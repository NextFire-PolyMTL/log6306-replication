commit 56bce678cb8a3e308313895e5fecd9b112ead4ae
Author: Patrik <zepatrik@users.noreply.github.com>
Date:   Mon Oct 12 11:35:50 2020 +0200

    refactor: use gobuffalo/pop for SQL abstraction (#2059)
    
    This patch replaces the existing SQL and memory managers with a pop based persister. Existing SQL migrations are compatible as they have been migrated to the new SQL abstraction in version 1.7.x. As a goodie, ORY Hydra now supports SQLite for both in-memory as well as on-disk (useful for development and very small deployments) databases!
    
    Closes #1730
    
    Co-authored-by: aeneasr <aeneas@ory.sh>
    Co-authored-by: hackerman <3372410+aeneasr@users.noreply.github.com>

diff --git a/.circleci/config.yml b/.circleci/config.yml
index 599dbcbc9..a76480b38 100644
--- a/.circleci/config.yml
+++ b/.circleci/config.yml
@@ -55,7 +55,7 @@ jobs:
           paths:
             - "/go/pkg/mod"
             - ".bin"
-      - run: .bin/go-acc -o coverage.txt ./... -- -failfast -timeout=20m
+      - run: .bin/go-acc -o coverage.txt ./... -- -failfast -timeout=20m -tags sqlite
       #      Running race conditions requires parallel tests, otherwise it's worthless (which is the case)
       #      - run: go test -race -short $(go list ./... | grep -v cmd)
       - run: test -z "$CIRCLE_PR_NUMBER" && goveralls -service=circle-ci -coverprofile=coverage.txt -repotoken=$COVERALLS_REPO_TOKEN || echo "forks are not allowed to push to coveralls"
@@ -207,14 +207,6 @@ workflows:
           filters:
             tags:
               only: /.*/
-      - test-e2e:
-          name: test-e2e-plugin
-          requires:
-            - test-e2e-memory
-          flavor: plugin
-          filters:
-            tags:
-              only: /.*/
       - changelog/generate:
           requires:
             - nancy/test
@@ -223,7 +215,6 @@ workflows:
             - test-e2e-postgres
             - test-e2e-mysql
             - test-e2e-cockroach
-            - test-e2e-plugin
             - docs/build
 #            - test-legacy-migrations-mysql
 #            - test-legacy-migrations-cockroach
@@ -242,7 +233,6 @@ workflows:
             - test-e2e-postgres
             - test-e2e-mysql
             - test-e2e-cockroach
-            - test-e2e-plugin
 #            - test-legacy-migrations-mysql
 #            - test-legacy-migrations-cockroach
           filters:
@@ -295,7 +285,6 @@ workflows:
             - test-e2e-postgres
             - test-e2e-mysql
             - test-e2e-cockroach
-            - test-e2e-plugin
             - changelog/generate
 #            - test-legacy-migrations-mysql
 #            - test-legacy-migrations-cockroach
diff --git a/.schema/api.swagger.json b/.schema/api.swagger.json
index 1928fc007..db1058ef8 100755
--- a/.schema/api.swagger.json
+++ b/.schema/api.swagger.json
@@ -2503,7 +2503,7 @@
           "type": "string"
         },
         "challenge": {
-          "description": "Challenge is the identifier (\"authorization challenge\") of the consent authorization request. It is used to\nidentify the session.",
+          "description": "ID is the identifier (\"authorization challenge\") of the consent authorization request. It is used to\nidentify the session.",
           "type": "string"
         },
         "client": {
@@ -2657,7 +2657,7 @@
       ],
       "properties": {
         "challenge": {
-          "description": "Challenge is the identifier (\"login challenge\") of the login request. It is used to\nidentify the session.",
+          "description": "ID is the identifier (\"login challenge\") of the login request. It is used to\nidentify the session.",
           "type": "string"
         },
         "client": {
diff --git a/Dockerfile b/Dockerfile
index c4765f38d..c10e13f46 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,6 +1,5 @@
 # To compile this image manually run:
 #
-# $ GO111MODULE=on GOOS=linux GOARCH=amd64 go build && docker build -t oryd/hydra:v1.0.0-rc.7_oryOS.10 . && rm hydra
 FROM alpine:3.12
 
 RUN apk add -U --no-cache ca-certificates
diff --git a/Dockerfile-e2e b/Dockerfile-e2e
index b0be350ba..67d1836ae 100644
--- a/Dockerfile-e2e
+++ b/Dockerfile-e2e
@@ -12,7 +12,7 @@ ENV GO111MODULE=on
 ADD . .
 
 RUN go install .
-RUN go build -buildmode=plugin -o /memtest.so ./test/e2e/plugin/memtest.go
+RUN go build -buildmode=plugin -tags sqlite -o /memtest.so ./test/e2e/plugin/memtest.go
 
 ENTRYPOINT ["hydra"]
 
diff --git a/Makefile b/Makefile
index 6cd4ae7f3..378058f06 100644
--- a/Makefile
+++ b/Makefile
@@ -40,7 +40,7 @@ lint: .bin/golangci-lint
 # Runs full test suite including tests where databases are enabled
 .PHONY: test-legacy-migrations
 test-legacy-migrations: test-resetdb sqlbin
-		source scripts/test-env.sh && go test -tags legacy_migration_test -failfast -timeout=20m ./internal/fizzmigrate
+		source scripts/test-env.sh && go test -tags legacy_migration_test sqlite -failfast -timeout=20m ./internal/fizzmigrate
 		docker rm -f hydra_test_database_mysql
 		docker rm -f hydra_test_database_postgres
 		docker rm -f hydra_test_database_cockroach
@@ -49,7 +49,7 @@ test-legacy-migrations: test-resetdb sqlbin
 .PHONY: test
 test: .bin/go-acc
 		make test-resetdb
-		source scripts/test-env.sh && go-acc ./... -- -failfast -timeout=20m
+		source scripts/test-env.sh && go-acc ./... -- -failfast -timeout=20m -tags sqlite
 		docker rm -f hydra_test_database_mysql
 		docker rm -f hydra_test_database_postgres
 		docker rm -f hydra_test_database_cockroach
@@ -71,7 +71,7 @@ test-resetdb: node_modules
 .PHONY: docker
 docker: .bin/packr2
 		packr2
-		CGO_ENABLED=0 GO111MODULE=on GOOS=linux GOARCH=amd64 go build
+		GO111MODULE=on GOOS=linux GOARCH=amd64 go build -tags sqlite
 		packr2 clean
 		docker build -t oryd/hydra:latest .
 		docker build -f Dockerfile-alpine -t oryd/hydra:latest-alpine .
@@ -88,13 +88,11 @@ e2e: node_modules test-resetdb
 		./test/e2e/circle-ci.bash mysql-jwt
 		./test/e2e/circle-ci.bash cockroach
 		./test/e2e/circle-ci.bash cockroach-jwt
-		./test/e2e/circle-ci.bash plugin
-		./test/e2e/circle-ci.bash plugin-jwt
 
 # Runs tests in short mode, without database adapters
 .PHONY: quicktest
 quicktest:
-		go test -failfast -short ./...
+		go test -failfast -short -tags sqlite ./...
 
 # Formats the code
 .PHONY: format
@@ -138,6 +136,7 @@ install-stable: .bin/packr2
 		git checkout $$HYDRA_LATEST
 		packr2
 		GO111MODULE=on go install \
+				-tags sqlite \
 				-ldflags "-X github.com/ory/hydra/cmd.Version=$$HYDRA_LATEST -X github.com/ory/hydra/cmd.Date=`TZ=UTC date -u '+%Y-%m-%dT%H:%M:%SZ'` -X github.com/ory/hydra/cmd.Commit=`git rev-parse HEAD`" \
 				.
 		packr2 clean
@@ -146,5 +145,5 @@ install-stable: .bin/packr2
 .PHONY: install
 install: .bin/packr2
 		packr2
-		GO111MODULE=on go install .
+		GO111MODULE=on go install -tags sqlite .
 		packr2 clean
diff --git a/client/client.go b/client/client.go
index 7b9a46a59..6e1d86898 100644
--- a/client/client.go
+++ b/client/client.go
@@ -24,6 +24,8 @@ import (
 	"strings"
 	"time"
 
+	"github.com/gobuffalo/pop/v5"
+
 	jose "gopkg.in/square/go-jose.v2" // Naming the dependency jose is important for go-swagger to work, see https://github.com/go-swagger/go-swagger/issues/1587
 
 	"github.com/ory/fosite"
@@ -202,6 +204,36 @@ func (Client) TableName() string {
 	return "hydra_client"
 }
 
+func (c *Client) BeforeSave(_ *pop.Connection) error {
+	if c.JSONWebKeys == nil {
+		c.JSONWebKeys = new(x.JoseJSONWebKeySet)
+	}
+
+	if c.Metadata == nil {
+		c.Metadata = []byte("{}")
+	}
+
+	if c.Audience == nil {
+		c.Audience = sqlxx.StringSlicePipeDelimiter{}
+	}
+
+	if c.AllowedCORSOrigins == nil {
+		c.AllowedCORSOrigins = sqlxx.StringSlicePipeDelimiter{}
+	}
+
+	if c.CreatedAt.IsZero() {
+		c.CreatedAt = time.Now()
+	}
+	c.CreatedAt = c.CreatedAt.UTC()
+
+	if c.UpdatedAt.IsZero() {
+		c.UpdatedAt = time.Now()
+	}
+	c.UpdatedAt = c.UpdatedAt.UTC()
+
+	return nil
+}
+
 func (c *Client) GetID() string {
 	return c.ID
 }
diff --git a/client/manager.go b/client/manager.go
index 727592b86..5db8a4b82 100644
--- a/client/manager.go
+++ b/client/manager.go
@@ -26,8 +26,6 @@ import (
 	"github.com/ory/fosite"
 )
 
-var _, _ Manager = new(SQLManager), new(MemoryManager)
-
 type Manager interface {
 	Storage
 
diff --git a/client/manager_memory.go b/client/manager_memory.go
deleted file mode 100644
index d553c1fc6..000000000
--- a/client/manager_memory.go
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @license 	Apache-2.0
- */
-
-package client
-
-import (
-	"context"
-	"sync"
-
-	"github.com/pkg/errors"
-
-	"github.com/ory/fosite"
-	"github.com/ory/x/pagination"
-	"github.com/ory/x/sqlcon"
-)
-
-type MemoryManager struct {
-	r       InternalRegistry
-	Clients []Client
-	sync.RWMutex
-}
-
-func NewMemoryManager(r InternalRegistry) *MemoryManager {
-	return &MemoryManager{
-		Clients: []Client{},
-		r:       r,
-	}
-}
-
-func (m *MemoryManager) GetConcreteClient(ctx context.Context, id string) (*Client, error) {
-	m.RLock()
-	defer m.RUnlock()
-
-	for _, c := range m.Clients {
-		if c.GetID() == id {
-			return &c, nil
-		}
-	}
-
-	return nil, errors.WithStack(sqlcon.ErrNoRows)
-}
-
-func (m *MemoryManager) GetClient(ctx context.Context, id string) (fosite.Client, error) {
-	return m.GetConcreteClient(ctx, id)
-}
-
-func (m *MemoryManager) UpdateClient(ctx context.Context, c *Client) error {
-	o, err := m.GetClient(ctx, c.GetID())
-	if err != nil {
-		return err
-	}
-
-	if c.Secret == "" {
-		c.Secret = string(o.GetHashedSecret())
-	} else {
-		h, err := m.r.ClientHasher().Hash(ctx, []byte(c.Secret))
-		if err != nil {
-			return errors.WithStack(err)
-		}
-		c.Secret = string(h)
-	}
-
-	m.Lock()
-	defer m.Unlock()
-	for k, f := range m.Clients {
-		if f.GetID() == c.GetID() {
-			m.Clients[k] = *c
-		}
-	}
-
-	return nil
-}
-
-func (m *MemoryManager) Authenticate(ctx context.Context, id string, secret []byte) (*Client, error) {
-	m.RLock()
-	defer m.RUnlock()
-
-	c, err := m.GetConcreteClient(ctx, id)
-	if err != nil {
-		return nil, err
-	}
-
-	if err := m.r.ClientHasher().Compare(ctx, c.GetHashedSecret(), secret); err != nil {
-		return nil, errors.WithStack(err)
-	}
-
-	return c, nil
-}
-
-func (m *MemoryManager) CreateClient(ctx context.Context, c *Client) error {
-	if _, err := m.GetConcreteClient(ctx, c.GetID()); err == nil {
-		return sqlcon.ErrUniqueViolation
-	}
-
-	m.Lock()
-	defer m.Unlock()
-
-	hash, err := m.r.ClientHasher().Hash(ctx, []byte(c.Secret))
-	if err != nil {
-		return errors.WithStack(err)
-	}
-	c.Secret = string(hash)
-
-	m.Clients = append(m.Clients, *c)
-	return nil
-}
-
-func (m *MemoryManager) DeleteClient(ctx context.Context, id string) error {
-	m.Lock()
-	defer m.Unlock()
-
-	for k, f := range m.Clients {
-		if f.GetID() == id {
-			m.Clients = append(m.Clients[:k], m.Clients[k+1:]...)
-			return nil
-		}
-	}
-
-	return nil
-}
-
-func (m *MemoryManager) GetClients(ctx context.Context, limit, offset int) (clients []Client, err error) {
-	m.RLock()
-	defer m.RUnlock()
-
-	start, end := pagination.Index(limit, offset, len(m.Clients))
-	return append(clients, m.Clients[start:end]...), nil
-}
-
-func (m *MemoryManager) CountClients(ctx context.Context) (n int, err error) {
-	return len(m.Clients), nil
-}
diff --git a/client/manager_sql.go b/client/manager_sql.go
deleted file mode 100644
index e9bdcbb96..000000000
--- a/client/manager_sql.go
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @license 	Apache-2.0
- */
-
-package client
-
-import (
-	"context"
-	"fmt"
-	"strings"
-	"time"
-
-	"github.com/jmoiron/sqlx"
-	"github.com/pkg/errors"
-
-	"github.com/ory/fosite"
-	"github.com/ory/hydra/x"
-	"github.com/ory/x/sqlcon"
-)
-
-func NewSQLManager(db *sqlx.DB, r InternalRegistry) *SQLManager {
-	return &SQLManager{
-		r:  r,
-		DB: db,
-	}
-}
-
-type SQLManager struct {
-	r  InternalRegistry
-	DB *sqlx.DB
-}
-
-var sqlParams = []string{
-	"id",
-	"client_name",
-	"client_secret",
-	"redirect_uris",
-	"grant_types",
-	"response_types",
-	"scope",
-	"owner",
-	"policy_uri",
-	"tos_uri",
-	"client_uri",
-	"subject_type",
-	"logo_uri",
-	"contacts",
-	"client_secret_expires_at",
-	"sector_identifier_uri",
-	"jwks",
-	"jwks_uri",
-	"token_endpoint_auth_method",
-	"token_endpoint_auth_signing_alg",
-	"request_uris",
-	"request_object_signing_alg",
-	"userinfo_signed_response_alg",
-	"allowed_cors_origins",
-	"audience",
-	"updated_at",
-	"created_at",
-	"frontchannel_logout_uri",
-	"frontchannel_logout_session_required",
-	"post_logout_redirect_uris",
-	"backchannel_logout_uri",
-	"backchannel_logout_session_required",
-	"metadata",
-}
-
-func (m *SQLManager) GetConcreteClient(ctx context.Context, id string) (*Client, error) {
-	var d Client
-	if err := m.DB.GetContext(ctx, &d, m.DB.Rebind("SELECT * FROM hydra_client WHERE id=?"), id); err != nil {
-		return nil, sqlcon.HandleError(err)
-	}
-
-	return &d, nil
-}
-
-func (m *SQLManager) GetClient(ctx context.Context, id string) (fosite.Client, error) {
-	return m.GetConcreteClient(ctx, id)
-}
-
-func (m *SQLManager) UpdateClient(ctx context.Context, c *Client) error {
-	o, err := m.GetClient(ctx, c.GetID())
-	if err != nil {
-		return errors.WithStack(err)
-	}
-
-	if c.Secret == "" {
-		c.Secret = string(o.GetHashedSecret())
-	} else {
-		h, err := m.r.ClientHasher().Hash(ctx, []byte(c.Secret))
-		if err != nil {
-			return errors.WithStack(err)
-		}
-		c.Secret = string(h)
-	}
-
-	var query []string
-	for _, param := range sqlParams {
-		query = append(query, fmt.Sprintf("%s=:%s", param, param))
-	}
-
-	/* #nosec G201 - query is constructed using predefined variables only that are never modified */
-	if _, err := m.DB.NamedExecContext(
-		ctx,
-		fmt.Sprintf(`UPDATE hydra_client SET %s WHERE id=:id`, strings.Join(query, ", ")),
-		setDefaults(c),
-	); err != nil {
-		return sqlcon.HandleError(err)
-	}
-	return nil
-}
-
-func (m *SQLManager) Authenticate(ctx context.Context, id string, secret []byte) (*Client, error) {
-	c, err := m.GetConcreteClient(ctx, id)
-	if err != nil {
-		return nil, errors.WithStack(err)
-	}
-
-	if err := m.r.ClientHasher().Compare(ctx, c.GetHashedSecret(), secret); err != nil {
-		return nil, errors.WithStack(err)
-	}
-
-	return c, nil
-}
-
-func (m *SQLManager) CreateClient(ctx context.Context, c *Client) error {
-	h, err := m.r.ClientHasher().Hash(ctx, []byte(c.Secret))
-	if err != nil {
-		return errors.WithStack(err)
-	}
-	c.Secret = string(h)
-
-	/* #nosec G201 - sqlParams is a "constant" array */
-	if _, err := m.DB.NamedExecContext(ctx,
-		fmt.Sprintf(
-			"INSERT INTO hydra_client (%s) VALUES (%s)",
-			strings.Join(sqlParams, ", "),
-			":"+strings.Join(sqlParams, ", :"),
-		),
-		setDefaults(c),
-	); err != nil {
-		return sqlcon.HandleError(err)
-	}
-
-	return nil
-}
-
-func (m *SQLManager) DeleteClient(ctx context.Context, id string) error {
-	if _, err := m.DB.ExecContext(ctx, m.DB.Rebind(`DELETE FROM hydra_client WHERE id=?`), id); err != nil {
-		return sqlcon.HandleError(err)
-	}
-	return nil
-}
-
-func (m *SQLManager) GetClients(ctx context.Context, limit, offset int) (clients []Client, err error) {
-	clients = []Client{}
-
-	if err := m.DB.SelectContext(ctx, &clients, m.DB.Rebind("SELECT * FROM hydra_client ORDER BY id LIMIT ? OFFSET ?"), limit, offset); err != nil {
-		return nil, sqlcon.HandleError(err)
-	}
-
-	return clients, nil
-}
-
-func (m *SQLManager) CountClients(ctx context.Context) (int, error) {
-	var n int
-	if err := m.DB.QueryRow("SELECT count(*) FROM hydra_client").Scan(&n); err != nil {
-		fmt.Println(err.Error())
-		return 0, sqlcon.HandleError(err)
-	}
-
-	return n, nil
-}
-
-func setDefaults(c *Client) *Client {
-	if c.JSONWebKeys == nil {
-		c.JSONWebKeys = new(x.JoseJSONWebKeySet)
-	}
-
-	if c.Metadata == nil {
-		c.Metadata = []byte("{}")
-	}
-
-	if c.CreatedAt.IsZero() {
-		c.CreatedAt = time.Now().UTC()
-	}
-
-	if c.UpdatedAt.IsZero() {
-		c.UpdatedAt = time.Now().UTC()
-	}
-
-	return c
-}
diff --git a/client/manager_test.go b/client/manager_test.go
index 2ff733093..1158ba253 100644
--- a/client/manager_test.go
+++ b/client/manager_test.go
@@ -24,20 +24,21 @@ import (
 	"fmt"
 	"testing"
 
+	"github.com/ory/hydra/internal"
+
 	"github.com/ory/hydra/driver"
 
 	_ "github.com/go-sql-driver/mysql"
 	_ "github.com/jackc/pgx/v4/stdlib"
 
 	. "github.com/ory/hydra/client"
-	"github.com/ory/hydra/internal"
 )
 
 func TestManagers(t *testing.T) {
 	conf := internal.NewConfigurationWithDefaults()
 
 	registries := map[string]driver.Registry{
-		"memory": internal.NewRegistryMemory(conf),
+		"memory": internal.NewRegistryMemory(t, conf),
 	}
 
 	if !testing.Short() {
diff --git a/client/manager_test_helpers.go b/client/manager_test_helpers.go
index d4b27373f..d1a0227c2 100644
--- a/client/manager_test_helpers.go
+++ b/client/manager_test_helpers.go
@@ -90,7 +90,7 @@ func TestHelperCreateGetUpdateDeleteClient(k string, m Storage) func(t *testing.
 			Contacts:                          []string{"aeneas1", "aeneas2"},
 			SecretExpiresAt:                   0,
 			SectorIdentifierURI:               "https://sector",
-			JSONWebKeys:                       &x.JoseJSONWebKeySet{JSONWebKeySet: &jose.JSONWebKeySet{Keys: []jose.JSONWebKey{{KeyID: "foo", Key: []byte("asdf"), Certificates: []*x509.Certificate{}}}}},
+			JSONWebKeys:                       &x.JoseJSONWebKeySet{JSONWebKeySet: &jose.JSONWebKeySet{Keys: []jose.JSONWebKey{{KeyID: "foo", Key: []byte("asdf"), Certificates: []*x509.Certificate{}, CertificateThumbprintSHA1: []uint8{}, CertificateThumbprintSHA256: []uint8{}}}}},
 			JSONWebKeysURI:                    "https://...",
 			TokenEndpointAuthMethod:           "none",
 			TokenEndpointAuthSigningAlgorithm: "RS256",
@@ -200,8 +200,9 @@ func compare(t *testing.T, expected *Client, actual fosite.Client, k string) {
 		assert.EqualValues(t, expected.SecretExpiresAt, actual.SecretExpiresAt)
 		assert.EqualValues(t, expected.SectorIdentifierURI, actual.SectorIdentifierURI)
 		assert.EqualValues(t, expected.UserinfoSignedResponseAlg, actual.UserinfoSignedResponseAlg)
-		assert.EqualValues(t, expected.CreatedAt.Unix(), actual.CreatedAt.Unix())
-		assert.EqualValues(t, expected.UpdatedAt.Unix(), actual.UpdatedAt.Unix())
+		assert.EqualValues(t, expected.CreatedAt.UTC().Unix(), actual.CreatedAt.UTC().Unix())
+		// these values are not the same because of https://github.com/gobuffalo/pop/issues/591
+		//assert.EqualValues(t, expected.UpdatedAt.UTC().Unix(), actual.UpdatedAt.UTC().Unix(), "%s\n%s", expected.UpdatedAt.String(), actual.UpdatedAt.String())
 		assert.EqualValues(t, expected.FrontChannelLogoutURI, actual.FrontChannelLogoutURI)
 		assert.EqualValues(t, expected.FrontChannelLogoutSessionRequired, actual.FrontChannelLogoutSessionRequired)
 		assert.EqualValues(t, expected.PostLogoutRedirectURIs, actual.PostLogoutRedirectURIs)
diff --git a/client/sdk_test.go b/client/sdk_test.go
index 6ad384d64..abdc85957 100644
--- a/client/sdk_test.go
+++ b/client/sdk_test.go
@@ -21,6 +21,7 @@
 package client_test
 
 import (
+	"context"
 	"fmt"
 	"net/http/httptest"
 	"strings"
@@ -68,6 +69,10 @@ func createTestClient(prefix string) *models.OAuth2Client {
 		UserinfoSignedResponseAlg: "none",
 		SubjectType:               "public",
 		Metadata:                  map[string]interface{}{"foo": "bar"},
+		// because these values are not nullable in the SQL schema, we have to set them not nil
+		AllowedCorsOrigins: models.StringSlicePipeDelimiter{},
+		Audience:           models.StringSlicePipeDelimiter{},
+		Jwks:               models.JoseJSONWebKeySet(map[string]interface{}{}),
 		// SectorIdentifierUri:   "https://sector.com/foo",
 	}
 }
@@ -76,7 +81,7 @@ func TestClientSDK(t *testing.T) {
 	conf := internal.NewConfigurationWithDefaults()
 	viper.Set(configuration.ViperKeySubjectTypesSupported, []string{"public"})
 	viper.Set(configuration.ViperKeyDefaultClientScope, []string{"foo", "bar"})
-	r := internal.NewRegistryMemory(conf)
+	r := internal.NewRegistryMemory(t, conf)
 
 	router := x.NewRouterAdmin()
 	handler := client.NewHandler(r)
@@ -114,7 +119,7 @@ func TestClientSDK(t *testing.T) {
 
 		// secret is not returned on GetOAuth2Client
 		compareClient.ClientSecret = ""
-		gresult, err := c.Admin.GetOAuth2Client(admin.NewGetOAuth2ClientParams().WithID(createClient.ClientID))
+		gresult, err := c.Admin.GetOAuth2Client(admin.NewGetOAuth2ClientParams().WithID(createClient.ClientID).WithContext(context.Background()))
 		require.NoError(t, err)
 		assert.NotEmpty(t, gresult.Payload.UpdatedAt)
 		gresult.Payload.UpdatedAt = strfmt.DateTime{}
@@ -144,6 +149,8 @@ func TestClientSDK(t *testing.T) {
 		require.NoError(t, err)
 		assert.NotEmpty(t, uresult.Payload.UpdatedAt)
 		uresult.Payload.UpdatedAt = strfmt.DateTime{}
+		assert.NotEmpty(t, uresult.Payload.CreatedAt)
+		uresult.Payload.CreatedAt = strfmt.DateTime{}
 		assert.EqualValues(t, compareClient, uresult.Payload)
 
 		// create another client
@@ -152,6 +159,8 @@ func TestClientSDK(t *testing.T) {
 		require.NoError(t, err)
 		assert.NotEmpty(t, uresult.Payload.UpdatedAt)
 		uresult.Payload.UpdatedAt = strfmt.DateTime{}
+		assert.NotEmpty(t, uresult.Payload.CreatedAt)
+		uresult.Payload.CreatedAt = strfmt.DateTime{}
 		assert.EqualValues(t, updateClient, uresult.Payload)
 
 		// again, test if secret is not returned on Get
@@ -161,6 +170,8 @@ func TestClientSDK(t *testing.T) {
 		require.NoError(t, err)
 		assert.NotEmpty(t, gresult.Payload.UpdatedAt)
 		gresult.Payload.UpdatedAt = strfmt.DateTime{}
+		assert.NotEmpty(t, gresult.Payload.CreatedAt)
+		gresult.Payload.CreatedAt = strfmt.DateTime{}
 		assert.EqualValues(t, compareClient, gresult.Payload)
 
 		// client can not be found after being deleted
diff --git a/consent/handler.go b/consent/handler.go
index 9e1c0da05..ae1452382 100644
--- a/consent/handler.go
+++ b/consent/handler.go
@@ -335,7 +335,7 @@ func (h *Handler) AcceptLoginRequest(w http.ResponseWriter, r *http.Request, ps
 		return
 	}
 
-	p.Challenge = challenge
+	p.ID = challenge
 	ar, err := h.r.ConsentManager().GetLoginRequest(r.Context(), challenge)
 	if err != nil {
 		h.r.Writer().WriteError(w, r, err)
@@ -428,7 +428,7 @@ func (h *Handler) RejectLoginRequest(w http.ResponseWriter, r *http.Request, ps
 
 	request, err := h.r.ConsentManager().HandleLoginRequest(r.Context(), challenge, &HandledLoginRequest{
 		Error:       &p,
-		Challenge:   challenge,
+		ID:          challenge,
 		RequestedAt: ar.RequestedAt,
 	})
 	if err != nil {
@@ -564,7 +564,7 @@ func (h *Handler) AcceptConsentRequest(w http.ResponseWriter, r *http.Request, p
 		return
 	}
 
-	p.Challenge = challenge
+	p.ID = challenge
 	p.RequestedAt = cr.RequestedAt
 	p.HandledAt = sqlxx.NullTime(time.Now().UTC())
 
@@ -647,7 +647,7 @@ func (h *Handler) RejectConsentRequest(w http.ResponseWriter, r *http.Request, p
 
 	request, err := h.r.ConsentManager().HandleConsentRequest(r.Context(), challenge, &HandledConsentRequest{
 		Error:       &p,
-		Challenge:   challenge,
+		ID:          challenge,
 		RequestedAt: hr.RequestedAt,
 		HandledAt:   sqlxx.NullTime(time.Now().UTC()),
 	})
diff --git a/consent/handler_test.go b/consent/handler_test.go
index 794ba58f4..e05c86a4f 100644
--- a/consent/handler_test.go
+++ b/consent/handler_test.go
@@ -39,7 +39,7 @@ import (
 
 //func TestLogout(t *testing.T) {
 //	conf := internal.NewConfigurationWithDefaults()
-//	reg := internal.NewRegistryMemory(conf)
+//	reg := internal.NewRegistryMemory(t, conf)
 //
 //	r := x.NewRouterPublic()
 //	h := NewHandler(reg, conf)
@@ -103,13 +103,15 @@ func TestGetLogoutRequest(t *testing.T) {
 			challenge := "challenge" + key
 
 			conf := internal.NewConfigurationWithDefaults()
-			reg := internal.NewRegistryMemory(conf)
+			reg := internal.NewRegistryMemory(t, conf)
 
 			if tc.exists {
+				cl := &client.Client{ID: "client" + key}
+				require.NoError(t, reg.ClientManager().CreateClient(context.Background(), cl))
 				require.NoError(t, reg.ConsentManager().CreateLogoutRequest(context.TODO(), &LogoutRequest{
-					Client:    &client.Client{ID: "client" + key},
-					Challenge: challenge,
-					WasUsed:   tc.used,
+					Client:  cl,
+					ID:      challenge,
+					WasUsed: tc.used,
 				}))
 			}
 
@@ -142,14 +144,20 @@ func TestGetLoginRequest(t *testing.T) {
 			challenge := "challenge" + key
 
 			conf := internal.NewConfigurationWithDefaults()
-			reg := internal.NewRegistryMemory(conf)
+			reg := internal.NewRegistryMemory(t, conf)
 
 			if tc.exists {
-				require.NoError(t, reg.ConsentManager().CreateLoginRequest(context.TODO(), &LoginRequest{
-					Client:     &client.Client{ID: "client" + key},
-					Challenge:  challenge,
-					WasHandled: tc.handled,
+				cl := &client.Client{ID: "client" + key}
+				require.NoError(t, reg.ClientManager().CreateClient(context.Background(), cl))
+				require.NoError(t, reg.ConsentManager().CreateLoginRequest(context.Background(), &LoginRequest{
+					Client: cl,
+					ID:     challenge,
 				}))
+
+				if tc.handled {
+					_, err := reg.ConsentManager().HandleLoginRequest(context.Background(), challenge, &HandledLoginRequest{ID: challenge, WasUsed: true})
+					require.NoError(t, err)
+				}
 			}
 
 			h := NewHandler(reg, conf)
@@ -181,14 +189,23 @@ func TestGetConsentRequest(t *testing.T) {
 			challenge := "challenge" + key
 
 			conf := internal.NewConfigurationWithDefaults()
-			reg := internal.NewRegistryMemory(conf)
+			reg := internal.NewRegistryMemory(t, conf)
 
 			if tc.exists {
-				require.NoError(t, reg.ConsentManager().CreateConsentRequest(context.TODO(), &ConsentRequest{
-					Client:     &client.Client{ID: "client" + key},
-					Challenge:  challenge,
-					WasHandled: tc.handled,
+				cl := &client.Client{ID: "client" + key}
+				require.NoError(t, reg.ClientManager().CreateClient(context.Background(), cl))
+				require.NoError(t, reg.ConsentManager().CreateConsentRequest(context.Background(), &ConsentRequest{
+					Client: cl,
+					ID:     challenge,
 				}))
+
+				if tc.handled {
+					_, err := reg.ConsentManager().HandleConsentRequest(context.Background(), challenge, &HandledConsentRequest{
+						ID:      challenge,
+						WasUsed: true,
+					})
+					require.NoError(t, err)
+				}
 			}
 
 			h := NewHandler(reg, conf)
diff --git a/consent/helper_test.go b/consent/helper_test.go
index 53d6a819a..9857672cd 100644
--- a/consent/helper_test.go
+++ b/consent/helper_test.go
@@ -55,35 +55,35 @@ func TestMatchScopes(t *testing.T) {
 		expectChallenge string
 	}{
 		{
-			granted:         []HandledConsentRequest{{Challenge: "1", GrantedScope: []string{"foo", "bar"}}},
+			granted:         []HandledConsentRequest{{ID: "1", GrantedScope: []string{"foo", "bar"}}},
 			requested:       []string{"foo", "bar"},
 			expectChallenge: "1",
 		},
 		{
-			granted:         []HandledConsentRequest{{Challenge: "1", GrantedScope: []string{"foo", "bar"}}},
+			granted:         []HandledConsentRequest{{ID: "1", GrantedScope: []string{"foo", "bar"}}},
 			requested:       []string{"foo", "bar", "baz"},
 			expectChallenge: "",
 		},
 		{
 			granted: []HandledConsentRequest{
-				{Challenge: "1", GrantedScope: []string{"foo", "bar"}},
-				{Challenge: "2", GrantedScope: []string{"foo", "bar"}},
+				{ID: "1", GrantedScope: []string{"foo", "bar"}},
+				{ID: "2", GrantedScope: []string{"foo", "bar"}},
 			},
 			requested:       []string{"foo", "bar"},
 			expectChallenge: "1",
 		},
 		{
 			granted: []HandledConsentRequest{
-				{Challenge: "1", GrantedScope: []string{"foo", "bar"}},
-				{Challenge: "2", GrantedScope: []string{"foo", "bar", "baz"}},
+				{ID: "1", GrantedScope: []string{"foo", "bar"}},
+				{ID: "2", GrantedScope: []string{"foo", "bar", "baz"}},
 			},
 			requested:       []string{"foo", "bar", "baz"},
 			expectChallenge: "2",
 		},
 		{
 			granted: []HandledConsentRequest{
-				{Challenge: "1", GrantedScope: []string{"foo", "bar"}},
-				{Challenge: "2", GrantedScope: []string{"foo", "bar", "baz"}},
+				{ID: "1", GrantedScope: []string{"foo", "bar"}},
+				{ID: "2", GrantedScope: []string{"foo", "bar", "baz"}},
 			},
 			requested:       []string{"zab"},
 			expectChallenge: "",
@@ -95,7 +95,7 @@ func TestMatchScopes(t *testing.T) {
 				assert.Nil(t, got)
 				return
 			}
-			assert.Equal(t, tc.expectChallenge, got.Challenge)
+			assert.Equal(t, tc.expectChallenge, got.ID)
 		})
 	}
 }
diff --git a/consent/manager.go b/consent/manager.go
index 469ef8471..8675706e8 100644
--- a/consent/manager.go
+++ b/consent/manager.go
@@ -26,14 +26,16 @@ import (
 	"github.com/ory/hydra/client"
 )
 
-var _, _ Manager = new(SQLManager), new(MemoryManager)
-
 type ForcedObfuscatedLoginSession struct {
 	ClientID          string `db:"client_id"`
 	Subject           string `db:"subject"`
 	SubjectObfuscated string `db:"subject_obfuscated"`
 }
 
+func (_ *ForcedObfuscatedLoginSession) TableName() string {
+	return "hydra_oauth2_obfuscated_authentication_session"
+}
+
 type Manager interface {
 	CreateConsentRequest(ctx context.Context, req *ConsentRequest) error
 	GetConsentRequest(ctx context.Context, challenge string) (*ConsentRequest, error)
diff --git a/consent/manager_memory.go b/consent/manager_memory.go
deleted file mode 100644
index f68486a83..000000000
--- a/consent/manager_memory.go
+++ /dev/null
@@ -1,578 +0,0 @@
-/*
- * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @Copyright 	2017-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @license 	Apache-2.0
- */
-
-package consent
-
-import (
-	"context"
-	"sync"
-	"time"
-
-	"github.com/ory/hydra/client"
-
-	"github.com/pkg/errors"
-
-	"github.com/ory/fosite"
-	"github.com/ory/x/pagination"
-
-	"github.com/ory/hydra/x"
-)
-
-type MemoryManager struct {
-	consentRequests        map[string]ConsentRequest
-	logoutRequests         map[string]LogoutRequest
-	handledConsentRequests map[string]HandledConsentRequest
-	authRequests           map[string]LoginRequest
-	handledAuthRequests    map[string]HandledLoginRequest
-	authSessions           map[string]LoginSession
-	pairwise               []ForcedObfuscatedLoginSession
-	m                      map[string]*sync.RWMutex
-	r                      InternalRegistry
-}
-
-func NewMemoryManager(r InternalRegistry) *MemoryManager {
-	return &MemoryManager{
-		consentRequests:        map[string]ConsentRequest{},
-		logoutRequests:         map[string]LogoutRequest{},
-		handledConsentRequests: map[string]HandledConsentRequest{},
-		authRequests:           map[string]LoginRequest{},
-		handledAuthRequests:    map[string]HandledLoginRequest{},
-		authSessions:           map[string]LoginSession{},
-		pairwise:               []ForcedObfuscatedLoginSession{},
-		r:                      r,
-		m: map[string]*sync.RWMutex{
-			"logoutRequests":         new(sync.RWMutex),
-			"consentRequests":        new(sync.RWMutex),
-			"handledConsentRequests": new(sync.RWMutex),
-			"authRequests":           new(sync.RWMutex),
-			"handledAuthRequests":    new(sync.RWMutex),
-			"authSessions":           new(sync.RWMutex),
-		},
-	}
-}
-
-func (m *MemoryManager) CreateForcedObfuscatedLoginSession(ctx context.Context, s *ForcedObfuscatedLoginSession) error {
-	for k, v := range m.pairwise {
-		if v.Subject == s.Subject && v.ClientID == s.ClientID {
-			m.pairwise[k] = *s
-			return nil
-		}
-	}
-
-	m.pairwise = append(m.pairwise, *s)
-	return nil
-}
-
-func (m *MemoryManager) GetForcedObfuscatedLoginSession(ctx context.Context, client, obfuscated string) (*ForcedObfuscatedLoginSession, error) {
-	for _, v := range m.pairwise {
-		if v.SubjectObfuscated == obfuscated && v.ClientID == client {
-			return &v, nil
-		}
-	}
-
-	return nil, errors.WithStack(x.ErrNotFound)
-}
-
-func (m *MemoryManager) RevokeSubjectConsentSession(ctx context.Context, user string) error {
-	return m.RevokeSubjectClientConsentSession(ctx, user, "")
-}
-
-func (m *MemoryManager) RevokeSubjectClientConsentSession(ctx context.Context, user, client string) error {
-	var found bool
-
-	m.m["handledConsentRequests"].RLock()
-	for k, c := range m.handledConsentRequests {
-		m.m["handledConsentRequests"].RUnlock()
-		cr, err := m.GetConsentRequest(ctx, c.Challenge)
-		if err != nil {
-			return err
-		}
-		m.m["handledConsentRequests"].RLock()
-
-		if cr.Subject == user &&
-			(client == "" ||
-				(client != "" && cr.Client.GetID() == client)) {
-			delete(m.handledConsentRequests, k)
-
-			m.m["consentRequests"].Lock()
-			delete(m.consentRequests, k)
-			m.m["consentRequests"].Unlock()
-
-			if err := m.r.OAuth2Storage().RevokeAccessToken(ctx, c.Challenge); errors.Is(err, fosite.ErrNotFound) {
-				// do nothing
-			} else if err != nil {
-				return err
-			}
-			if err := m.r.OAuth2Storage().RevokeRefreshToken(ctx, c.Challenge); errors.Is(err, fosite.ErrNotFound) {
-				// do nothing
-			} else if err != nil {
-				return err
-			}
-			found = true
-		}
-	}
-	m.m["handledConsentRequests"].RUnlock()
-
-	if !found {
-		return errors.WithStack(x.ErrNotFound)
-	}
-	return nil
-}
-
-func (m *MemoryManager) RevokeSubjectLoginSession(ctx context.Context, user string) error {
-	m.m["authSessions"].Lock()
-	defer m.m["authSessions"].Unlock()
-
-	var found bool
-	for k, c := range m.authSessions {
-		if c.Subject == user {
-			delete(m.authSessions, k)
-			found = true
-		}
-	}
-
-	if !found {
-		return errors.WithStack(x.ErrNotFound)
-	}
-	return nil
-}
-
-func (m *MemoryManager) CreateConsentRequest(ctx context.Context, c *ConsentRequest) error {
-	m.m["consentRequests"].Lock()
-	defer m.m["consentRequests"].Unlock()
-	if _, ok := m.consentRequests[c.Challenge]; ok {
-		return errors.New("Key already exists")
-	}
-	m.consentRequests[c.Challenge] = *c
-	return nil
-}
-
-func (m *MemoryManager) GetConsentRequest(ctx context.Context, challenge string) (*ConsentRequest, error) {
-	m.m["consentRequests"].RLock()
-	defer m.m["consentRequests"].RUnlock()
-
-	c, ok := m.consentRequests[challenge]
-	if !ok {
-		return nil, errors.WithStack(x.ErrNotFound)
-	}
-
-	m.m["handledConsentRequests"].RLock()
-	for _, h := range m.handledConsentRequests {
-		if h.Challenge == c.Challenge {
-			c.WasHandled = h.WasUsed
-		}
-	}
-	m.m["handledConsentRequests"].RUnlock()
-
-	c.Client.ID = c.Client.GetID()
-	return &c, nil
-}
-
-func (m *MemoryManager) HandleConsentRequest(ctx context.Context, challenge string, r *HandledConsentRequest) (*ConsentRequest, error) {
-	m.m["handledConsentRequests"].Lock()
-	m.handledConsentRequests[r.Challenge] = *r
-	m.m["handledConsentRequests"].Unlock()
-	return m.GetConsentRequest(ctx, challenge)
-}
-
-func (m *MemoryManager) VerifyAndInvalidateConsentRequest(ctx context.Context, verifier string) (*HandledConsentRequest, error) {
-	m.m["consentRequests"].RLock()
-	for k := range m.consentRequests {
-		c := m.consentRequests[k]
-		if c.Verifier == verifier {
-			m.m["handledConsentRequests"].RLock()
-			for kk := range m.handledConsentRequests {
-				h := m.handledConsentRequests[kk]
-				if h.Challenge == c.Challenge {
-					m.m["consentRequests"].RUnlock()
-					m.m["handledConsentRequests"].RUnlock()
-					if h.WasUsed {
-						return nil, errors.WithStack(fosite.ErrInvalidRequest.WithDebug("Consent verifier has been used already"))
-					}
-
-					h.WasUsed = true
-					if _, err := m.HandleConsentRequest(ctx, h.Challenge, &h); err != nil {
-						return nil, err
-					}
-
-					c.Client.ID = c.Client.GetID()
-					h.ConsentRequest = &c
-					return &h, nil
-				}
-			}
-			m.m["handledConsentRequests"].RUnlock()
-		}
-	}
-	m.m["consentRequests"].RUnlock()
-	return nil, errors.WithStack(x.ErrNotFound)
-}
-
-func (m *MemoryManager) FindGrantedAndRememberedConsentRequests(ctx context.Context, client, subject string) ([]HandledConsentRequest, error) {
-	var rs []HandledConsentRequest
-
-	m.m["handledConsentRequests"].RLock()
-	for _, c := range m.handledConsentRequests {
-		m.m["handledConsentRequests"].RUnlock()
-		cr, err := m.GetConsentRequest(ctx, c.Challenge)
-		if errors.Is(err, fosite.ErrNotFound) {
-			return nil, errors.WithStack(ErrNoPreviousConsentFound)
-		} else if err != nil {
-			return nil, err
-		}
-		m.m["handledConsentRequests"].RLock()
-
-		if subject != cr.Subject {
-			continue
-		}
-
-		if client != cr.Client.GetID() {
-			continue
-		}
-
-		if c.HasError() {
-			continue
-		}
-
-		if !c.Remember {
-			continue
-		}
-
-		if cr.Skip {
-			continue
-		}
-
-		if c.RememberFor > 0 && c.RequestedAt.Add(time.Duration(c.RememberFor)*time.Second).Before(time.Now().UTC()) {
-			continue
-		}
-
-		cr.Client.ID = cr.Client.GetID()
-		c.ConsentRequest = cr
-		rs = append(rs, c)
-	}
-	m.m["handledConsentRequests"].RUnlock()
-
-	if len(rs) == 0 {
-		return nil, errors.WithStack(ErrNoPreviousConsentFound)
-	}
-
-	return rs, nil
-}
-
-func (m *MemoryManager) FindSubjectsGrantedConsentRequests(ctx context.Context, subject string, limit, offset int) ([]HandledConsentRequest, error) {
-	var rs []HandledConsentRequest
-
-	m.m["handledConsentRequests"].RLock()
-	for _, c := range m.handledConsentRequests {
-		m.m["handledConsentRequests"].RUnlock()
-		cr, err := m.GetConsentRequest(ctx, c.Challenge)
-		if err != nil {
-			return nil, err
-		}
-		m.m["handledConsentRequests"].RLock()
-
-		if subject != cr.Subject {
-			continue
-		}
-
-		if c.HasError() {
-			continue
-		}
-
-		if cr.Skip {
-			continue
-		}
-
-		if c.RememberFor > 0 && c.RequestedAt.Add(time.Duration(c.RememberFor)*time.Second).Before(time.Now().UTC()) {
-			continue
-		}
-
-		cr.Client.ID = cr.Client.GetID()
-		c.ConsentRequest = cr
-		rs = append(rs, c)
-	}
-	m.m["handledConsentRequests"].RUnlock()
-
-	if len(rs) == 0 {
-		return nil, errors.WithStack(ErrNoPreviousConsentFound)
-	}
-
-	if limit < 0 && offset < 0 {
-		return rs, nil
-	}
-
-	start, end := pagination.Index(limit, offset, len(rs))
-	return rs[start:end], nil
-}
-
-func (m *MemoryManager) CountSubjectsGrantedConsentRequests(ctx context.Context, subject string) (int, error) {
-	var rs []HandledConsentRequest
-	for _, c := range m.handledConsentRequests {
-		cr, err := m.GetConsentRequest(ctx, c.Challenge)
-		if err != nil {
-			return 0, err
-		}
-
-		if subject != cr.Subject {
-			continue
-		}
-
-		if c.HasError() {
-			continue
-		}
-
-		if cr.Skip {
-			continue
-		}
-
-		if c.RememberFor > 0 && c.RequestedAt.Add(time.Duration(c.RememberFor)*time.Second).Before(time.Now().UTC()) {
-			continue
-		}
-
-		cr.Client.ID = cr.Client.GetID()
-		c.ConsentRequest = cr
-		rs = append(rs, c)
-	}
-
-	return len(rs), nil
-}
-
-func (m *MemoryManager) ConfirmLoginSession(ctx context.Context, id string, subject string, remember bool) error {
-	m.m["authSessions"].Lock()
-	defer m.m["authSessions"].Unlock()
-	if c, ok := m.authSessions[id]; ok {
-		c.Remember = remember
-		c.Subject = subject
-		c.AuthenticatedAt = time.Now().UTC()
-		m.authSessions[id] = c
-		return nil
-	}
-	return errors.WithStack(x.ErrNotFound)
-}
-
-func (m *MemoryManager) GetRememberedLoginSession(ctx context.Context, id string) (*LoginSession, error) {
-	m.m["authSessions"].RLock()
-	defer m.m["authSessions"].RUnlock()
-	if c, ok := m.authSessions[id]; ok {
-		if c.Remember {
-			return &c, nil
-		}
-		return nil, errors.WithStack(x.ErrNotFound)
-	}
-	return nil, errors.WithStack(x.ErrNotFound)
-}
-
-func (m *MemoryManager) CreateLoginSession(ctx context.Context, a *LoginSession) error {
-	m.m["authSessions"].Lock()
-	defer m.m["authSessions"].Unlock()
-	if _, ok := m.authSessions[a.ID]; ok {
-		return errors.New("Key already exists")
-	}
-	m.authSessions[a.ID] = *a
-	return nil
-}
-
-func (m *MemoryManager) DeleteLoginSession(ctx context.Context, id string) error {
-	m.m["authSessions"].Lock()
-	defer m.m["authSessions"].Unlock()
-	delete(m.authSessions, id)
-	return nil
-}
-
-func (m *MemoryManager) CreateLoginRequest(ctx context.Context, a *LoginRequest) error {
-	m.m["authRequests"].Lock()
-	defer m.m["authRequests"].Unlock()
-	if _, ok := m.authRequests[a.Challenge]; ok {
-		return errors.New("Key already exists")
-	}
-	m.authRequests[a.Challenge] = *a
-	return nil
-}
-
-func (m *MemoryManager) GetLoginRequest(ctx context.Context, challenge string) (*LoginRequest, error) {
-	m.m["authRequests"].RLock()
-	defer m.m["authRequests"].RUnlock()
-
-	c, ok := m.authRequests[challenge]
-	if !ok {
-		return nil, errors.WithStack(x.ErrNotFound)
-	}
-
-	m.m["handledAuthRequests"].Lock()
-	for _, h := range m.handledAuthRequests {
-		if h.Challenge == c.Challenge {
-			c.WasHandled = h.WasUsed
-		}
-	}
-	m.m["handledAuthRequests"].Unlock()
-
-	c.Client.ID = c.Client.GetID()
-	return &c, nil
-}
-
-func (m *MemoryManager) HandleLoginRequest(ctx context.Context, challenge string, r *HandledLoginRequest) (*LoginRequest, error) {
-	m.m["handledAuthRequests"].Lock()
-	m.handledAuthRequests[r.Challenge] = *r
-	m.m["handledAuthRequests"].Unlock()
-	return m.GetLoginRequest(ctx, challenge)
-}
-
-func (m *MemoryManager) VerifyAndInvalidateLoginRequest(ctx context.Context, verifier string) (*HandledLoginRequest, error) {
-	m.m["authRequests"].RLock()
-	for k := range m.authRequests {
-		c := m.authRequests[k]
-		if c.Verifier == verifier {
-			m.m["handledAuthRequests"].RLock()
-			for kk := range m.handledAuthRequests {
-				h := m.handledAuthRequests[kk]
-				if h.Challenge == c.Challenge {
-					m.m["handledAuthRequests"].RUnlock()
-					m.m["authRequests"].RUnlock()
-
-					if h.WasUsed {
-						return nil, errors.WithStack(fosite.ErrInvalidRequest.WithDebug("Authentication verifier has been used already"))
-					}
-
-					h.WasUsed = true
-					if _, err := m.HandleLoginRequest(ctx, h.Challenge, &h); err != nil {
-						return nil, err
-					}
-
-					c.Client.ID = c.Client.GetID()
-					h.LoginRequest = &c
-					return &h, nil
-				}
-			}
-			m.m["handledAuthRequests"].RUnlock()
-		}
-	}
-
-	m.m["authRequests"].RUnlock()
-	return nil, errors.WithStack(x.ErrNotFound)
-}
-
-func (m *MemoryManager) ListUserAuthenticatedClientsWithFrontChannelLogout(ctx context.Context, subject, sid string) ([]client.Client, error) {
-	m.m["consentRequests"].RLock()
-	defer m.m["consentRequests"].RUnlock()
-
-	preventDupes := make(map[string]bool)
-	var rs []client.Client
-	for _, cr := range m.consentRequests {
-		if cr.Subject == subject &&
-			len(cr.Client.FrontChannelLogoutURI) > 0 &&
-			cr.LoginSessionID.String() == sid &&
-			!preventDupes[cr.Client.GetID()] {
-
-			rs = append(rs, *cr.Client)
-			preventDupes[cr.Client.GetID()] = true
-		}
-	}
-
-	return rs, nil
-}
-
-func (m *MemoryManager) ListUserAuthenticatedClientsWithBackChannelLogout(ctx context.Context, subject, sid string) ([]client.Client, error) {
-	m.m["consentRequests"].RLock()
-	defer m.m["consentRequests"].RUnlock()
-
-	clientsMap := make(map[string]bool)
-	var rs []client.Client
-	for _, cr := range m.consentRequests {
-		if cr.Subject == subject &&
-			cr.LoginSessionID.String() == sid &&
-			len(cr.Client.BackChannelLogoutURI) > 0 &&
-			!(clientsMap[cr.Client.GetID()]) {
-			rs = append(rs, *cr.Client)
-			clientsMap[cr.Client.GetID()] = true
-		}
-	}
-
-	return rs, nil
-}
-
-func (m *MemoryManager) CreateLogoutRequest(ctx context.Context, r *LogoutRequest) error {
-	m.m["logoutRequests"].Lock()
-	m.logoutRequests[r.Challenge] = *r
-	m.m["logoutRequests"].Unlock()
-	return nil
-}
-
-func (m *MemoryManager) GetLogoutRequest(ctx context.Context, challenge string) (*LogoutRequest, error) {
-	m.m["logoutRequests"].RLock()
-	defer m.m["logoutRequests"].RUnlock()
-	if c, ok := m.logoutRequests[challenge]; ok {
-		return &c, nil
-	}
-	return nil, errors.WithStack(x.ErrNotFound)
-}
-
-func (m *MemoryManager) AcceptLogoutRequest(ctx context.Context, challenge string) (*LogoutRequest, error) {
-	m.m["logoutRequests"].Lock()
-	lr, ok := m.logoutRequests[challenge]
-	if !ok {
-		m.m["logoutRequests"].Unlock()
-		return nil, errors.WithStack(x.ErrNotFound)
-	}
-
-	lr.Accepted = true
-	m.logoutRequests[challenge] = lr
-
-	m.m["logoutRequests"].Unlock()
-	return m.GetLogoutRequest(ctx, challenge)
-}
-
-func (m *MemoryManager) RejectLogoutRequest(ctx context.Context, challenge string) error {
-	m.m["logoutRequests"].Lock()
-	defer m.m["logoutRequests"].Unlock()
-
-	if _, ok := m.logoutRequests[challenge]; !ok {
-		return errors.WithStack(x.ErrNotFound)
-	}
-
-	delete(m.logoutRequests, challenge)
-	return nil
-}
-
-func (m *MemoryManager) VerifyAndInvalidateLogoutRequest(ctx context.Context, verifier string) (*LogoutRequest, error) {
-	m.m["logoutRequests"].RLock()
-	for k := range m.logoutRequests {
-		c := m.logoutRequests[k]
-		if c.Verifier == verifier {
-			m.m["logoutRequests"].RUnlock()
-
-			if c.WasUsed {
-				return nil, errors.WithStack(fosite.ErrInvalidRequest.WithDebug("Logout verifier has been used already"))
-			}
-
-			if !c.Accepted {
-				return nil, errors.WithStack(fosite.ErrInvalidRequest.WithDebug("Logout verifier has not been accepted yet"))
-			}
-
-			c.WasUsed = true
-			if err := m.CreateLogoutRequest(ctx, &c); err != nil {
-				return nil, err
-			}
-
-			return &c, nil
-		}
-	}
-
-	m.m["logoutRequests"].RUnlock()
-	return nil, errors.WithStack(x.ErrNotFound)
-}
diff --git a/consent/manager_sql.go b/consent/manager_sql.go
deleted file mode 100644
index 0bb8d6ceb..000000000
--- a/consent/manager_sql.go
+++ /dev/null
@@ -1,592 +0,0 @@
-/*
- * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @Copyright 	2017-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @license 	Apache-2.0
- */
-
-package consent
-
-import (
-	"context"
-	"database/sql"
-	"fmt"
-	"strings"
-	"time"
-
-	"github.com/ory/hydra/client"
-
-	"github.com/jmoiron/sqlx"
-	"github.com/pkg/errors"
-
-	"github.com/ory/fosite"
-	"github.com/ory/x/sqlcon"
-
-	"github.com/ory/hydra/x"
-)
-
-type SQLManager struct {
-	DB *sqlx.DB
-	r  InternalRegistry
-}
-
-func NewSQLManager(db *sqlx.DB, r InternalRegistry) *SQLManager {
-	return &SQLManager{
-		DB: db,
-		r:  r,
-	}
-}
-
-func (m *SQLManager) RevokeSubjectConsentSession(ctx context.Context, user string) error {
-	return m.revokeConsentSession(ctx, user, "")
-}
-
-func (m *SQLManager) RevokeSubjectClientConsentSession(ctx context.Context, user, client string) error {
-	return m.revokeConsentSession(ctx, user, client)
-}
-
-func (m *SQLManager) revokeConsentSession(ctx context.Context, user, client string) error {
-	args := []interface{}{user}
-
-	// part can be one of constants:
-	//
-	// - r.subject=?
-	// - r.subject=? AND r.client_id=?
-	part := "r.subject=?"
-	if client != "" {
-		part += " AND r.client_id=?"
-		args = append(args, client)
-	}
-
-	var challenges = make([]string, 0)
-	/* #nosec G201 - see "part" */
-	if err := m.DB.SelectContext(ctx, &challenges, m.DB.Rebind(fmt.Sprintf(
-		`SELECT r.challenge FROM hydra_oauth2_consent_request_handled as h
-JOIN hydra_oauth2_consent_request as r ON r.challenge = h.challenge WHERE %s`,
-		part,
-	)), args...); err != nil {
-		if err == sql.ErrNoRows {
-			return errors.WithStack(x.ErrNotFound)
-		}
-		return sqlcon.HandleError(err)
-	}
-
-	for _, challenge := range challenges {
-		if err := m.r.OAuth2Storage().RevokeAccessToken(ctx, challenge); errors.Is(err, fosite.ErrNotFound) {
-			// do nothing
-		} else if err != nil {
-			return err
-		}
-		if err := m.r.OAuth2Storage().RevokeRefreshToken(ctx, challenge); errors.Is(err, fosite.ErrNotFound) {
-			// do nothing
-		} else if err != nil {
-			return err
-		}
-	}
-
-	var queries []string
-	switch m.DB.DriverName() {
-	case "mysql":
-		/* #nosec G201 - see "part" */
-		queries = append(queries,
-			fmt.Sprintf(`DELETE h, r FROM hydra_oauth2_consent_request_handled as h
-JOIN hydra_oauth2_consent_request as r ON r.challenge = h.challenge
-WHERE %s`, part),
-		)
-	default:
-		queries = append(queries,
-			/* #nosec G201 - see "part" */
-			fmt.Sprintf(`DELETE FROM hydra_oauth2_consent_request_handled
-WHERE challenge IN (SELECT r.challenge FROM hydra_oauth2_consent_request as r WHERE %s)`, part),
-			/* #nosec G201 - see "part" */
-			fmt.Sprintf(`DELETE FROM hydra_oauth2_consent_request as r WHERE %s`, part),
-		)
-	}
-
-	for _, q := range queries {
-		rows, err := m.DB.ExecContext(ctx, m.DB.Rebind(q), args...)
-		if err != nil {
-			if err == sql.ErrNoRows {
-				return errors.WithStack(x.ErrNotFound)
-			}
-			return sqlcon.HandleError(err)
-		}
-
-		if count, _ := rows.RowsAffected(); count == 0 {
-			return errors.WithStack(x.ErrNotFound)
-		}
-	}
-	return nil
-}
-
-func (m *SQLManager) RevokeSubjectLoginSession(ctx context.Context, user string) error {
-	_, err := m.DB.ExecContext(
-		ctx,
-		m.DB.Rebind("DELETE FROM hydra_oauth2_authentication_session WHERE subject=?"),
-		user,
-	)
-	if err != nil {
-		if err == sql.ErrNoRows {
-			return errors.WithStack(x.ErrNotFound)
-		}
-		return sqlcon.HandleError(err)
-	}
-
-	// This confuses people, see https://github.com/ory/hydra/issues/1168
-	//
-	// count, _ := rows.RowsAffected()
-	// if count == 0 {
-	// 	 return errors.WithStack(x.ErrNotFound)
-	// }
-
-	return nil
-}
-
-func (m *SQLManager) CreateForcedObfuscatedLoginSession(ctx context.Context, s *ForcedObfuscatedLoginSession) error {
-	tx, err := m.DB.BeginTxx(ctx, nil)
-	if err != nil {
-		return sqlcon.HandleError(err)
-	}
-
-	if _, err := tx.ExecContext(
-		ctx,
-		m.DB.Rebind("DELETE FROM hydra_oauth2_obfuscated_authentication_session WHERE client_id=? AND subject=?"),
-		s.ClientID,
-		s.Subject,
-	); err != nil {
-		if err := tx.Rollback(); err != nil {
-			return sqlcon.HandleError(err)
-		}
-		return sqlcon.HandleError(err)
-	}
-
-	if _, err := tx.NamedExec(
-		"INSERT INTO hydra_oauth2_obfuscated_authentication_session (subject, client_id, subject_obfuscated) VALUES (:subject, :client_id, :subject_obfuscated)",
-		s,
-	); err != nil {
-		if err := tx.Rollback(); err != nil {
-			return sqlcon.HandleError(err)
-		}
-		return sqlcon.HandleError(err)
-	}
-
-	if err := tx.Commit(); err != nil {
-		return sqlcon.HandleError(err)
-	}
-	return nil
-}
-
-func (m *SQLManager) GetForcedObfuscatedLoginSession(ctx context.Context, client, obfuscated string) (*ForcedObfuscatedLoginSession, error) {
-	var d ForcedObfuscatedLoginSession
-
-	if err := m.DB.GetContext(ctx, &d, m.DB.Rebind("SELECT * FROM hydra_oauth2_obfuscated_authentication_session WHERE client_id=? AND subject_obfuscated=?"), client, obfuscated); err != nil {
-		if err == sql.ErrNoRows {
-			return nil, errors.WithStack(x.ErrNotFound)
-		}
-		return nil, sqlcon.HandleError(err)
-	}
-
-	return &d, nil
-}
-
-func (m *SQLManager) CreateConsentRequest(ctx context.Context, c *ConsentRequest) error {
-	/* #nosec G201 - sqlParamsConsentRequest is "constant" array */
-	if _, err := m.DB.NamedExecContext(ctx, fmt.Sprintf(
-		"INSERT INTO hydra_oauth2_consent_request (%s) VALUES (%s)",
-		strings.Join(sqlParamsConsentRequest, ", "),
-		":"+strings.Join(sqlParamsConsentRequest, ", :"),
-	), c.prepareSQL()); err != nil {
-		return sqlcon.HandleError(err)
-	}
-
-	return nil
-}
-
-func (m *SQLManager) GetConsentRequest(ctx context.Context, challenge string) (*ConsentRequest, error) {
-	var d ConsentRequest
-	err := m.DB.GetContext(ctx, &d, m.DB.Rebind("SELECT r.*, COALESCE(hr.was_used, false) as was_handled FROM hydra_oauth2_consent_request r "+
-		"LEFT JOIN hydra_oauth2_consent_request_handled hr ON r.challenge = hr.challenge WHERE r.challenge=?"), challenge)
-	if err != nil {
-		if err == sql.ErrNoRows {
-			return nil, errors.WithStack(x.ErrNotFound)
-		}
-		return nil, sqlcon.HandleError(err)
-	}
-
-	c, err := m.r.ClientManager().GetConcreteClient(ctx, d.ClientID)
-	if err != nil {
-		return nil, err
-	}
-
-	d.Client = c
-	return &d, nil
-}
-
-func (m *SQLManager) CreateLoginRequest(ctx context.Context, c *LoginRequest) error {
-	/* #nosec G201 - sqlParamsAuthenticationRequest is "constant" array */
-	if _, err := m.DB.NamedExecContext(ctx, fmt.Sprintf(
-		"INSERT INTO hydra_oauth2_authentication_request (%s) VALUES (%s)",
-		strings.Join(sqlParamsAuthenticationRequest, ", "),
-		":"+strings.Join(sqlParamsAuthenticationRequest, ", :"),
-	), c.prepareSQL()); err != nil {
-		return sqlcon.HandleError(err)
-	}
-
-	return nil
-}
-
-func (m *SQLManager) GetLoginRequest(ctx context.Context, challenge string) (*LoginRequest, error) {
-	var d LoginRequest
-	err := m.DB.GetContext(ctx, &d, m.DB.Rebind("SELECT r.*, COALESCE(hr.was_used, false) as was_handled FROM hydra_oauth2_authentication_request r "+
-		"LEFT JOIN hydra_oauth2_authentication_request_handled hr ON r.challenge = hr.challenge WHERE r.challenge=?"), challenge)
-	if err != nil {
-		if err == sql.ErrNoRows {
-			return nil, errors.WithStack(x.ErrNotFound)
-		}
-		return nil, sqlcon.HandleError(err)
-	}
-
-	c, err := m.r.ClientManager().GetConcreteClient(ctx, d.ClientID)
-	if err != nil {
-		return nil, err
-	}
-
-	d.Client = c
-	return &d, nil
-}
-
-func (m *SQLManager) HandleConsentRequest(ctx context.Context, challenge string, r *HandledConsentRequest) (*ConsentRequest, error) {
-	r.prepareSQL()
-
-	/* #nosec G201 - sqlParamsConsentRequestHandled is a "constant" array */
-	if _, err := m.DB.NamedExecContext(ctx, fmt.Sprintf(
-		"INSERT INTO hydra_oauth2_consent_request_handled (%s) VALUES (%s)",
-		strings.Join(sqlParamsConsentRequestHandled, ", "),
-		":"+strings.Join(sqlParamsConsentRequestHandled, ", :"),
-	), r); err != nil {
-		err = sqlcon.HandleError(err)
-		if errors.Is(err, sqlcon.ErrUniqueViolation) {
-			return m.replaceUnusedConsentRequest(ctx, challenge, r)
-		}
-		return nil, err
-	}
-
-	return m.GetConsentRequest(ctx, challenge)
-}
-
-func (m *SQLManager) replaceUnusedConsentRequest(ctx context.Context, challenge string, d *HandledConsentRequest) (*ConsentRequest, error) {
-	/* #nosec G201 - sqlParamsConsentRequestHandledUpdate is a "constant" array */
-	if _, err := m.DB.NamedExecContext(ctx, fmt.Sprintf(
-		"UPDATE hydra_oauth2_consent_request_handled SET %s WHERE challenge=:challenge AND was_used=false",
-		strings.Join(sqlParamsConsentRequestHandledUpdate, ", "),
-	), d); err != nil {
-		return nil, sqlcon.HandleError(err)
-	}
-
-	return m.GetConsentRequest(ctx, challenge)
-}
-
-func (m *SQLManager) VerifyAndInvalidateConsentRequest(ctx context.Context, verifier string) (*HandledConsentRequest, error) {
-	var d HandledConsentRequest
-	var challenge string
-
-	// This can be solved more elegantly with a join statement, but it works for now
-
-	if err := m.DB.GetContext(ctx, &challenge, m.DB.Rebind("SELECT challenge FROM hydra_oauth2_consent_request WHERE verifier=?"), verifier); err != nil {
-		return nil, sqlcon.HandleError(err)
-	}
-
-	if err := m.DB.GetContext(ctx, &d, m.DB.Rebind("SELECT * FROM hydra_oauth2_consent_request_handled WHERE challenge=?"), challenge); err != nil {
-		return nil, sqlcon.HandleError(err)
-	}
-
-	if d.WasUsed {
-		return nil, errors.WithStack(fosite.ErrInvalidRequest.WithDebug("Consent verifier has been used already"))
-	}
-
-	r, err := m.GetConsentRequest(ctx, challenge)
-	if err != nil {
-		return nil, err
-	}
-
-	if _, err := m.DB.ExecContext(ctx, m.DB.Rebind("UPDATE hydra_oauth2_consent_request_handled SET was_used=true WHERE challenge=?"), challenge); err != nil {
-		return nil, sqlcon.HandleError(err)
-	}
-
-	return d.postSQL(r), nil
-}
-
-func (m *SQLManager) HandleLoginRequest(ctx context.Context, challenge string, r *HandledLoginRequest) (*LoginRequest, error) {
-	/* #nosec G201 - sqlParamsAuthenticationRequestHandled is a "constant" array */
-	if _, err := m.DB.NamedExecContext(ctx, fmt.Sprintf(
-		"INSERT INTO hydra_oauth2_authentication_request_handled (%s) VALUES (%s)",
-		strings.Join(sqlParamsAuthenticationRequestHandled, ", "),
-		":"+strings.Join(sqlParamsAuthenticationRequestHandled, ", :"),
-	), r.prepareSQL()); err != nil {
-		return nil, sqlcon.HandleError(err)
-	}
-
-	return m.GetLoginRequest(ctx, challenge)
-}
-
-func (m *SQLManager) VerifyAndInvalidateLoginRequest(ctx context.Context, verifier string) (*HandledLoginRequest, error) {
-	var d HandledLoginRequest
-	var challenge string
-
-	// This can be solved more elegantly with a join statement, but it works for now
-
-	if err := m.DB.GetContext(ctx, &challenge, m.DB.Rebind("SELECT challenge FROM hydra_oauth2_authentication_request WHERE verifier=?"), verifier); err != nil {
-		return nil, sqlcon.HandleError(err)
-	}
-
-	if err := m.DB.GetContext(ctx, &d, m.DB.Rebind("SELECT * FROM hydra_oauth2_authentication_request_handled WHERE challenge=?"), challenge); err != nil {
-		return nil, sqlcon.HandleError(err)
-	}
-
-	if d.WasUsed {
-		return nil, errors.WithStack(fosite.ErrInvalidRequest.WithDebug("Authentication verifier has been used already"))
-	}
-
-	if _, err := m.DB.ExecContext(ctx, m.DB.Rebind("UPDATE hydra_oauth2_authentication_request_handled SET was_used=true WHERE challenge=?"), challenge); err != nil {
-		return nil, sqlcon.HandleError(err)
-	}
-
-	r, err := m.GetLoginRequest(ctx, challenge)
-	if err != nil {
-		return nil, err
-	}
-
-	return d.postSQL(r), nil
-}
-
-func (m *SQLManager) GetRememberedLoginSession(ctx context.Context, id string) (*LoginSession, error) {
-	var a LoginSession
-	if err := m.DB.GetContext(ctx, &a, m.DB.Rebind("SELECT * FROM hydra_oauth2_authentication_session WHERE id=? AND remember=TRUE"), id); err != nil {
-		if err == sql.ErrNoRows {
-			return nil, errors.WithStack(x.ErrNotFound)
-		}
-		return nil, sqlcon.HandleError(err)
-	}
-
-	return &a, nil
-}
-
-func (m *SQLManager) ConfirmLoginSession(ctx context.Context, id string, subject string, remember bool) error {
-	if _, err := m.DB.ExecContext(ctx, m.DB.Rebind("UPDATE hydra_oauth2_authentication_session SET remember=?, subject=?, authenticated_at=? WHERE id=?"), remember, subject, time.Now().UTC(), id); err != nil {
-		return sqlcon.HandleError(err)
-	}
-	return nil
-}
-
-func (m *SQLManager) CreateLoginSession(ctx context.Context, a *LoginSession) error {
-	/* #nosec G201 - sqlParamsAuthSession is a "constant" array */
-	if _, err := m.DB.NamedExecContext(ctx, fmt.Sprintf(
-		"INSERT INTO hydra_oauth2_authentication_session (%s) VALUES (%s)",
-		strings.Join(sqlParamsAuthSession, ", "),
-		":"+strings.Join(sqlParamsAuthSession, ", :"),
-	), a); err != nil {
-		return sqlcon.HandleError(err)
-	}
-
-	return nil
-}
-
-func (m *SQLManager) DeleteLoginSession(ctx context.Context, id string) error {
-	if _, err := m.DB.ExecContext(ctx, m.DB.Rebind("DELETE FROM hydra_oauth2_authentication_session WHERE id=?"), id); err != nil {
-		return sqlcon.HandleError(err)
-	}
-
-	return nil
-}
-
-func (m *SQLManager) FindGrantedAndRememberedConsentRequests(ctx context.Context, client, subject string) ([]HandledConsentRequest, error) {
-	var a []HandledConsentRequest
-
-	if err := m.DB.SelectContext(ctx, &a, m.DB.Rebind(`SELECT h.* FROM
-	hydra_oauth2_consent_request_handled as h
-JOIN
-	hydra_oauth2_consent_request as r ON (h.challenge = r.challenge)
-WHERE
-		r.subject=? AND r.client_id=? AND r.skip=FALSE
-	AND
-		(h.error='{}' AND h.remember=TRUE)
-ORDER BY h.requested_at DESC
-LIMIT 1`), subject, client); err != nil {
-		if err == sql.ErrNoRows {
-			return nil, errors.WithStack(ErrNoPreviousConsentFound)
-		}
-		return nil, sqlcon.HandleError(err)
-	}
-
-	return m.resolveHandledConsentRequests(ctx, a)
-}
-
-func (m *SQLManager) FindSubjectsGrantedConsentRequests(ctx context.Context, subject string, limit, offset int) ([]HandledConsentRequest, error) {
-	var a []HandledConsentRequest
-
-	if err := m.DB.SelectContext(ctx, &a, m.DB.Rebind(`SELECT h.* FROM
-	hydra_oauth2_consent_request_handled as h
-JOIN
-	hydra_oauth2_consent_request as r ON (h.challenge = r.challenge)
-WHERE
-		r.subject=? AND r.skip=FALSE
-	AND
-		(h.error='{}')
-ORDER BY h.requested_at DESC
-LIMIT ? OFFSET ?
-`), subject, limit, offset); err != nil {
-		return nil, sqlcon.HandleError(err)
-	}
-
-	return m.resolveHandledConsentRequests(ctx, a)
-}
-
-func (m *SQLManager) CountSubjectsGrantedConsentRequests(ctx context.Context, subject string) (int, error) {
-	var n int
-
-	if err := m.DB.QueryRowContext(ctx, m.DB.Rebind(`SELECT COUNT(*) FROM
-	hydra_oauth2_consent_request_handled as h
-JOIN
-	hydra_oauth2_consent_request as r ON (h.challenge = r.challenge)
-WHERE
-		r.subject=? AND r.skip=FALSE
-	AND
-		(h.error='{}')
-`), subject).Scan(&n); err != nil {
-		return 0, sqlcon.HandleError(err)
-	}
-
-	return n, nil
-}
-
-func (m *SQLManager) resolveHandledConsentRequests(ctx context.Context, requests []HandledConsentRequest) ([]HandledConsentRequest, error) {
-	var result []HandledConsentRequest
-	for _, v := range requests {
-		r, err := m.GetConsentRequest(ctx, v.Challenge)
-		if err != nil {
-			return nil, err
-		} else if errors.Is(err, x.ErrNotFound) {
-			return nil, errors.WithStack(ErrNoPreviousConsentFound)
-		}
-
-		if v.RememberFor > 0 && v.RequestedAt.Add(time.Duration(v.RememberFor)*time.Second).Before(time.Now().UTC()) {
-			continue
-		}
-
-		v.postSQL(r)
-		result = append(result, v)
-	}
-
-	if len(result) == 0 {
-		return nil, errors.WithStack(ErrNoPreviousConsentFound)
-	}
-
-	return result, nil
-}
-
-func (m *SQLManager) ListUserAuthenticatedClientsWithFrontChannelLogout(ctx context.Context, subject, sid string) ([]client.Client, error) {
-	return m.listUserAuthenticatedClients(ctx, subject, sid, "front")
-}
-
-func (m *SQLManager) ListUserAuthenticatedClientsWithBackChannelLogout(ctx context.Context, subject, sid string) ([]client.Client, error) {
-	return m.listUserAuthenticatedClients(ctx, subject, sid, "back")
-}
-
-func (m *SQLManager) listUserAuthenticatedClients(ctx context.Context, subject, sid, channel string) ([]client.Client, error) {
-	var ids []string
-	/* #nosec G201 - channel can either be "front" or "back" */
-	if err := m.DB.SelectContext(ctx, &ids, m.DB.Rebind(fmt.Sprintf(`SELECT DISTINCT(c.id) FROM hydra_client as c JOIN hydra_oauth2_consent_request as r ON (c.id = r.client_id) WHERE r.subject=? AND c.%schannel_logout_uri!='' AND c.%schannel_logout_uri IS NOT NULL AND r.login_session_id = ?`, channel, channel)), subject, sid); err != nil {
-		if err == sql.ErrNoRows {
-			return nil, errors.WithStack(x.ErrNotFound)
-		}
-		return nil, sqlcon.HandleError(err)
-	}
-
-	cs := make([]client.Client, len(ids))
-	for k, id := range ids {
-		c, err := m.r.ClientManager().GetConcreteClient(ctx, id)
-		if err != nil {
-			return nil, err
-		}
-		cs[k] = *c
-	}
-
-	return cs, nil
-}
-
-func (m *SQLManager) CreateLogoutRequest(ctx context.Context, r *LogoutRequest) error {
-	/* #nosec G201 - sqlParamsLogoutRequest is a "constant" array */
-	if _, err := m.DB.NamedExecContext(ctx, fmt.Sprintf(
-		"INSERT INTO hydra_oauth2_logout_request (%s) VALUES (%s)",
-		strings.Join(sqlParamsLogoutRequest, ", "),
-		":"+strings.Join(sqlParamsLogoutRequest, ", :"),
-	), r.prepareSQL()); err != nil {
-		return sqlcon.HandleError(err)
-	}
-
-	return nil
-}
-
-func (m *SQLManager) AcceptLogoutRequest(ctx context.Context, challenge string) (*LogoutRequest, error) {
-	if _, err := m.DB.ExecContext(ctx, m.DB.Rebind("UPDATE hydra_oauth2_logout_request SET accepted=true, rejected=false WHERE challenge=?"), challenge); err != nil {
-		return nil, sqlcon.HandleError(err)
-	}
-
-	return m.GetLogoutRequest(ctx, challenge)
-}
-
-func (m *SQLManager) RejectLogoutRequest(ctx context.Context, challenge string) error {
-	if _, err := m.DB.ExecContext(ctx, m.DB.Rebind("UPDATE hydra_oauth2_logout_request SET rejected=true, accepted=false WHERE challenge=?"), challenge); err != nil {
-		return sqlcon.HandleError(err)
-	}
-	return nil
-}
-
-func (m *SQLManager) GetLogoutRequest(ctx context.Context, challenge string) (*LogoutRequest, error) {
-	var lr LogoutRequest
-	if err := m.DB.GetContext(ctx, &lr, m.DB.Rebind("SELECT * FROM hydra_oauth2_logout_request WHERE challenge=? AND rejected=FALSE"), challenge); err != nil {
-		if err == sql.ErrNoRows {
-			return nil, errors.WithStack(x.ErrNotFound)
-		}
-		return nil, sqlcon.HandleError(err)
-	}
-
-	if lr.ClientID.Valid {
-		var err error
-		lr.Client, err = m.r.ClientManager().GetConcreteClient(ctx, lr.ClientID.String)
-		if err != nil {
-			return nil, err
-		}
-	}
-
-	return &lr, nil
-}
-
-func (m *SQLManager) VerifyAndInvalidateLogoutRequest(ctx context.Context, verifier string) (*LogoutRequest, error) {
-	var lr LogoutRequest
-	if err := m.DB.GetContext(ctx, &lr, m.DB.Rebind("SELECT * FROM hydra_oauth2_logout_request WHERE verifier=? AND was_used=FALSE AND accepted=TRUE AND rejected=FALSE"), verifier); err != nil {
-		if err == sql.ErrNoRows {
-			return nil, errors.WithStack(x.ErrNotFound)
-		}
-		return nil, sqlcon.HandleError(err)
-	}
-
-	if _, err := m.DB.ExecContext(ctx, m.DB.Rebind("UPDATE hydra_oauth2_logout_request SET was_used=TRUE WHERE verifier=?"), verifier); err != nil {
-		return nil, sqlcon.HandleError(err)
-	}
-
-	return m.GetLogoutRequest(ctx, lr.Challenge)
-}
diff --git a/consent/manager_test.go b/consent/manager_test.go
index 44540a20e..a8dbe7350 100644
--- a/consent/manager_test.go
+++ b/consent/manager_test.go
@@ -39,7 +39,7 @@ func TestManagers(t *testing.T) {
 	conf := internal.NewConfigurationWithDefaults()
 	viper.Set(configuration.ViperKeyAccessTokenLifespan, time.Hour)
 	registries := map[string]driver.Registry{
-		"memory": internal.NewRegistryMemory(conf),
+		"memory": internal.NewRegistryMemory(t, conf),
 	}
 
 	if !testing.Short() {
diff --git a/consent/manager_test_helpers.go b/consent/manager_test_helpers.go
index e212db7db..5ba5604a5 100644
--- a/consent/manager_test_helpers.go
+++ b/consent/manager_test_helpers.go
@@ -22,10 +22,13 @@ package consent
 
 import (
 	"context"
+	"errors"
 	"fmt"
 	"testing"
 	"time"
 
+	"github.com/ory/x/sqlcon"
+
 	"github.com/google/uuid"
 	"github.com/stretchr/testify/assert"
 	"github.com/stretchr/testify/require"
@@ -40,7 +43,7 @@ import (
 
 func MockConsentRequest(key string, remember bool, rememberFor int, hasError bool, skip bool, authAt bool) (c *ConsentRequest, h *HandledConsentRequest) {
 	c = &ConsentRequest{
-		Challenge:         "challenge" + key,
+		ID:                "challenge" + key,
 		RequestedScope:    []string{"scopea" + key, "scopeb" + key},
 		RequestedAudience: []string{"auda" + key, "audb" + key},
 		Skip:              skip,
@@ -85,7 +88,7 @@ func MockConsentRequest(key string, remember bool, rememberFor int, hasError boo
 		ConsentRequest:  c,
 		RememberFor:     rememberFor,
 		Remember:        remember,
-		Challenge:       "challenge" + key,
+		ID:              "challenge" + key,
 		RequestedAt:     time.Now().UTC().Add(-time.Minute),
 		AuthenticatedAt: authenticatedAt,
 		GrantedScope:    []string{"scopea" + key, "scopeb" + key},
@@ -107,7 +110,7 @@ func MockLogoutRequest(key string, withClient bool) (c *LogoutRequest) {
 	}
 	return &LogoutRequest{
 		Subject:               "subject" + key,
-		Challenge:             "challenge" + key,
+		ID:                    "challenge" + key,
 		Verifier:              "verifier" + key,
 		SessionID:             "session" + key,
 		RPInitiated:           true,
@@ -131,7 +134,7 @@ func MockAuthRequest(key string, authAt bool) (c *LoginRequest, h *HandledLoginR
 		Subject:        "subject" + key,
 		RequestURL:     "https://request-url/path" + key,
 		Skip:           true,
-		Challenge:      "challenge" + key,
+		ID:             "challenge" + key,
 		Verifier:       "verifier" + key,
 		RequestedScope: []string{"scopea" + key, "scopeb" + key},
 		CSRF:           "csrf" + key,
@@ -156,7 +159,7 @@ func MockAuthRequest(key string, authAt bool) (c *LoginRequest, h *HandledLoginR
 		LoginRequest:           c,
 		RememberFor:            120,
 		Remember:               true,
-		Challenge:              "challenge" + key,
+		ID:                     "challenge" + key,
 		RequestedAt:            time.Now().UTC().Add(-time.Minute),
 		AuthenticatedAt:        sqlxx.NullTime(authenticatedAt),
 		Error:                  err,
@@ -186,7 +189,7 @@ func SaneMockHandleConsentRequest(t *testing.T, m Manager, c *ConsentRequest, au
 		ConsentRequest:  c,
 		RememberFor:     rememberFor,
 		Remember:        remember,
-		Challenge:       c.Challenge,
+		ID:              c.ID,
 		RequestedAt:     time.Now().UTC().Add(-time.Minute),
 		AuthenticatedAt: sqlxx.NullTime(authAt),
 		GrantedScope:    []string{"scopea", "scopeb"},
@@ -196,7 +199,7 @@ func SaneMockHandleConsentRequest(t *testing.T, m Manager, c *ConsentRequest, au
 		HandledAt:       sqlxx.NullTime(time.Now().UTC().Add(-time.Minute)),
 	}
 
-	_, err := m.HandleConsentRequest(context.Background(), c.Challenge, h)
+	_, err := m.HandleConsentRequest(context.Background(), c.ID, h)
 	require.NoError(t, err)
 	return h
 }
@@ -215,7 +218,7 @@ func SaneMockConsentRequest(t *testing.T, m Manager, ar *LoginRequest, skip bool
 		},
 		Client:                 ar.Client,
 		RequestURL:             "https://request-url/path",
-		LoginChallenge:         sqlxx.NullString(ar.Challenge),
+		LoginChallenge:         sqlxx.NullString(ar.ID),
 		LoginSessionID:         ar.SessionID,
 		ForceSubjectIdentifier: "forced-subject",
 		SubjectIdentifier:      "forced-subject",
@@ -224,9 +227,9 @@ func SaneMockConsentRequest(t *testing.T, m Manager, ar *LoginRequest, skip bool
 		RequestedAt:            time.Now().UTC().Add(-time.Hour),
 		Context:                sqlxx.JSONRawMessage(`{"foo": "bar"}`),
 
-		Challenge: uuid.New().String(),
-		Verifier:  uuid.New().String(),
-		CSRF:      uuid.New().String(),
+		ID:       uuid.New().String(),
+		Verifier: uuid.New().String(),
+		CSRF:     uuid.New().String(),
 	}
 
 	require.NoError(t, m.CreateConsentRequest(context.Background(), c))
@@ -249,9 +252,9 @@ func SaneMockAuthRequest(t *testing.T, m Manager, ls *LoginSession, cl *client.C
 		RequestedScope: []string{"scopea", "scopeb"},
 		SessionID:      sqlxx.NullString(ls.ID),
 
-		CSRF:      uuid.New().String(),
-		Challenge: uuid.New().String(),
-		Verifier:  uuid.New().String(),
+		CSRF:     uuid.New().String(),
+		ID:       uuid.New().String(),
+		Verifier: uuid.New().String(),
 	}
 	require.NoError(t, m.CreateLoginRequest(context.Background(), c))
 	return c
@@ -261,16 +264,16 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 	return func(t *testing.T) {
 		t.Run("case=init-fks", func(t *testing.T) {
 			for _, k := range []string{"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "rv1", "rv2"} {
-				require.NoError(t, clientManager.CreateClient(context.TODO(), &client.Client{ID: fmt.Sprintf("fk-client-%s", k)}))
+				require.NoError(t, clientManager.CreateClient(context.Background(), &client.Client{ID: fmt.Sprintf("fk-client-%s", k)}))
 
-				require.NoError(t, m.CreateLoginSession(context.TODO(), &LoginSession{
+				require.NoError(t, m.CreateLoginSession(context.Background(), &LoginSession{
 					ID:              fmt.Sprintf("fk-login-session-%s", k),
 					AuthenticatedAt: time.Now().Round(time.Second).UTC(),
 					Subject:         fmt.Sprintf("subject-%s", k),
 				}))
 
-				require.NoError(t, m.CreateLoginRequest(context.TODO(), &LoginRequest{
-					Challenge:       fmt.Sprintf("fk-login-challenge-%s", k),
+				require.NoError(t, m.CreateLoginRequest(context.Background(), &LoginRequest{
+					ID:              fmt.Sprintf("fk-login-challenge-%s", k),
 					Verifier:        fmt.Sprintf("fk-login-verifier-%s", k),
 					Client:          &client.Client{ID: fmt.Sprintf("fk-client-%s", k)},
 					AuthenticatedAt: sqlxx.NullTime(time.Now()),
@@ -299,27 +302,27 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 				},
 			} {
 				t.Run("case=create-get-"+tc.s.ID, func(t *testing.T) {
-					_, err := m.GetRememberedLoginSession(context.TODO(), tc.s.ID)
-					require.EqualError(t, err, x.ErrNotFound.Error())
+					_, err := m.GetRememberedLoginSession(context.Background(), tc.s.ID)
+					require.EqualError(t, err, x.ErrNotFound.Error(), "%#v", err)
 
-					err = m.CreateLoginSession(context.TODO(), &tc.s)
+					err = m.CreateLoginSession(context.Background(), &tc.s)
 					require.NoError(t, err)
 
-					_, err = m.GetRememberedLoginSession(context.TODO(), tc.s.ID)
+					_, err = m.GetRememberedLoginSession(context.Background(), tc.s.ID)
 					require.EqualError(t, err, x.ErrNotFound.Error())
 
-					require.NoError(t, m.ConfirmLoginSession(context.TODO(), tc.s.ID, tc.s.Subject, true))
+					require.NoError(t, m.ConfirmLoginSession(context.Background(), tc.s.ID, tc.s.Subject, true))
 
-					got, err := m.GetRememberedLoginSession(context.TODO(), tc.s.ID)
+					got, err := m.GetRememberedLoginSession(context.Background(), tc.s.ID)
 					require.NoError(t, err)
 					assert.EqualValues(t, tc.s.ID, got.ID)
 					assert.NotEqual(t, tc.s.AuthenticatedAt.Unix(), got.AuthenticatedAt.Unix()) // this was updated from confirm...
 					assert.EqualValues(t, tc.s.Subject, got.Subject)
 
 					time.Sleep(time.Second) // Make sure AuthAt does not equal...
-					require.NoError(t, m.ConfirmLoginSession(context.TODO(), tc.s.ID, "some-other-subject", true))
+					require.NoError(t, m.ConfirmLoginSession(context.Background(), tc.s.ID, "some-other-subject", true))
 
-					got2, err := m.GetRememberedLoginSession(context.TODO(), tc.s.ID)
+					got2, err := m.GetRememberedLoginSession(context.Background(), tc.s.ID)
 					require.NoError(t, err)
 					assert.EqualValues(t, tc.s.ID, got2.ID)
 					assert.NotEqual(t, tc.s.AuthenticatedAt.Unix(), got2.AuthenticatedAt.Unix()) // this was updated from confirm...
@@ -338,10 +341,10 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 				},
 			} {
 				t.Run("case=delete-get-"+tc.id, func(t *testing.T) {
-					err := m.DeleteLoginSession(context.TODO(), tc.id)
+					err := m.DeleteLoginSession(context.Background(), tc.id)
 					require.NoError(t, err)
 
-					_, err = m.GetRememberedLoginSession(context.TODO(), tc.id)
+					_, err = m.GetRememberedLoginSession(context.Background(), tc.id)
 					require.Error(t, err)
 				})
 			}
@@ -361,31 +364,31 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 			} {
 				t.Run("key="+tc.key, func(t *testing.T) {
 					c, h := MockAuthRequest(tc.key, tc.authAt)
-					_ = clientManager.CreateClient(context.TODO(), c.Client) // Ignore errors that are caused by duplication
+					_ = clientManager.CreateClient(context.Background(), c.Client) // Ignore errors that are caused by duplication
 
-					_, err := m.GetLoginRequest(context.TODO(), "challenge"+tc.key)
+					_, err := m.GetLoginRequest(context.Background(), "challenge"+tc.key)
 					require.Error(t, err)
 
-					require.NoError(t, m.CreateLoginRequest(context.TODO(), c))
+					require.NoError(t, m.CreateLoginRequest(context.Background(), c))
 
-					got1, err := m.GetLoginRequest(context.TODO(), "challenge"+tc.key)
+					got1, err := m.GetLoginRequest(context.Background(), "challenge"+tc.key)
 					require.NoError(t, err)
 					assert.False(t, got1.WasHandled)
 					compareAuthenticationRequest(t, c, got1)
 
-					got1, err = m.HandleLoginRequest(context.TODO(), "challenge"+tc.key, h)
+					got1, err = m.HandleLoginRequest(context.Background(), "challenge"+tc.key, h)
 					require.NoError(t, err)
 					compareAuthenticationRequest(t, c, got1)
 
-					got2, err := m.VerifyAndInvalidateLoginRequest(context.TODO(), "verifier"+tc.key)
+					got2, err := m.VerifyAndInvalidateLoginRequest(context.Background(), "verifier"+tc.key)
 					require.NoError(t, err)
 					compareAuthenticationRequest(t, c, got2.LoginRequest)
-					assert.Equal(t, c.Challenge, got2.Challenge)
+					assert.Equal(t, c.ID, got2.ID)
 
-					_, err = m.VerifyAndInvalidateLoginRequest(context.TODO(), "verifier"+tc.key)
+					_, err = m.VerifyAndInvalidateLoginRequest(context.Background(), "verifier"+tc.key)
 					require.Error(t, err)
 
-					got1, err = m.GetLoginRequest(context.TODO(), "challenge"+tc.key)
+					got1, err = m.GetLoginRequest(context.Background(), "challenge"+tc.key)
 					require.NoError(t, err)
 					assert.True(t, got1.WasHandled)
 				})
@@ -411,30 +414,30 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 			} {
 				t.Run("key="+tc.key, func(t *testing.T) {
 					c, h := MockConsentRequest(tc.key, tc.remember, tc.rememberFor, tc.hasError, tc.skip, tc.authAt)
-					_ = clientManager.CreateClient(context.TODO(), c.Client) // Ignore errors that are caused by duplication
+					_ = clientManager.CreateClient(context.Background(), c.Client) // Ignore errors that are caused by duplication
 
-					_, err := m.GetConsentRequest(context.TODO(), "challenge"+tc.key)
+					_, err := m.GetConsentRequest(context.Background(), "challenge"+tc.key)
 					require.Error(t, err)
 
-					require.NoError(t, m.CreateConsentRequest(context.TODO(), c))
+					require.NoError(t, m.CreateConsentRequest(context.Background(), c))
 
-					got1, err := m.GetConsentRequest(context.TODO(), "challenge"+tc.key)
+					got1, err := m.GetConsentRequest(context.Background(), "challenge"+tc.key)
 					require.NoError(t, err)
 					compareConsentRequest(t, c, got1)
 					assert.False(t, got1.WasHandled)
 
-					got1, err = m.HandleConsentRequest(context.TODO(), "challenge"+tc.key, h)
+					got1, err = m.HandleConsentRequest(context.Background(), "challenge"+tc.key, h)
 					require.NoError(t, err)
 					require.Equal(t, time.Now().UTC().Round(time.Minute), time.Time(h.HandledAt).Round(time.Minute))
 					compareConsentRequest(t, c, got1)
 
-					_, err = m.HandleConsentRequest(context.TODO(), "challenge"+tc.key, h)
+					_, err = m.HandleConsentRequest(context.Background(), "challenge"+tc.key, h)
 					require.NoError(t, err)
 
-					got2, err := m.VerifyAndInvalidateConsentRequest(context.TODO(), "verifier"+tc.key)
+					got2, err := m.VerifyAndInvalidateConsentRequest(context.Background(), "verifier"+tc.key)
 					require.NoError(t, err)
 					compareConsentRequest(t, c, got2.ConsentRequest)
-					assert.Equal(t, c.Challenge, got2.Challenge)
+					assert.Equal(t, c.ID, got2.ID)
 
 					if tc.hasError {
 						assert.True(t, got2.HasError())
@@ -442,10 +445,10 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 					assert.Equal(t, tc.remember, got2.Remember)
 					assert.Equal(t, tc.rememberFor, got2.RememberFor)
 
-					_, err = m.VerifyAndInvalidateConsentRequest(context.TODO(), "verifier"+tc.key)
+					_, err = m.VerifyAndInvalidateConsentRequest(context.Background(), "verifier"+tc.key)
 					require.Error(t, err)
 
-					got1, err = m.GetConsentRequest(context.TODO(), "challenge"+tc.key)
+					got1, err = m.GetConsentRequest(context.Background(), "challenge"+tc.key)
 					require.NoError(t, err)
 					assert.True(t, got1.WasHandled)
 				})
@@ -466,7 +469,7 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 				{"6", "6", 0},
 			} {
 				t.Run("key="+tc.keyC+"-"+tc.keyS, func(t *testing.T) {
-					rs, err := m.FindGrantedAndRememberedConsentRequests(context.TODO(), "fk-client-"+tc.keyC, "subject"+tc.keyS)
+					rs, err := m.FindGrantedAndRememberedConsentRequests(context.Background(), "fk-client-"+tc.keyC, "subject"+tc.keyS)
 					if tc.expectedLength == 0 {
 						assert.EqualError(t, err, ErrNoPreviousConsentFound.Error())
 					} else {
@@ -478,19 +481,19 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 		})
 
 		t.Run("case=revoke-auth-request", func(t *testing.T) {
-			require.NoError(t, m.CreateLoginSession(context.TODO(), &LoginSession{
+			require.NoError(t, m.CreateLoginSession(context.Background(), &LoginSession{
 				ID:              "rev-session-1",
 				AuthenticatedAt: time.Now(),
 				Subject:         "subject-1",
 			}))
 
-			require.NoError(t, m.CreateLoginSession(context.TODO(), &LoginSession{
+			require.NoError(t, m.CreateLoginSession(context.Background(), &LoginSession{
 				ID:              "rev-session-2",
 				AuthenticatedAt: time.Now(),
 				Subject:         "subject-2",
 			}))
 
-			require.NoError(t, m.CreateLoginSession(context.TODO(), &LoginSession{
+			require.NoError(t, m.CreateLoginSession(context.Background(), &LoginSession{
 				ID:              "rev-session-3",
 				AuthenticatedAt: time.Now(),
 				Subject:         "subject-1",
@@ -510,11 +513,11 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 				},
 			} {
 				t.Run(fmt.Sprintf("case=%d/subject=%s", i, tc.subject), func(t *testing.T) {
-					require.NoError(t, m.RevokeSubjectLoginSession(context.TODO(), tc.subject))
+					require.NoError(t, m.RevokeSubjectLoginSession(context.Background(), tc.subject))
 
 					for _, id := range tc.ids {
 						t.Run(fmt.Sprintf("id=%s", id), func(t *testing.T) {
-							_, err := m.GetRememberedLoginSession(context.TODO(), id)
+							_, err := m.GetRememberedLoginSession(context.Background(), id)
 							assert.EqualError(t, err, x.ErrNotFound.Error())
 						})
 					}
@@ -527,20 +530,20 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 			cr2, hcr2 := MockConsentRequest("rv2", false, 0, false, false, false)
 
 			// Ignore duplication errors
-			_ = clientManager.CreateClient(context.TODO(), cr1.Client)
-			_ = clientManager.CreateClient(context.TODO(), cr2.Client)
+			_ = clientManager.CreateClient(context.Background(), cr1.Client)
+			_ = clientManager.CreateClient(context.Background(), cr2.Client)
 
-			require.NoError(t, m.CreateConsentRequest(context.TODO(), cr1))
-			require.NoError(t, m.CreateConsentRequest(context.TODO(), cr2))
-			_, err := m.HandleConsentRequest(context.TODO(), "challengerv1", hcr1)
+			require.NoError(t, m.CreateConsentRequest(context.Background(), cr1))
+			require.NoError(t, m.CreateConsentRequest(context.Background(), cr2))
+			_, err := m.HandleConsentRequest(context.Background(), "challengerv1", hcr1)
 			require.NoError(t, err)
-			_, err = m.HandleConsentRequest(context.TODO(), "challengerv2", hcr2)
+			_, err = m.HandleConsentRequest(context.Background(), "challengerv2", hcr2)
 			require.NoError(t, err)
 
-			require.NoError(t, fositeManager.CreateAccessTokenSession(context.TODO(), "trva1", &fosite.Request{Client: cr1.Client, ID: "challengerv1", RequestedAt: time.Now()}))
-			require.NoError(t, fositeManager.CreateRefreshTokenSession(context.TODO(), "rrva1", &fosite.Request{Client: cr1.Client, ID: "challengerv1", RequestedAt: time.Now()}))
-			require.NoError(t, fositeManager.CreateAccessTokenSession(context.TODO(), "trva2", &fosite.Request{Client: cr2.Client, ID: "challengerv2", RequestedAt: time.Now()}))
-			require.NoError(t, fositeManager.CreateRefreshTokenSession(context.TODO(), "rrva2", &fosite.Request{Client: cr2.Client, ID: "challengerv2", RequestedAt: time.Now()}))
+			require.NoError(t, fositeManager.CreateAccessTokenSession(context.Background(), "trva1", &fosite.Request{Client: cr1.Client, ID: "challengerv1", RequestedAt: time.Now()}))
+			require.NoError(t, fositeManager.CreateRefreshTokenSession(context.Background(), "rrva1", &fosite.Request{Client: cr1.Client, ID: "challengerv1", RequestedAt: time.Now()}))
+			require.NoError(t, fositeManager.CreateAccessTokenSession(context.Background(), "trva2", &fosite.Request{Client: cr2.Client, ID: "challengerv2", RequestedAt: time.Now()}))
+			require.NoError(t, fositeManager.CreateRefreshTokenSession(context.Background(), "rrva2", &fosite.Request{Client: cr2.Client, ID: "challengerv2", RequestedAt: time.Now()}))
 
 			for i, tc := range []struct {
 				subject string
@@ -563,27 +566,27 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 				},
 			} {
 				t.Run(fmt.Sprintf("case=%d/subject=%s", i, tc.subject), func(t *testing.T) {
-					_, err := fositeManager.GetAccessTokenSession(context.TODO(), tc.at, nil)
+					_, err := fositeManager.GetAccessTokenSession(context.Background(), tc.at, nil)
 					assert.NoError(t, err)
-					_, err = fositeManager.GetRefreshTokenSession(context.TODO(), tc.rt, nil)
+					_, err = fositeManager.GetRefreshTokenSession(context.Background(), tc.rt, nil)
 					assert.NoError(t, err)
 
 					if tc.client == "" {
-						require.NoError(t, m.RevokeSubjectConsentSession(context.TODO(), tc.subject))
+						require.NoError(t, m.RevokeSubjectConsentSession(context.Background(), tc.subject))
 					} else {
-						require.NoError(t, m.RevokeSubjectClientConsentSession(context.TODO(), tc.subject, tc.client))
+						require.NoError(t, m.RevokeSubjectClientConsentSession(context.Background(), tc.subject, tc.client))
 					}
 
 					for _, id := range tc.ids {
 						t.Run(fmt.Sprintf("id=%s", id), func(t *testing.T) {
-							_, err := m.GetConsentRequest(context.TODO(), id)
-							assert.EqualError(t, err, x.ErrNotFound.Error())
+							_, err := m.GetConsentRequest(context.Background(), id)
+							assert.True(t, errors.Is(err, sqlcon.ErrNoRows))
 						})
 					}
 
-					r, err := fositeManager.GetAccessTokenSession(context.TODO(), tc.at, nil)
+					r, err := fositeManager.GetAccessTokenSession(context.Background(), tc.at, nil)
 					assert.Error(t, err, "%+v", r)
-					r, err = fositeManager.GetRefreshTokenSession(context.TODO(), tc.rt, nil)
+					r, err = fositeManager.GetRefreshTokenSession(context.Background(), tc.rt, nil)
 					assert.Error(t, err, "%+v", r)
 				})
 			}
@@ -594,14 +597,14 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 			cr2, hcr2 := MockConsentRequest("rv2", false, 0, false, false, false)
 
 			// Ignore duplicate errors
-			_ = clientManager.CreateClient(context.TODO(), cr1.Client)
-			_ = clientManager.CreateClient(context.TODO(), cr2.Client)
+			_ = clientManager.CreateClient(context.Background(), cr1.Client)
+			_ = clientManager.CreateClient(context.Background(), cr2.Client)
 
-			require.NoError(t, m.CreateConsentRequest(context.TODO(), cr1))
-			require.NoError(t, m.CreateConsentRequest(context.TODO(), cr2))
-			_, err := m.HandleConsentRequest(context.TODO(), "challengerv1", hcr1)
+			require.NoError(t, m.CreateConsentRequest(context.Background(), cr1))
+			require.NoError(t, m.CreateConsentRequest(context.Background(), cr2))
+			_, err := m.HandleConsentRequest(context.Background(), "challengerv1", hcr1)
 			require.NoError(t, err)
-			_, err = m.HandleConsentRequest(context.TODO(), "challengerv2", hcr2)
+			_, err = m.HandleConsentRequest(context.Background(), "challengerv2", hcr2)
 			require.NoError(t, err)
 
 			for i, tc := range []struct {
@@ -626,7 +629,7 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 				},
 			} {
 				t.Run(fmt.Sprintf("case=%d/subject=%s", i, tc.subject), func(t *testing.T) {
-					consents, err := m.FindSubjectsGrantedConsentRequests(context.TODO(), tc.subject, 100, 0)
+					consents, err := m.FindSubjectsGrantedConsentRequests(context.Background(), tc.subject, 100, 0)
 					assert.Equal(t, len(tc.challenges), len(consents))
 
 					if len(tc.challenges) == 0 {
@@ -634,12 +637,12 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 					} else {
 						require.NoError(t, err)
 						for _, consent := range consents {
-							assert.Contains(t, tc.challenges, consent.Challenge)
+							assert.Contains(t, tc.challenges, consent.ID)
 							assert.Contains(t, tc.clients, consent.ConsentRequest.Client.ID)
 						}
 					}
 
-					n, err := m.CountSubjectsGrantedConsentRequests(context.TODO(), tc.subject)
+					n, err := m.CountSubjectsGrantedConsentRequests(context.Background(), tc.subject)
 					require.NoError(t, err)
 					assert.Equal(t, n, len(tc.challenges))
 
@@ -647,17 +650,17 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 			}
 
 			t.Run("case=obfuscated", func(t *testing.T) {
-				_, err := m.GetForcedObfuscatedLoginSession(context.TODO(), "fk-client-1", "obfuscated-1")
-				require.EqualError(t, err, x.ErrNotFound.Error())
+				_, err := m.GetForcedObfuscatedLoginSession(context.Background(), "fk-client-1", "obfuscated-1")
+				require.True(t, errors.Is(err, sqlcon.ErrNoRows))
 
 				expect := &ForcedObfuscatedLoginSession{
 					ClientID:          "fk-client-1",
 					Subject:           "subject-1",
 					SubjectObfuscated: "obfuscated-1",
 				}
-				require.NoError(t, m.CreateForcedObfuscatedLoginSession(context.TODO(), expect))
+				require.NoError(t, m.CreateForcedObfuscatedLoginSession(context.Background(), expect))
 
-				got, err := m.GetForcedObfuscatedLoginSession(context.TODO(), "fk-client-1", "obfuscated-1")
+				got, err := m.GetForcedObfuscatedLoginSession(context.Background(), "fk-client-1", "obfuscated-1")
 				require.NoError(t, err)
 				assert.EqualValues(t, expect, got)
 
@@ -666,14 +669,14 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 					Subject:           "subject-1",
 					SubjectObfuscated: "obfuscated-2",
 				}
-				require.NoError(t, m.CreateForcedObfuscatedLoginSession(context.TODO(), expect))
+				require.NoError(t, m.CreateForcedObfuscatedLoginSession(context.Background(), expect))
 
-				got, err = m.GetForcedObfuscatedLoginSession(context.TODO(), "fk-client-1", "obfuscated-2")
+				got, err = m.GetForcedObfuscatedLoginSession(context.Background(), "fk-client-1", "obfuscated-2")
 				require.NoError(t, err)
 				assert.EqualValues(t, expect, got)
 
-				_, err = m.GetForcedObfuscatedLoginSession(context.TODO(), "fk-client-1", "obfuscated-1")
-				require.EqualError(t, err, x.ErrNotFound.Error())
+				_, err = m.GetForcedObfuscatedLoginSession(context.Background(), "fk-client-1", "obfuscated-1")
+				require.True(t, errors.Is(err, sqlcon.ErrNoRows))
 			})
 
 			t.Run("case=ListUserAuthenticatedClientsWithFrontAndBackChannelLogout", func(t *testing.T) {
@@ -747,13 +750,13 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 					}
 
 					t.Run(fmt.Sprintf("method=ListUserAuthenticatedClientsWithFrontChannelLogout/session=%s/subject=%s", ls.ID, ls.Subject), func(t *testing.T) {
-						actual, err := m.ListUserAuthenticatedClientsWithFrontChannelLogout(context.TODO(), ls.Subject, ls.ID)
+						actual, err := m.ListUserAuthenticatedClientsWithFrontChannelLogout(context.Background(), ls.Subject, ls.ID)
 						require.NoError(t, err)
 						check(t, frontChannels, actual)
 					})
 
 					t.Run(fmt.Sprintf("method=ListUserAuthenticatedClientsWithBackChannelLogout/session=%s", ls.ID), func(t *testing.T) {
-						actual, err := m.ListUserAuthenticatedClientsWithBackChannelLogout(context.TODO(), ls.Subject, ls.ID)
+						actual, err := m.ListUserAuthenticatedClientsWithBackChannelLogout(context.Background(), ls.Subject, ls.ID)
 						require.NoError(t, err)
 						check(t, backChannels, actual)
 					})
@@ -776,42 +779,42 @@ func ManagerTests(m Manager, clientManager client.Manager, fositeManager x.Fosit
 					t.Run("key="+tc.key, func(t *testing.T) {
 						c := MockLogoutRequest(tc.key, tc.withClient)
 						if tc.withClient {
-							require.NoError(t, clientManager.CreateClient(context.TODO(), c.Client)) // Ignore errors that are caused by duplication
+							require.NoError(t, clientManager.CreateClient(context.Background(), c.Client)) // Ignore errors that are caused by duplication
 						}
 
-						_, err := m.GetLogoutRequest(context.TODO(), "challenge"+tc.key)
+						_, err := m.GetLogoutRequest(context.Background(), "challenge"+tc.key)
 						require.Error(t, err)
 
-						require.NoError(t, m.CreateLogoutRequest(context.TODO(), c))
+						require.NoError(t, m.CreateLogoutRequest(context.Background(), c))
 
-						got2, err := m.GetLogoutRequest(context.TODO(), "challenge"+tc.key)
+						got2, err := m.GetLogoutRequest(context.Background(), "challenge"+tc.key)
 						require.NoError(t, err)
 						assert.False(t, got2.WasUsed)
 						assert.False(t, got2.Accepted)
 						compareLogoutRequest(t, c, got2)
 
 						if k%2 == 0 {
-							got2, err = m.AcceptLogoutRequest(context.TODO(), "challenge"+tc.key)
+							got2, err = m.AcceptLogoutRequest(context.Background(), "challenge"+tc.key)
 							require.NoError(t, err)
 							assert.True(t, got2.Accepted)
 							compareLogoutRequest(t, c, got2)
 
-							got3, err := m.VerifyAndInvalidateLogoutRequest(context.TODO(), "verifier"+tc.key)
+							got3, err := m.VerifyAndInvalidateLogoutRequest(context.Background(), "verifier"+tc.key)
 							require.NoError(t, err)
 							assert.True(t, got3.Accepted)
 							assert.True(t, got3.WasUsed)
 							compareLogoutRequest(t, c, got3)
 
-							_, err = m.VerifyAndInvalidateLogoutRequest(context.TODO(), "verifier"+tc.key)
+							_, err = m.VerifyAndInvalidateLogoutRequest(context.Background(), "verifier"+tc.key)
 							require.Error(t, err)
 
-							got2, err = m.GetLogoutRequest(context.TODO(), "challenge"+tc.key)
+							got2, err = m.GetLogoutRequest(context.Background(), "challenge"+tc.key)
 							require.NoError(t, err)
 							compareLogoutRequest(t, got3, got2)
 							assert.True(t, got2.WasUsed)
 						} else {
-							require.NoError(t, m.RejectLogoutRequest(context.TODO(), "challenge"+tc.key))
-							_, err = m.GetLogoutRequest(context.TODO(), "challenge"+tc.key)
+							require.NoError(t, m.RejectLogoutRequest(context.Background(), "challenge"+tc.key))
+							_, err = m.GetLogoutRequest(context.Background(), "challenge"+tc.key)
 							require.Error(t, err)
 						}
 					})
@@ -827,7 +830,7 @@ func compareLogoutRequest(t *testing.T, a, b *LogoutRequest) {
 		assert.EqualValues(t, a.Client.GetID(), b.Client.GetID())
 	}
 
-	assert.EqualValues(t, a.Challenge, b.Challenge)
+	assert.EqualValues(t, a.ID, b.ID)
 	assert.EqualValues(t, a.Subject, b.Subject)
 	assert.EqualValues(t, a.Verifier, b.Verifier)
 	assert.EqualValues(t, a.RequestURL, b.RequestURL)
@@ -838,7 +841,7 @@ func compareLogoutRequest(t *testing.T, a, b *LogoutRequest) {
 
 func compareAuthenticationRequest(t *testing.T, a, b *LoginRequest) {
 	assert.EqualValues(t, a.Client.GetID(), b.Client.GetID())
-	assert.EqualValues(t, a.Challenge, b.Challenge)
+	assert.EqualValues(t, a.ID, b.ID)
 	assert.EqualValues(t, *a.OpenIDConnectContext, *b.OpenIDConnectContext)
 	assert.EqualValues(t, a.Subject, b.Subject)
 	assert.EqualValues(t, a.RequestedScope, b.RequestedScope)
@@ -851,7 +854,7 @@ func compareAuthenticationRequest(t *testing.T, a, b *LoginRequest) {
 
 func compareConsentRequest(t *testing.T, a, b *ConsentRequest) {
 	assert.EqualValues(t, a.Client.GetID(), b.Client.GetID())
-	assert.EqualValues(t, a.Challenge, b.Challenge)
+	assert.EqualValues(t, a.ID, b.ID)
 	assert.EqualValues(t, *a.OpenIDConnectContext, *b.OpenIDConnectContext)
 	assert.EqualValues(t, a.Subject, b.Subject)
 	assert.EqualValues(t, a.RequestedScope, b.RequestedScope)
diff --git a/consent/sdk_test.go b/consent/sdk_test.go
index 7e9f8ced5..592e5f4ed 100644
--- a/consent/sdk_test.go
+++ b/consent/sdk_test.go
@@ -34,7 +34,6 @@ import (
 	"github.com/ory/x/urlx"
 
 	"github.com/ory/hydra/x"
-
 	"github.com/ory/viper"
 
 	"github.com/ory/hydra/driver/configuration"
@@ -50,7 +49,7 @@ func TestSDK(t *testing.T) {
 	conf := internal.NewConfigurationWithDefaults()
 	viper.Set(configuration.ViperKeyIssuerURL, "https://www.ory.sh")
 	viper.Set(configuration.ViperKeyAccessTokenLifespan, time.Minute)
-	reg := internal.NewRegistryMemory(conf)
+	reg := internal.NewRegistryMemory(t, conf)
 
 	router := x.NewRouterPublic()
 	h := NewHandler(reg, conf)
@@ -62,38 +61,57 @@ func TestSDK(t *testing.T) {
 
 	m := reg.ConsentManager()
 
-	require.NoError(t, m.CreateLoginSession(context.TODO(), &LoginSession{
+	require.NoError(t, m.CreateLoginSession(context.Background(), &LoginSession{
 		ID:      "session1",
 		Subject: "subject1",
 	}))
 
 	ar1, _ := MockAuthRequest("1", false)
 	ar2, _ := MockAuthRequest("2", false)
-	require.NoError(t, m.CreateLoginRequest(context.TODO(), ar1))
-	require.NoError(t, m.CreateLoginRequest(context.TODO(), ar2))
+	require.NoError(t, reg.ClientManager().CreateClient(context.Background(), ar1.Client))
+	require.NoError(t, reg.ClientManager().CreateClient(context.Background(), ar2.Client))
+	require.NoError(t, m.CreateLoginSession(context.Background(), &LoginSession{
+		ID:      ar1.SessionID.String(),
+		Subject: ar1.Subject,
+	}))
+	require.NoError(t, m.CreateLoginSession(context.Background(), &LoginSession{
+		ID:      ar2.SessionID.String(),
+		Subject: ar2.Subject,
+	}))
+	require.NoError(t, m.CreateLoginRequest(context.Background(), ar1))
+	require.NoError(t, m.CreateLoginRequest(context.Background(), ar2))
 
 	cr1, hcr1 := MockConsentRequest("1", false, 0, false, false, false)
 	cr2, hcr2 := MockConsentRequest("2", false, 0, false, false, false)
 	cr3, hcr3 := MockConsentRequest("3", true, 3600, false, false, false)
 	cr4, hcr4 := MockConsentRequest("4", true, 3600, false, false, false)
-	require.NoError(t, m.CreateConsentRequest(context.TODO(), cr1))
-	require.NoError(t, m.CreateConsentRequest(context.TODO(), cr2))
-	require.NoError(t, m.CreateConsentRequest(context.TODO(), cr3))
-	require.NoError(t, m.CreateConsentRequest(context.TODO(), cr4))
-	_, err := m.HandleConsentRequest(context.TODO(), "challenge1", hcr1)
+	require.NoError(t, reg.ClientManager().CreateClient(context.Background(), cr3.Client))
+	require.NoError(t, reg.ClientManager().CreateClient(context.Background(), cr4.Client))
+	require.NoError(t, m.CreateLoginRequest(context.Background(), &LoginRequest{ID: cr1.LoginChallenge.String(), Client: cr1.Client, Verifier: cr1.ID}))
+	require.NoError(t, m.CreateLoginRequest(context.Background(), &LoginRequest{ID: cr2.LoginChallenge.String(), Client: cr2.Client, Verifier: cr2.ID}))
+	require.NoError(t, m.CreateLoginRequest(context.Background(), &LoginRequest{ID: cr3.LoginChallenge.String(), Client: cr3.Client, Verifier: cr3.ID}))
+	require.NoError(t, m.CreateLoginSession(context.Background(), &LoginSession{ID: cr3.LoginSessionID.String()}))
+	require.NoError(t, m.CreateLoginRequest(context.Background(), &LoginRequest{ID: cr4.LoginChallenge.String(), Client: cr4.Client, Verifier: cr4.ID}))
+	require.NoError(t, m.CreateLoginSession(context.Background(), &LoginSession{ID: cr4.LoginSessionID.String()}))
+	require.NoError(t, m.CreateConsentRequest(context.Background(), cr1))
+	require.NoError(t, m.CreateConsentRequest(context.Background(), cr2))
+	require.NoError(t, m.CreateConsentRequest(context.Background(), cr3))
+	require.NoError(t, m.CreateConsentRequest(context.Background(), cr4))
+	_, err := m.HandleConsentRequest(context.Background(), "challenge1", hcr1)
 	require.NoError(t, err)
-	_, err = m.HandleConsentRequest(context.TODO(), "challenge2", hcr2)
+	_, err = m.HandleConsentRequest(context.Background(), "challenge2", hcr2)
 	require.NoError(t, err)
-	_, err = m.HandleConsentRequest(context.TODO(), "challenge3", hcr3)
+	_, err = m.HandleConsentRequest(context.Background(), "challenge3", hcr3)
 	require.NoError(t, err)
-	_, err = m.HandleConsentRequest(context.TODO(), "challenge4", hcr4)
+	_, err = m.HandleConsentRequest(context.Background(), "challenge4", hcr4)
 	require.NoError(t, err)
 
 	lur1 := MockLogoutRequest("testsdk-1", true)
-	require.NoError(t, m.CreateLogoutRequest(context.TODO(), lur1))
+	require.NoError(t, reg.ClientManager().CreateClient(context.Background(), lur1.Client))
+	require.NoError(t, m.CreateLogoutRequest(context.Background(), lur1))
 
 	lur2 := MockLogoutRequest("testsdk-2", false)
-	require.NoError(t, m.CreateLogoutRequest(context.TODO(), lur2))
+	require.NoError(t, m.CreateLogoutRequest(context.Background(), lur2))
 
 	crGot, err := sdk.Admin.GetConsentRequest(admin.NewGetConsentRequestParams().WithConsentChallenge("challenge1"))
 	require.NoError(t, err)
@@ -162,14 +180,14 @@ func TestSDK(t *testing.T) {
 }
 
 func compareSDKLoginRequest(t *testing.T, expected *LoginRequest, got models.LoginRequest) {
-	assert.EqualValues(t, expected.Challenge, *got.Challenge)
+	assert.EqualValues(t, expected.ID, *got.Challenge)
 	assert.EqualValues(t, expected.Subject, *got.Subject)
 	assert.EqualValues(t, expected.Skip, *got.Skip)
 	assert.EqualValues(t, expected.Client.GetID(), got.Client.ClientID)
 }
 
 func compareSDKConsentRequest(t *testing.T, expected *ConsentRequest, got models.ConsentRequest) {
-	assert.EqualValues(t, expected.Challenge, *got.Challenge)
+	assert.EqualValues(t, expected.ID, *got.Challenge)
 	assert.EqualValues(t, expected.Subject, got.Subject)
 	assert.EqualValues(t, expected.Skip, got.Skip)
 	assert.EqualValues(t, expected.Client.GetID(), got.Client.ClientID)
diff --git a/consent/sql_helper.go b/consent/sql_helper.go
deleted file mode 100644
index 5dcaa7615..000000000
--- a/consent/sql_helper.go
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @Copyright 	2017-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @license 	Apache-2.0
- */
-
-package consent
-
-import (
-	"fmt"
-)
-
-var sqlParamsAuthenticationRequestHandled = []string{
-	"challenge",
-	"subject",
-	"remember",
-	"remember_for",
-	"error",
-	"requested_at",
-	"authenticated_at",
-	"acr",
-	"was_used",
-	"context",
-	"forced_subject_identifier",
-}
-
-var sqlParamsAuthenticationRequest = []string{
-	"challenge",
-	"verifier",
-	"client_id",
-	"subject",
-	"request_url",
-	"skip",
-	"requested_scope",
-	"requested_at_audience",
-	"authenticated_at",
-	"requested_at",
-	"csrf",
-	"oidc_context",
-	"login_session_id",
-}
-
-var sqlParamsConsentRequest = append(sqlParamsAuthenticationRequest,
-	"forced_subject_identifier",
-	"login_challenge",
-	"acr",
-	"context",
-)
-
-var sqlParamsConsentRequestHandled = []string{
-	"challenge",
-	"granted_scope",
-	"granted_at_audience",
-	"remember",
-	"remember_for",
-	"authenticated_at",
-	"error",
-	"requested_at",
-	"session_access_token",
-	"session_id_token",
-	"was_used",
-	"handled_at",
-}
-var sqlParamsConsentRequestHandledUpdate = func() []string {
-	p := make([]string, len(sqlParamsConsentRequestHandled))
-	for i, v := range sqlParamsConsentRequestHandled {
-		p[i] = fmt.Sprintf("%s=:%s", v, v)
-	}
-	return p
-}()
-
-var sqlParamsAuthSession = []string{
-	"id",
-	"authenticated_at",
-	"subject",
-	"remember",
-}
-
-var sqlParamsLogoutRequest = []string{
-	"challenge",
-	"verifier",
-	"subject",
-	"sid",
-	"request_url",
-	"redir_url",
-	"was_used",
-	"accepted",
-	"rejected",
-	"client_id",
-	"rp_initiated",
-}
diff --git a/consent/strategy_default.go b/consent/strategy_default.go
index 1aaa9a1c1..441b79a3c 100644
--- a/consent/strategy_default.go
+++ b/consent/strategy_default.go
@@ -30,6 +30,8 @@ import (
 	"sync"
 	"time"
 
+	"github.com/ory/x/sqlcon"
+
 	jwtgo "github.com/dgrijalva/jwt-go"
 	"github.com/gorilla/sessions"
 	"github.com/pborman/uuid"
@@ -262,7 +264,7 @@ func (s *DefaultStrategy) forwardAuthenticationRequest(w http.ResponseWriter, r
 	if err := s.r.ConsentManager().CreateLoginRequest(
 		r.Context(),
 		&LoginRequest{
-			Challenge:         challenge,
+			ID:                challenge,
 			Verifier:          verifier,
 			CSRF:              csrf,
 			Skip:              skip,
@@ -347,7 +349,7 @@ func (s *DefaultStrategy) obfuscateSubjectIdentifier(cl fosite.Client, subject,
 func (s *DefaultStrategy) verifyAuthentication(w http.ResponseWriter, r *http.Request, req fosite.AuthorizeRequester, verifier string) (*HandledLoginRequest, error) {
 	ctx := r.Context()
 	session, err := s.r.ConsentManager().VerifyAndInvalidateLoginRequest(ctx, verifier)
-	if errors.Is(err, x.ErrNotFound) {
+	if errors.Is(err, sqlcon.ErrNoRows) {
 		return nil, errors.WithStack(fosite.ErrAccessDenied.WithDebug("The login verifier has already been used, has not been granted, or is invalid."))
 	} else if err != nil {
 		return nil, err
@@ -548,7 +550,7 @@ func (s *DefaultStrategy) forwardConsentRequest(w http.ResponseWriter, r *http.R
 	if err := s.r.ConsentManager().CreateConsentRequest(
 		r.Context(),
 		&ConsentRequest{
-			Challenge:              challenge,
+			ID:                     challenge,
 			ACR:                    as.ACR,
 			Verifier:               verifier,
 			CSRF:                   csrf,
@@ -563,7 +565,7 @@ func (s *DefaultStrategy) forwardConsentRequest(w http.ResponseWriter, r *http.R
 			ForceSubjectIdentifier: as.ForceSubjectIdentifier,
 			OpenIDConnectContext:   as.LoginRequest.OpenIDConnectContext,
 			LoginSessionID:         as.LoginRequest.SessionID,
-			LoginChallenge:         sqlxx.NullString(as.LoginRequest.Challenge),
+			LoginChallenge:         sqlxx.NullString(as.LoginRequest.ID),
 			Context:                as.Context,
 		},
 	); err != nil {
@@ -586,7 +588,7 @@ func (s *DefaultStrategy) forwardConsentRequest(w http.ResponseWriter, r *http.R
 
 func (s *DefaultStrategy) verifyConsent(w http.ResponseWriter, r *http.Request, req fosite.AuthorizeRequester, verifier string) (*HandledConsentRequest, error) {
 	session, err := s.r.ConsentManager().VerifyAndInvalidateConsentRequest(r.Context(), verifier)
-	if errors.Is(err, x.ErrNotFound) {
+	if errors.Is(err, sqlcon.ErrNoRows) {
 		return nil, errors.WithStack(fosite.ErrAccessDenied.WithDebug("The consent verifier has already been used, has not been granted, or is invalid."))
 	} else if err != nil {
 		return nil, err
@@ -789,7 +791,7 @@ func (s *DefaultStrategy) issueLogoutVerifier(w http.ResponseWriter, r *http.Req
 		challenge := uuid.New()
 		if err := s.r.ConsentManager().CreateLogoutRequest(r.Context(), &LogoutRequest{
 			RequestURL:  r.URL.String(),
-			Challenge:   challenge,
+			ID:          challenge,
 			Subject:     session.Subject,
 			SessionID:   session.ID,
 			Verifier:    uuid.New(),
@@ -912,7 +914,7 @@ func (s *DefaultStrategy) issueLogoutVerifier(w http.ResponseWriter, r *http.Req
 	challenge := uuid.New()
 	if err := s.r.ConsentManager().CreateLogoutRequest(r.Context(), &LogoutRequest{
 		RequestURL:  r.URL.String(),
-		Challenge:   challenge,
+		ID:          challenge,
 		SessionID:   hintSid,
 		Subject:     session.Subject,
 		Verifier:    uuid.New(),
diff --git a/consent/strategy_default_test.go b/consent/strategy_default_test.go
index 9974fed0c..5f7ea6e00 100644
--- a/consent/strategy_default_test.go
+++ b/consent/strategy_default_test.go
@@ -115,7 +115,7 @@ func acceptRequest(apiClient *hydra.OryHydra, consent *models.AcceptConsentReque
 	}
 }
 
-func newAuthCookieJar(t *testing.T, reg *driver.RegistryMemory, u, sessionID string) http.CookieJar {
+func newAuthCookieJar(t *testing.T, reg driver.Registry, u, sessionID string) http.CookieJar {
 	cj, err := cookiejar.New(&cookiejar.Options{})
 	require.NoError(t, err)
 	secrets := viper.GetStringSlice(configuration.ViperKeyGetCookieSecrets)
@@ -125,7 +125,7 @@ func newAuthCookieJar(t *testing.T, reg *driver.RegistryMemory, u, sessionID str
 	}
 
 	hr := &http.Request{Header: map[string][]string{}, URL: urlx.ParseOrPanic(u), RequestURI: u}
-	cookie, _ := reg.CookieStore().Get(hr, CookieName(reg.C.ServesHTTPS(), CookieAuthenticationName))
+	cookie, _ := reg.CookieStore().Get(hr, CookieName(reg.Config().ServesHTTPS(), CookieAuthenticationName))
 
 	cookie.Values[CookieAuthenticationSIDName] = sessionID
 	cookie.Options.HttpOnly = true
@@ -137,7 +137,7 @@ func newAuthCookieJar(t *testing.T, reg *driver.RegistryMemory, u, sessionID str
 	return cj
 }
 
-func newValidAuthCookieJar(t *testing.T, reg *driver.RegistryMemory, u, sessionID, subject string) http.CookieJar {
+func newValidAuthCookieJar(t *testing.T, reg driver.Registry, u, sessionID, subject string) http.CookieJar {
 	cj := newAuthCookieJar(t, reg, u, sessionID)
 	require.NoError(t, reg.ConsentManager().CreateLoginSession(context.TODO(), &LoginSession{
 		ID:              sessionID,
@@ -167,7 +167,7 @@ func acceptLogoutChallenge(api *hydra.OryHydra, key string) func(t *testing.T) f
 	}
 }
 
-func genIDToken(t *testing.T, reg *driver.RegistryMemory, c jwtgo.Claims) string {
+func genIDToken(t *testing.T, reg driver.Registry, c jwtgo.Claims) string {
 	r, _, err := reg.OpenIDJWTStrategy().Generate(context.TODO(), c, jwt.NewHeaders())
 	require.NoError(t, err)
 	return r
@@ -194,7 +194,7 @@ func logoutHandler(strategy Strategy, writer herodot.Writer, w http.ResponseWrit
 
 func runLogout(t *testing.T, method string) {
 	conf := internal.NewConfigurationWithDefaults()
-	reg := internal.NewRegistryMemory(conf)
+	reg := internal.NewRegistryMemory(t, conf)
 
 	internal.MustEnsureRegistryKeys(reg, x.OpenIDConnectKeyName)
 	// jwts := reg.OpenIDJWTStrategy()
@@ -490,10 +490,11 @@ func runLogout(t *testing.T, method string) {
 				c.LoginSessionID = sqlxx.NullString(tc.sessionID)
 				c.Client.BackChannelLogoutURI = servers[k].URL
 				c.Subject = tc.subject
+				require.NoError(t, reg.ClientManager().CreateClient(context.Background(), c.Client))
+				require.NoError(t, reg.ConsentManager().CreateLoginRequest(context.Background(), &LoginRequest{ID: c.LoginChallenge.String(), Client: c.Client, Verifier: c.ID}))
 				require.NoError(t, reg.ConsentManager().CreateConsentRequest(context.Background(), c))
-				_, err := reg.ConsentManager().HandleConsentRequest(context.Background(), c.Challenge, hc)
+				_, err := reg.ConsentManager().HandleConsentRequest(context.Background(), c.ID, hc)
 				require.NoError(t, err)
-				require.NoError(t, reg.ClientManager().CreateClient(context.TODO(), c.Client))
 			}
 
 			cl := &http.Client{
@@ -540,7 +541,7 @@ func TestStrategyLogoutPost(t *testing.T) {
 
 func TestStrategyLoginConsent(t *testing.T) {
 	conf := internal.NewConfigurationWithDefaults()
-	reg := internal.NewRegistryMemory(conf)
+	reg := internal.NewRegistryMemory(t, conf)
 
 	var lph, cph, aph func(w http.ResponseWriter, r *http.Request)
 	lp := mockProvider(&lph)
@@ -576,6 +577,8 @@ func TestStrategyLoginConsent(t *testing.T) {
 	persistentCJ4 := newCookieJar(t)
 	nonexistentCJ := newAuthCookieJar(t, reg, ap.URL, "i-do-not-exist")
 
+	require.NoError(t, reg.ClientManager().CreateClient(context.Background(), &client.Client{ID: "client-id"}))
+
 	for k, tc := range []struct {
 		setup                 func()
 		d                     string
diff --git a/consent/types.go b/consent/types.go
index 56fb83da9..d0fec3f83 100644
--- a/consent/types.go
+++ b/consent/types.go
@@ -28,6 +28,10 @@ import (
 	"net/http"
 	"time"
 
+	"github.com/ory/x/sqlcon"
+
+	"github.com/gobuffalo/pop/v5"
+
 	"github.com/pkg/errors"
 
 	"github.com/ory/fosite"
@@ -59,7 +63,7 @@ type LoginSession struct {
 	Remember        bool      `db:"remember"`
 }
 
-func (s LoginSession) TableName() string {
+func (_ LoginSession) TableName() string {
 	return "hydra_oauth2_authentication_session"
 }
 
@@ -137,7 +141,7 @@ func (e *RequestDeniedError) Scan(value interface{}) error {
 }
 
 func (e *RequestDeniedError) Value() (driver.Value, error) {
-	if e == nil {
+	if !e.IsError() {
 		return "{}", nil
 	}
 
@@ -153,6 +157,9 @@ func (e *RequestDeniedError) Value() (driver.Value, error) {
 //
 // swagger:model acceptConsentRequest
 type HandledConsentRequest struct {
+	// ID instead of Challenge because of pop
+	ID string `json:"-" db:"challenge"`
+
 	// GrantScope sets the scope the user authorized the client to use. Should be a subset of `requested_scope`.
 	GrantedScope sqlxx.StringSlicePipeDelimiter `json:"grant_scope" db:"granted_scope"`
 
@@ -175,7 +182,6 @@ type HandledConsentRequest struct {
 
 	ConsentRequest  *ConsentRequest     `json:"-" db:"-"`
 	Error           *RequestDeniedError `json:"-" db:"error"`
-	Challenge       string              `json:"-" db:"challenge"`
 	RequestedAt     time.Time           `json:"-" db:"requested_at"`
 	AuthenticatedAt sqlxx.NullTime      `json:"-" db:"authenticated_at"`
 	WasUsed         bool                `json:"-" db:"was_used"`
@@ -184,7 +190,7 @@ type HandledConsentRequest struct {
 	SessionAccessToken sqlxx.MapStringInterface `db:"session_access_token" json:"-"`
 }
 
-func (r HandledConsentRequest) TableName() string {
+func (_ HandledConsentRequest) TableName() string {
 	return "hydra_oauth2_consent_request_handled"
 }
 
@@ -192,16 +198,20 @@ func (r *HandledConsentRequest) HasError() bool {
 	return r.Error.IsError()
 }
 
-func (r *HandledConsentRequest) prepareSQL() *HandledConsentRequest {
+func (r *HandledConsentRequest) BeforeSave(_ *pop.Connection) error {
 	if r.Session != nil {
 		r.SessionAccessToken = r.Session.AccessToken
 		r.SessionIDToken = r.Session.IDToken
 	}
-	return r
+	return nil
 }
 
-func (r *HandledConsentRequest) postSQL(cr *ConsentRequest) *HandledConsentRequest {
-	r.ConsentRequest = cr
+func (r *HandledConsentRequest) AfterSave(c *pop.Connection) error {
+	r.ConsentRequest = &ConsentRequest{}
+	if err := r.ConsentRequest.FindInDB(c, r.ID); err != nil {
+		return errors.WithStack(err)
+	}
+
 	if r.SessionAccessToken == nil {
 		r.SessionAccessToken = make(map[string]interface{})
 	}
@@ -209,12 +219,19 @@ func (r *HandledConsentRequest) postSQL(cr *ConsentRequest) *HandledConsentReque
 		r.SessionIDToken = make(map[string]interface{})
 	}
 	r.Session = &ConsentRequestSessionData{AccessToken: r.SessionAccessToken, IDToken: r.SessionIDToken}
-	return r
+	return nil
+}
+
+func (r *HandledConsentRequest) AfterFind(c *pop.Connection) error {
+	return r.AfterSave(c)
 }
 
 // The response used to return used consent requests
 // same as HandledLoginRequest, just with consent_request exposed as json
 type PreviousConsentSession struct {
+	// Named ID because of pop
+	ID string `json:"-" db:"challenge"`
+
 	// GrantScope sets the scope the user authorized the client to use. Should be a subset of `requested_scope`.
 	GrantedScope sqlxx.StringSlicePipeDelimiter `json:"grant_scope" db:"granted_scope"`
 
@@ -237,7 +254,6 @@ type PreviousConsentSession struct {
 
 	ConsentRequest  *ConsentRequest     `json:"consent_request" db:"-"`
 	Error           *RequestDeniedError `json:"-" db:"error"`
-	Challenge       string              `json:"-" db:"challenge"`
 	RequestedAt     time.Time           `json:"-" db:"requested_at"`
 	AuthenticatedAt sqlxx.NullTime      `json:"-" db:"authenticated_at"`
 	WasUsed         bool                `json:"-" db:"was_used"`
@@ -250,6 +266,9 @@ type PreviousConsentSession struct {
 //
 // swagger:model acceptLoginRequest
 type HandledLoginRequest struct {
+	// ID instead of challenge for pop
+	ID string `json:"-" db:"challenge"`
+
 	// Remember, if set to true, tells ORY Hydra to remember this user by telling the user agent (browser) to store
 	// a cookie with authentication data. If the same user performs another OAuth 2.0 Authorization Request, he/she
 	// will not be asked to log in again.
@@ -294,13 +313,12 @@ type HandledLoginRequest struct {
 
 	LoginRequest    *LoginRequest       `json:"-" db:"-"`
 	Error           *RequestDeniedError `json:"-" db:"error"`
-	Challenge       string              `json:"-" db:"challenge"`
 	RequestedAt     time.Time           `json:"-" db:"requested_at"`
 	AuthenticatedAt sqlxx.NullTime      `json:"-" db:"authenticated_at"`
 	WasUsed         bool                `json:"-" db:"was_used"`
 }
 
-func (r HandledLoginRequest) TableName() string {
+func (_ HandledLoginRequest) TableName() string {
 	return "hydra_oauth2_authentication_request_handled"
 }
 
@@ -308,16 +326,16 @@ func (r *HandledLoginRequest) HasError() bool {
 	return r.Error.IsError()
 }
 
-func (r *HandledLoginRequest) postSQL(lr *LoginRequest) *HandledLoginRequest {
-	r.LoginRequest = lr
-	return r
+func (r *HandledLoginRequest) AfterUpdate(c *pop.Connection) error {
+	r.LoginRequest = &LoginRequest{}
+	return r.LoginRequest.FindInDB(c, r.ID)
 }
 
-func (r *HandledLoginRequest) prepareSQL() *HandledLoginRequest {
+func (r *HandledLoginRequest) BeforeSave(_ *pop.Connection) error {
 	if string(r.Context) == "" {
 		r.Context = sqlxx.JSONRawMessage("{}")
 	}
-	return r
+	return nil
 }
 
 // Contains optional information about the OpenID Connect request.
@@ -382,7 +400,7 @@ func (n *OpenIDConnectContext) Value() (driver.Value, error) {
 type LogoutRequest struct {
 	// Challenge is the identifier ("logout challenge") of the logout authentication request. It is used to
 	// identify the session.
-	Challenge string `json:"-" db:"challenge"`
+	ID string `json:"-" db:"challenge"`
 
 	// Subject is the user for whom the logout was request.
 	Subject string `json:"subject" db:"subject"`
@@ -405,14 +423,26 @@ type LogoutRequest struct {
 	Client                *client.Client `json:"-" db:"-"`
 }
 
-func (r *LogoutRequest) prepareSQL() *LogoutRequest {
+func (_ LogoutRequest) TableName() string {
+	return "hydra_oauth2_logout_request"
+}
+
+func (r *LogoutRequest) BeforeSave(_ *pop.Connection) error {
 	if r.Client != nil {
 		r.ClientID = sql.NullString{
 			Valid:  true,
 			String: r.Client.ID,
 		}
 	}
-	return r
+	return nil
+}
+
+func (r *LogoutRequest) AfterFind(c *pop.Connection) error {
+	if r.ClientID.Valid {
+		r.Client = &client.Client{}
+		return sqlcon.HandleError(c.Find(r.Client, r.ClientID.String))
+	}
+	return nil
 }
 
 // Returned when the log out request was used.
@@ -427,11 +457,11 @@ type LogoutResult struct {
 //
 // swagger:model loginRequest
 type LoginRequest struct {
-	// Challenge is the identifier ("login challenge") of the login request. It is used to
+	// ID is the identifier ("login challenge") of the login request. It is used to
 	// identify the session.
 	//
 	// required: true
-	Challenge string `json:"challenge" db:"challenge"`
+	ID string `json:"challenge" db:"challenge"`
 
 	// RequestedScope contains the OAuth 2.0 Scope requested by the OAuth 2.0 Client.
 	//
@@ -465,7 +495,7 @@ type LoginRequest struct {
 	// Client is the OAuth 2.0 Client that initiated the request.
 	//
 	// required: true
-	Client *client.Client `json:"client"`
+	Client *client.Client `json:"client" belongs_to:"hydra_client" fk_id:"ClientID"`
 
 	ClientID string `json:"-" db:"client_id"`
 
@@ -488,27 +518,29 @@ type LoginRequest struct {
 
 	AuthenticatedAt sqlxx.NullTime `json:"-" db:"authenticated_at"`
 	RequestedAt     time.Time      `json:"-" db:"requested_at"`
-	WasHandled      bool           `json:"-" db:"was_handled"`
-	Context         string         `json:"-" db:"context"`
+	WasHandled      bool           `json:"-" db:"was_handled,r"`
 }
 
-func (r *LoginRequest) prepareSQL() *LoginRequest {
-	if r.Client == nil {
-		return r
-	}
-	r.ClientID = r.Client.ID
-	return r
+func (_ LoginRequest) TableName() string {
+	return "hydra_oauth2_authentication_request"
+}
+
+func (r *LoginRequest) FindInDB(c *pop.Connection, id string) error {
+	return c.Select("hydra_oauth2_authentication_request.*", "COALESCE(hr.was_used, FALSE) as was_handled").
+		LeftJoin("hydra_oauth2_authentication_request_handled as hr", "hydra_oauth2_authentication_request.challenge = hr.challenge").
+		Eager().
+		Find(r, id)
 }
 
 // Contains information on an ongoing consent request.
 //
 // swagger:model consentRequest
 type ConsentRequest struct {
-	// Challenge is the identifier ("authorization challenge") of the consent authorization request. It is used to
+	// ID is the identifier ("authorization challenge") of the consent authorization request. It is used to
 	// identify the session.
 	//
 	// required: true
-	Challenge string `json:"challenge" db:"challenge"`
+	ID string `json:"challenge" db:"challenge"`
 
 	// RequestedScope contains the OAuth 2.0 Scope requested by the OAuth 2.0 Client.
 	RequestedScope sqlxx.StringSlicePipeDelimiter `json:"requested_scope" db:"requested_scope"`
@@ -530,7 +562,7 @@ type ConsentRequest struct {
 	OpenIDConnectContext *OpenIDConnectContext `json:"oidc_context" db:"oidc_context"`
 
 	// Client is the OAuth 2.0 Client that initiated the request.
-	Client   *client.Client `json:"client" db:"-"`
+	Client   *client.Client `json:"client" belongs_to:"hydra_client" fk_id:"ClientID"`
 	ClientID string         `json:"-" db:"client_id"`
 
 	// RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which
@@ -562,15 +594,19 @@ type ConsentRequest struct {
 	CSRF                   string         `json:"-" db:"csrf"`
 	AuthenticatedAt        sqlxx.NullTime `json:"-" db:"authenticated_at"`
 	RequestedAt            time.Time      `json:"-" db:"requested_at"`
-	WasHandled             bool           `json:"-" db:"was_handled"`
+	WasHandled             bool           `json:"-" db:"was_handled,r"`
 }
 
-func (r *ConsentRequest) prepareSQL() *ConsentRequest {
-	if r.Client == nil {
-		return r
-	}
-	r.ClientID = r.Client.ID
-	return r
+func (_ ConsentRequest) TableName() string {
+	return "hydra_oauth2_consent_request"
+}
+
+func (r *ConsentRequest) FindInDB(c *pop.Connection, id string) error {
+	return c.Select("COALESCE(hr.was_used, false) as was_handled", "hydra_oauth2_consent_request.*").
+		Where("hydra_oauth2_consent_request.challenge = ?", id).
+		LeftJoin("hydra_oauth2_consent_request_handled AS hr", "hr.challenge = hydra_oauth2_consent_request.challenge").
+		Eager().
+		First(r)
 }
 
 // Used to pass session data to a consent request.
diff --git a/driver/configuration/provider_viper.go b/driver/configuration/provider_viper.go
index 1283c49ac..428e37fae 100644
--- a/driver/configuration/provider_viper.go
+++ b/driver/configuration/provider_viper.go
@@ -84,6 +84,10 @@ const (
 	ViperKeyCGroupsV1AutoMaxProcsEnabled   = "cgroups.v1.auto_max_procs_enabled"
 )
 
+const DefaultSQLiteMemoryDSN = "sqlite://:memory:?_fk=true"
+
+const DSNMemory = "memory"
+
 func init() {
 	viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
 	viper.AutomaticEnv()
@@ -187,7 +191,18 @@ func (v *ViperProvider) CORSOptions(iface string) cors.Options {
 }
 
 func (v *ViperProvider) DSN() string {
-	return viperx.GetString(v.l, ViperKeyDSN, "", "DATABASE_URL")
+	dsn := viperx.GetString(v.l, ViperKeyDSN, "", "DATABASE_URL")
+
+	if dsn == DSNMemory {
+		return DefaultSQLiteMemoryDSN
+	}
+
+	if len(dsn) > 0 {
+		return dsn
+	}
+
+	v.l.Fatal("dsn must be set")
+	return ""
 }
 
 func (v *ViperProvider) EncryptSessionData() bool {
diff --git a/driver/configuration/provider_viper_test.go b/driver/configuration/provider_viper_test.go
index 55607ed0e..508ea0419 100644
--- a/driver/configuration/provider_viper_test.go
+++ b/driver/configuration/provider_viper_test.go
@@ -207,7 +207,7 @@ func TestViperProviderValidates(t *testing.T) {
 	assert.Equal(t, true, c.CookieSameSiteLegacyWorkaround())
 
 	// dsn
-	assert.Equal(t, "memory", c.DSN())
+	assert.Equal(t, DefaultSQLiteMemoryDSN, c.DSN())
 
 	// webfinger
 	assert.Equal(t, []string{"hydra.openid.id-token"}, c.WellKnownKeys())
diff --git a/driver/cors_test.go b/driver/cors_test.go
index 945541e47..65123a192 100644
--- a/driver/cors_test.go
+++ b/driver/cors_test.go
@@ -44,7 +44,7 @@ import (
 
 func TestOAuth2AwareCORSMiddleware(t *testing.T) {
 	c := internal.NewConfigurationWithDefaults()
-	r := internal.NewRegistryMemory(c)
+	r := internal.NewRegistryMemory(t, c)
 
 	token, signature, _ := r.OAuth2HMACStrategy().GenerateAccessToken(nil, nil)
 	for k, tc := range []struct {
@@ -156,10 +156,10 @@ func TestOAuth2AwareCORSMiddleware(t *testing.T) {
 				ar := fosite.NewAccessRequest(sess)
 				cl := &client.Client{ID: "foo-9", Secret: "bar", AllowedCORSOrigins: []string{"http://foobar.com"}}
 				ar.Client = cl
-				if err := r.OAuth2Storage().CreateAccessTokenSession(nil, signature, ar); err != nil {
+				if err := r.ClientManager().CreateClient(context.Background(), cl); err != nil {
 					panic(err)
 				}
-				if err := r.ClientManager().CreateClient(context.Background(), cl); err != nil {
+				if err := r.OAuth2Storage().CreateAccessTokenSession(context.Background(), signature, ar); err != nil {
 					panic(err)
 				}
 			},
diff --git a/driver/driver_default.go b/driver/driver_default.go
index bc7ca2cc3..ea71e2daa 100644
--- a/driver/driver_default.go
+++ b/driver/driver_default.go
@@ -17,14 +17,13 @@ func NewDefaultDriver(l *logrusx.Logger, forcedHTTP bool, insecureRedirects []st
 		configuration.MustValidate(l, c)
 	}
 
-	r, err := NewRegistry(c)
+	r, err := NewRegistry(c, l)
 	if err != nil {
 		l.WithError(err).Fatal("Unable to instantiate service registry.")
 	}
 
 	r.
 		WithConfig(c).
-		WithLogger(l).
 		WithBuildInfo(version, build, date)
 
 	if err = r.Init(); err != nil {
diff --git a/driver/registry.go b/driver/registry.go
index a037e2b6b..0ced525c5 100644
--- a/driver/registry.go
+++ b/driver/registry.go
@@ -3,6 +3,9 @@ package driver
 import (
 	"github.com/pkg/errors"
 
+	"github.com/ory/fosite"
+	foauth2 "github.com/ory/fosite/handler/oauth2"
+
 	"github.com/ory/x/logrusx"
 
 	"github.com/ory/hydra/persistence"
@@ -31,6 +34,8 @@ type Registry interface {
 	WithConfig(c configuration.Provider) Registry
 	WithLogger(l *logrusx.Logger) Registry
 
+	Config() configuration.Provider
+
 	WithBuildInfo(version, hash, date string) Registry
 	BuildVersion() string
 	BuildDate() string
@@ -53,15 +58,19 @@ type Registry interface {
 	ConsentHandler() *consent.Handler
 	OAuth2Handler() *oauth2.Handler
 	HealthHandler() *healthx.Handler
+
+	OAuth2HMACStrategy() *foauth2.HMACSHAStrategy
+	WithOAuth2Provider(f fosite.OAuth2Provider)
+	WithConsentStrategy(c consent.Strategy)
 }
 
-func MustNewRegistry(c configuration.Provider) Registry {
-	r, err := NewRegistry(c)
+func MustNewRegistry(c configuration.Provider, l *logrusx.Logger) Registry {
+	r, err := NewRegistry(c, l)
 	cmdx.Must(err, "unable to initialize services: %s", err)
 	return r
 }
 
-func NewRegistry(c configuration.Provider) (Registry, error) {
+func NewRegistry(c configuration.Provider, l *logrusx.Logger) (Registry, error) {
 	driver, err := dbal.GetDriverFor(c.DSN())
 	if err != nil {
 		return nil, errors.WithStack(err)
@@ -72,7 +81,7 @@ func NewRegistry(c configuration.Provider) (Registry, error) {
 		return nil, errors.Errorf("driver of type %T does not implement interface Registry", driver)
 	}
 
-	registry = registry.WithConfig(c)
+	registry = registry.WithLogger(l).WithConfig(c)
 
 	if err := registry.Init(); err != nil {
 		return nil, err
diff --git a/driver/registry_base.go b/driver/registry_base.go
index cbc33ba7a..d62d42fea 100644
--- a/driver/registry_base.go
+++ b/driver/registry_base.go
@@ -39,21 +39,17 @@ type RegistryBase struct {
 	l            *logrusx.Logger
 	al           *logrusx.Logger
 	C            configuration.Provider
-	cm           client.Manager
 	ch           *client.Handler
 	fh           fosite.Hasher
 	kh           *jwk.Handler
 	cv           *client.Validator
 	hh           *healthx.Handler
 	kg           map[string]jwk.KeyGenerator
-	km           jwk.Manager
 	kc           *jwk.AEAD
 	cs           sessions.Store
 	csPrev       [][]byte
-	com          consent.Manager
 	cos          consent.Strategy
 	writer       herodot.Writer
-	fs           x.FositeStorer
 	fsc          fosite.ScopeStrategy
 	atjs         jwk.JWTStrategy
 	idtjs        jwk.JWTStrategy
@@ -425,3 +421,17 @@ func (m *RegistryBase) PrometheusManager() *prometheus.MetricsManager {
 func (m *RegistryBase) Persister() persistence.Persister {
 	return m.persister
 }
+
+func (m *RegistryBase) Config() configuration.Provider {
+	return m.C
+}
+
+// WithOAuth2Provider forces an oauth2 provider which is only used for testing.
+func (m *RegistryBase) WithOAuth2Provider(f fosite.OAuth2Provider) {
+	m.fop = f
+}
+
+// WithConsentStrategy forces a consent strategy which is only used for testing.
+func (m *RegistryBase) WithConsentStrategy(c consent.Strategy) {
+	m.cos = c
+}
diff --git a/driver/registry_memory.go b/driver/registry_memory.go
deleted file mode 100644
index b3d42cfc9..000000000
--- a/driver/registry_memory.go
+++ /dev/null
@@ -1,86 +0,0 @@
-package driver
-
-import (
-	"github.com/ory/fosite"
-	"github.com/ory/hydra/oauth2"
-	"github.com/ory/hydra/persistence/memory"
-	"github.com/ory/hydra/x"
-
-	"github.com/ory/hydra/client"
-	"github.com/ory/hydra/consent"
-	"github.com/ory/hydra/jwk"
-	"github.com/ory/x/dbal"
-)
-
-type RegistryMemory struct {
-	*RegistryBase
-}
-
-var _ Registry = new(RegistryMemory)
-
-func init() {
-	dbal.RegisterDriver(func() dbal.Driver {
-		return NewRegistryMemory()
-	})
-}
-
-func NewRegistryMemory() *RegistryMemory {
-	r := &RegistryMemory{
-		RegistryBase: new(RegistryBase),
-	}
-	r.RegistryBase.with(r)
-	return r
-}
-
-// WithOAuth2Provider forces an oauth2 provider which is only used for testing.
-func (m *RegistryMemory) WithOAuth2Provider(f fosite.OAuth2Provider) *RegistryMemory {
-	m.RegistryBase.fop = f
-	return m
-}
-
-// WithConsentStrategy forces a consent strategy which is only used for testing.
-func (m *RegistryMemory) WithConsentStrategy(c consent.Strategy) *RegistryMemory {
-	m.RegistryBase.cos = c
-	return m
-}
-
-func (m *RegistryMemory) Init() error {
-	m.persister = &memory.Persister{}
-	return nil
-}
-
-func (m *RegistryMemory) CanHandle(dsn string) bool {
-	return dsn == "memory"
-}
-
-func (m *RegistryMemory) Ping() error {
-	return nil
-}
-
-func (m *RegistryMemory) ClientManager() client.Manager {
-	if m.cm == nil {
-		m.cm = client.NewMemoryManager(m)
-	}
-	return m.cm
-}
-
-func (m *RegistryMemory) ConsentManager() consent.Manager {
-	if m.com == nil {
-		m.com = consent.NewMemoryManager(m)
-	}
-	return m.com
-}
-
-func (m *RegistryMemory) OAuth2Storage() x.FositeStorer {
-	if m.fs == nil {
-		m.fs = oauth2.NewFositeMemoryStore(m.r, m.C)
-	}
-	return m.fs
-}
-
-func (m *RegistryMemory) KeyManager() jwk.Manager {
-	if m.km == nil {
-		m.km = jwk.NewMemoryManager()
-	}
-	return m.km
-}
diff --git a/driver/registry_noplugin.go b/driver/registry_noplugin.go
deleted file mode 100644
index 50a6e3f55..000000000
--- a/driver/registry_noplugin.go
+++ /dev/null
@@ -1,64 +0,0 @@
-// +build noplugin
-
-package driver
-
-import (
-	"github.com/jmoiron/sqlx"
-
-	"github.com/ory/hydra/client"
-	"github.com/ory/hydra/consent"
-	"github.com/ory/hydra/jwk"
-	"github.com/ory/hydra/x"
-	"github.com/ory/x/dbal"
-	"github.com/ory/x/sqlcon"
-	"github.com/ory/x/urlx"
-)
-
-type RegistryNoPlugin struct {
-	*RegistryBase
-	db          *sqlx.DB
-	dbalOptions []sqlcon.OptionModifier
-}
-
-var _ Registry = new(RegistryNoPlugin)
-
-func init() {
-	dbal.RegisterDriver(NewRegistryNoPlugin())
-}
-
-func NewRegistryNoPlugin() *RegistryNoPlugin {
-	r := &RegistryNoPlugin{
-		RegistryBase: new(RegistryBase),
-	}
-	r.RegistryBase.with(r)
-	return r
-}
-
-func (m *RegistryNoPlugin) Init() error {
-	panic("Unable to load plugin connection because 'noplugin' tag was declared")
-}
-
-func (m *RegistryNoPlugin) CanHandle(dsn string) bool {
-	u := urlx.ParseOrFatal(m.Logger(), dsn)
-	return u.Scheme == "plugin"
-}
-
-func (m *RegistryNoPlugin) Ping() error {
-	panic("Unable to load plugin connection because 'noplugin' tag was declared")
-}
-
-func (m *RegistryNoPlugin) ClientManager() client.Manager {
-	panic("Unable to load plugin connection because 'noplugin' tag was declared")
-}
-
-func (m *RegistryNoPlugin) ConsentManager() consent.Manager {
-	panic("Unable to load plugin connection because 'noplugin' tag was declared")
-}
-
-func (m *RegistryNoPlugin) OAuth2Storage() x.FositeStorer {
-	panic("Unable to load plugin connection because 'noplugin' tag was declared")
-}
-
-func (m *RegistryNoPlugin) KeyManager() jwk.Manager {
-	panic("Unable to load plugin connection because 'noplugin' tag was declared")
-}
diff --git a/driver/registry_nosqlite.go b/driver/registry_nosqlite.go
new file mode 100644
index 000000000..729e1eafc
--- /dev/null
+++ b/driver/registry_nosqlite.go
@@ -0,0 +1,7 @@
+// +build !sqlite
+
+package driver
+
+func (m *RegistrySQL) CanHandle(dsn string) bool {
+	return m.alwaysCanHandle(dsn)
+}
diff --git a/driver/registry_plugin.go b/driver/registry_plugin.go
deleted file mode 100644
index 2330acd74..000000000
--- a/driver/registry_plugin.go
+++ /dev/null
@@ -1,73 +0,0 @@
-// +build !noplugin
-
-package driver
-
-import (
-	"net/url"
-	"plugin"
-	"strings"
-
-	"github.com/pkg/errors"
-
-	"github.com/ory/hydra/driver/configuration"
-	"github.com/ory/x/dbal"
-)
-
-type RegistryPlugin struct {
-	c configuration.Provider
-	Registry
-}
-
-var _ Registry = new(RegistryPlugin)
-
-func init() {
-	dbal.RegisterDriver(func() dbal.Driver {
-		return NewRegistryPlugin()
-	})
-}
-
-func NewRegistryPlugin() *RegistryPlugin {
-	return new(RegistryPlugin)
-}
-
-func (m *RegistryPlugin) CanHandle(dsn string) bool {
-	u, err := url.Parse(dsn)
-	if err != nil {
-		return false
-	}
-	return u.Scheme == "plugin"
-}
-
-func (m *RegistryPlugin) WithConfig(c configuration.Provider) Registry {
-	m.c = c
-	return m
-}
-
-func (m *RegistryPlugin) Init() error {
-	if m.Registry != nil {
-		return nil
-	}
-
-	path := strings.Replace(m.c.DSN(), "plugin://", "", 1)
-	p, err := plugin.Open(path)
-	if err != nil {
-		return errors.Wrapf(err, "unable to open plugin path: %s", path)
-	}
-
-	l, err := p.Lookup("NewRegistry")
-	if err != nil {
-		return errors.Wrap(err, "unable to look up `Registry`")
-	}
-
-	reg, ok := l.(func() Registry)
-	if !ok {
-		return errors.Errorf("unable to type assert %T to `func() driver.Registry`", l)
-	}
-
-	m.Registry = reg()
-	m.Logger().Info("Successfully loaded database plugin")
-	m.Logger().Debugf("Memory address of database plugin is: %p", reg)
-	m.Registry.WithConfig(m.c)
-
-	return nil
-}
diff --git a/driver/registry_sql.go b/driver/registry_sql.go
index 81899d5d8..b1c9f34ec 100644
--- a/driver/registry_sql.go
+++ b/driver/registry_sql.go
@@ -1,14 +1,19 @@
 package driver
 
 import (
+	"context"
 	"strings"
 	"time"
 
+	"github.com/ory/hydra/driver/configuration"
+
 	"github.com/ory/x/resilience"
 
 	"github.com/gobuffalo/pop/v5"
 	"github.com/pkg/errors"
 
+	_ "github.com/jackc/pgx/v4/stdlib"
+
 	"github.com/ory/hydra/persistence/sql"
 
 	"github.com/jmoiron/sqlx"
@@ -19,7 +24,6 @@ import (
 	"github.com/ory/hydra/client"
 	"github.com/ory/hydra/consent"
 	"github.com/ory/hydra/jwk"
-	"github.com/ory/hydra/oauth2"
 	"github.com/ory/hydra/x"
 )
 
@@ -51,24 +55,6 @@ func (m *RegistrySQL) WithDB(db *sqlx.DB) Registry {
 }
 
 func (m *RegistrySQL) Init() error {
-	if m.db == nil {
-		// old db connection
-		options := append([]sqlcon.OptionModifier{}, m.dbalOptions...)
-		if m.Tracer().IsLoaded() {
-			options = append(options, sqlcon.WithDistributedTracing(), sqlcon.WithOmitArgsFromTraceSpans())
-		}
-
-		connection, err := sqlcon.NewSQLConnection(m.C.DSN(), m.Logger(), options...)
-		if err != nil {
-			return err
-		}
-
-		m.db, err = connection.GetDatabaseRetry(time.Second*5, time.Minute*5)
-		if err != nil {
-			return err
-		}
-	}
-
 	if m.persister == nil {
 		// new db connection
 		pool, idlePool, connMaxLifetime, cleanedDSN := sqlcon.ParseConnectionOptions(m.l, m.C.DSN())
@@ -84,10 +70,19 @@ func (m *RegistrySQL) Init() error {
 		if err := resilience.Retry(m.l, 5*time.Second, 5*time.Minute, c.Open); err != nil {
 			return errors.WithStack(err)
 		}
-		m.persister, err = sql.NewPersister(c)
+		m.persister, err = sql.NewPersister(c, m, m.C, m.l)
 		if err != nil {
 			return err
 		}
+
+		// if dsn is memory we have to run the migrations on every start
+		if m.C.DSN() == configuration.DefaultSQLiteMemoryDSN {
+			m.Logger().Print("Hydra is running migrations on every startup as DSN is memory.\n")
+			m.Logger().Print("This means your data is lost when Hydra terminates.\n")
+			if err := m.persister.MigrateUp(context.Background()); err != nil {
+				return err
+			}
+		}
 	}
 
 	return nil
@@ -103,40 +98,28 @@ func (m *RegistrySQL) DB() *sqlx.DB {
 	return m.db
 }
 
-func (m *RegistrySQL) CanHandle(dsn string) bool {
+func (m *RegistrySQL) alwaysCanHandle(dsn string) bool {
 	scheme := strings.Split(dsn, "://")[0]
 	s := dbal.Canonicalize(scheme)
 	return s == dbal.DriverMySQL || s == dbal.DriverPostgreSQL || s == dbal.DriverCockroachDB
 }
 
 func (m *RegistrySQL) Ping() error {
-	return m.DB().Ping()
+	return m.Persister().Connection(context.Background()).Open()
 }
 
 func (m *RegistrySQL) ClientManager() client.Manager {
-	if m.cm == nil {
-		m.cm = client.NewSQLManager(m.DB(), m)
-	}
-	return m.cm
+	return m.Persister()
 }
 
 func (m *RegistrySQL) ConsentManager() consent.Manager {
-	if m.com == nil {
-		m.com = consent.NewSQLManager(m.DB(), m)
-	}
-	return m.com
+	return m.Persister()
 }
 
 func (m *RegistrySQL) OAuth2Storage() x.FositeStorer {
-	if m.fs == nil {
-		m.fs = oauth2.NewFositeSQLStore(m.DB(), m.r, m.C, m.KeyCipher())
-	}
-	return m.fs
+	return m.Persister()
 }
 
 func (m *RegistrySQL) KeyManager() jwk.Manager {
-	if m.km == nil {
-		m.km = jwk.NewSQLManager(m.DB(), m)
-	}
-	return m.km
+	return m.Persister()
 }
diff --git a/driver/registry_sqlite.go b/driver/registry_sqlite.go
new file mode 100644
index 000000000..c3cff4903
--- /dev/null
+++ b/driver/registry_sqlite.go
@@ -0,0 +1,12 @@
+// +build sqlite
+
+package driver
+
+import (
+	"strings"
+)
+
+func (m *RegistrySQL) CanHandle(dsn string) bool {
+	scheme := strings.Split(dsn, "://")[0]
+	return scheme == "sqlite" || scheme == "sqlite3" || m.alwaysCanHandle(dsn)
+}
diff --git a/go.mod b/go.mod
index 0d1eddb42..c3cf543b0 100644
--- a/go.mod
+++ b/go.mod
@@ -15,6 +15,7 @@ require (
 	github.com/gobuffalo/packr v1.24.0 // indirect
 	github.com/gobuffalo/packr/v2 v2.7.1
 	github.com/gobuffalo/pop/v5 v5.2.4
+	github.com/gobuffalo/x v0.0.0-20181007152206-913e47c59ca7
 	github.com/gobwas/glob v0.2.3
 	github.com/golang/mock v1.4.3
 	github.com/google/uuid v1.1.1
@@ -48,7 +49,7 @@ require (
 	github.com/spf13/cobra v1.0.0
 	github.com/spf13/viper v1.7.0 // indirect
 	github.com/sqs/goreturns v0.0.0-20181028201513-538ac6014518
-	github.com/stretchr/testify v1.5.1
+	github.com/stretchr/testify v1.6.1
 	github.com/tidwall/gjson v1.6.0
 	github.com/tidwall/pretty v1.0.1 // indirect
 	github.com/toqueteos/webbrowser v1.2.0
@@ -60,3 +61,5 @@ require (
 	golang.org/x/tools v0.0.0-20200721223218-6123e77877b2
 	gopkg.in/square/go-jose.v2 v2.5.1
 )
+
+replace github.com/gobuffalo/pop/v5 => github.com/gobuffalo/pop/v5 v5.1.1-0.20200924193619-5ce72a770b26
diff --git a/go.sum b/go.sum
index 1c90d3e67..e8acfc0a0 100644
--- a/go.sum
+++ b/go.sum
@@ -477,6 +477,8 @@ github.com/gobuffalo/pop v4.8.4+incompatible/go.mod h1:DwBz3SD5SsHpTZiTubcsFWcVD
 github.com/gobuffalo/pop v4.13.1+incompatible h1:AhbqPxNOBN/DBb2DBaiBqzOXIBQXxEYzngHHJ+ytP4g=
 github.com/gobuffalo/pop v4.13.1+incompatible/go.mod h1:DwBz3SD5SsHpTZiTubcsFWcVDpJWGsxjVjMPnkiThWg=
 github.com/gobuffalo/pop/v5 v5.0.11/go.mod h1:mZJHJbA3cy2V18abXYuVop2ldEJ8UZ2DK6qOekC5u5g=
+github.com/gobuffalo/pop/v5 v5.1.1-0.20200924193619-5ce72a770b26 h1:FBUIrU6P15Eqhz8TG5fVMg3OcOo9XY8AxVkHVcByty0=
+github.com/gobuffalo/pop/v5 v5.1.1-0.20200924193619-5ce72a770b26/go.mod h1:fzUpBhQE48+kPczDbuJIuOCSS7OMqChoaGR6wj2j7Nc=
 github.com/gobuffalo/pop/v5 v5.2.0 h1:b5WDmlv5ZnOj0ZQ6SShBpwrolPCdbOXHM+SzRE//Nzs=
 github.com/gobuffalo/pop/v5 v5.2.0/go.mod h1:Hj586Cr7FoTFNmvzyNdUcajv3r0A+W+bkil4RIX/zKo=
 github.com/gobuffalo/pop/v5 v5.2.4 h1:mvAjx8k1oYXWBTNFbvlxFBNEfoXTnEnVBcCmvQ48Lnw=
@@ -522,6 +524,7 @@ github.com/gobuffalo/validate/v3 v3.1.0/go.mod h1:HFpjq+AIiA2RHoQnQVTFKF/ZpUPXwy
 github.com/gobuffalo/validate/v3 v3.2.0 h1:Zrpkz2kuZ4rGXLaO3IHVlwX512/cUWRvNjw46Cjhz2Q=
 github.com/gobuffalo/validate/v3 v3.2.0/go.mod h1:PrhDOdDHxtN8KUgMvF3TDL0r1YZXV4sQnyFX/EmeETY=
 github.com/gobuffalo/x v0.0.0-20181003152136-452098b06085/go.mod h1:WevpGD+5YOreDJznWevcn8NTmQEW5STSBgIkpkjzqXc=
+github.com/gobuffalo/x v0.0.0-20181007152206-913e47c59ca7 h1:N0iqtKwkicU8M2rLirTDJxdwuL8I2/8MjMlEayaNSgE=
 github.com/gobuffalo/x v0.0.0-20181007152206-913e47c59ca7/go.mod h1:9rDPXaB3kXdKWzMc4odGQQdG2e2DIEmANy5aSJ9yesY=
 github.com/gobwas/glob v0.2.3 h1:A4xDbljILXROh+kObIiy5kIaPYD8e96x1tgBhUI5J+Y=
 github.com/gobwas/glob v0.2.3/go.mod h1:d3Ez4x06l9bZtSvzIay5+Yzi0fmZzPgnTbPcKjJAkT8=
@@ -1104,6 +1107,8 @@ github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UV
 github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
 github.com/stretchr/testify v1.5.1 h1:nOGnQDM7FYENwehXlg/kFVnos3rEvtKTjRvOWSzb6H4=
 github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
+github.com/stretchr/testify v1.6.1 h1:hDPOHmpOpP40lSULcqw7IrRb/u7w6RpDC9399XyoNd0=
+github.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
 github.com/subosito/gotenv v1.1.1/go.mod h1:N0PQaV/YGNqwC0u51sEeR/aUtSLEXKX9iv69rRypqCw=
 github.com/subosito/gotenv v1.2.0 h1:Slr1R9HxAlEKefgq5jn9U+DnETlIUa6HfgEzj0g5d7s=
 github.com/subosito/gotenv v1.2.0/go.mod h1:N0PQaV/YGNqwC0u51sEeR/aUtSLEXKX9iv69rRypqCw=
@@ -1534,6 +1539,8 @@ gopkg.in/yaml.v2 v2.2.8 h1:obN1ZagJSUGI0Ek/LBmuj4SNLPfIny3KsKFopxRdj10=
 gopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
 gopkg.in/yaml.v2 v2.3.0 h1:clyUAQHOM3G0M3f5vQj7LuJrETvjVot3Z5el9nffUtU=
 gopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
+gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=
+gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
 gotest.tools v2.2.0+incompatible h1:VsBPFP1AI068pPrMxtb/S8Zkgf9xEmTLJjfM+P5UIEo=
 gotest.tools v2.2.0+incompatible/go.mod h1:DsYFclhRJ6vuDpmuTbkuFWG+y2sxOXAzmJt81HFBacw=
 honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
diff --git a/internal/driver.go b/internal/driver.go
index 33d1dc934..d65ac1382 100644
--- a/internal/driver.go
+++ b/internal/driver.go
@@ -72,11 +72,8 @@ func NewConfigurationWithDefaultsAndHTTPS() *configuration.ViperProvider {
 	return configuration.NewViperProvider(logrusx.New("", ""), false, nil).(*configuration.ViperProvider)
 }
 
-func NewRegistryMemory(c *configuration.ViperProvider) *driver.RegistryMemory {
-	viper.Set(configuration.ViperKeyLogLevel, "debug")
-	r := driver.NewRegistryMemory().WithConfig(c)
-	_ = r.Init()
-	return r.(*driver.RegistryMemory)
+func NewRegistryMemory(t *testing.T, c *configuration.ViperProvider) driver.Registry {
+	return newRegistryDefault(t, "memory", c)
 }
 
 func NewRegistrySQLFromDB(c *configuration.ViperProvider, db *sqlx.DB) *driver.RegistrySQL {
@@ -86,20 +83,22 @@ func NewRegistrySQLFromDB(c *configuration.ViperProvider, db *sqlx.DB) *driver.R
 	return r.(*driver.RegistrySQL)
 }
 
-func NewRegistrySQLFromURL(t *testing.T, url string) *driver.RegistrySQL {
-	conf := NewConfigurationWithDefaults()
+func NewRegistrySQLFromURL(t *testing.T, url string) driver.Registry {
+	return newRegistryDefault(t, url, NewConfigurationWithDefaults())
+}
+
+func newRegistryDefault(t *testing.T, url string, c configuration.Provider) driver.Registry {
+	viper.Set(configuration.ViperKeyLogLevel, "debug")
 	viper.Set(configuration.ViperKeyDSN, url)
-	reg, err := driver.NewRegistry(conf)
+	r, err := driver.NewRegistry(c, logrusx.New("test_hydra", "master"))
 	require.NoError(t, err)
-	r, ok := reg.(*driver.RegistrySQL)
-	require.True(t, ok)
 	require.NoError(t, r.Init())
 	return r
 }
 
-func CleanAndMigrate(reg *driver.RegistrySQL) func(*testing.T) {
+func CleanAndMigrate(reg driver.Registry) func(*testing.T) {
 	return func(t *testing.T) {
-		x.CleanSQL(t, reg.DB())
+		x.CleanSQLPop(t, reg.Persister().Connection(context.Background()))
 		require.NoError(t, reg.Persister().MigrateUp(context.Background()))
 		t.Log("clean and migrate done")
 	}
@@ -131,7 +130,7 @@ func ConnectToCRDB(t *testing.T) string {
 	return url
 }
 
-func ConnectDatabases(t *testing.T) (pg, mysql, crdb *driver.RegistrySQL, clean func(*testing.T)) {
+func ConnectDatabases(t *testing.T) (pg, mysql, crdb driver.Registry, clean func(*testing.T)) {
 	var pgURL, mysqlURL, crdbURL string
 	wg := sync.WaitGroup{}
 
@@ -148,7 +147,7 @@ func ConnectDatabases(t *testing.T) (pg, mysql, crdb *driver.RegistrySQL, clean
 	}()
 	go func() {
 		crdbURL = ConnectToCRDB(t)
-		t.Log("cddb done")
+		t.Log("crdb done")
 		wg.Done()
 	}()
 	t.Log("beginning to wait")
@@ -158,14 +157,14 @@ func ConnectDatabases(t *testing.T) (pg, mysql, crdb *driver.RegistrySQL, clean
 	pg = NewRegistrySQLFromURL(t, pgURL)
 	mysql = NewRegistrySQLFromURL(t, mysqlURL)
 	crdb = NewRegistrySQLFromURL(t, crdbURL)
-	dbs := []*driver.RegistrySQL{pg, mysql, crdb}
+	dbs := []driver.Registry{pg, mysql, crdb}
 
 	clean = func(t *testing.T) {
 		wg := sync.WaitGroup{}
 
 		wg.Add(len(dbs))
 		for _, db := range dbs {
-			go func(db *driver.RegistrySQL) {
+			go func(db driver.Registry) {
 				defer wg.Done()
 				CleanAndMigrate(db)(t)
 			}(db)
diff --git a/internal/fizzmigrate/empty.go b/internal/fizzmigrate/empty.go
new file mode 100644
index 000000000..04885c008
--- /dev/null
+++ b/internal/fizzmigrate/empty.go
@@ -0,0 +1,4 @@
+package fizzmigrate
+
+// this file exists to have some buildable go sources in this package
+// required for e.g. `make format`
diff --git a/internal/httpclient/models/consent_request.go b/internal/httpclient/models/consent_request.go
index 9961b19df..644980261 100644
--- a/internal/httpclient/models/consent_request.go
+++ b/internal/httpclient/models/consent_request.go
@@ -21,7 +21,7 @@ type ConsentRequest struct {
 	// to express that, for example, a user authenticated using two factor authentication.
 	Acr string `json:"acr,omitempty"`
 
-	// Challenge is the identifier ("authorization challenge") of the consent authorization request. It is used to
+	// ID is the identifier ("authorization challenge") of the consent authorization request. It is used to
 	// identify the session.
 	// Required: true
 	Challenge *string `json:"challenge"`
diff --git a/internal/httpclient/models/login_request.go b/internal/httpclient/models/login_request.go
index f6856e015..4cf1b2d99 100644
--- a/internal/httpclient/models/login_request.go
+++ b/internal/httpclient/models/login_request.go
@@ -17,7 +17,7 @@ import (
 // swagger:model loginRequest
 type LoginRequest struct {
 
-	// Challenge is the identifier ("login challenge") of the login request. It is used to
+	// ID is the identifier ("login challenge") of the login request. It is used to
 	// identify the session.
 	// Required: true
 	Challenge *string `json:"challenge"`
diff --git a/jwk/generator_rs256.go b/jwk/generator_rs256.go
index 12583039f..5473ac554 100644
--- a/jwk/generator_rs256.go
+++ b/jwk/generator_rs256.go
@@ -55,18 +55,22 @@ func (g *RS256Generator) Generate(id, use string) (*jose.JSONWebKeySet, error) {
 	return &jose.JSONWebKeySet{
 		Keys: []jose.JSONWebKey{
 			{
-				Algorithm:    "RS256",
-				Key:          key,
-				Use:          use,
-				KeyID:        Ider("private", id),
-				Certificates: []*x509.Certificate{},
+				Algorithm:                   "RS256",
+				Key:                         key,
+				Use:                         use,
+				KeyID:                       Ider("private", id),
+				Certificates:                []*x509.Certificate{},
+				CertificateThumbprintSHA1:   []uint8{},
+				CertificateThumbprintSHA256: []uint8{},
 			},
 			{
-				Algorithm:    "RS256",
-				Use:          use,
-				Key:          &key.PublicKey,
-				KeyID:        Ider("public", id),
-				Certificates: []*x509.Certificate{},
+				Algorithm:                   "RS256",
+				Use:                         use,
+				Key:                         &key.PublicKey,
+				KeyID:                       Ider("public", id),
+				Certificates:                []*x509.Certificate{},
+				CertificateThumbprintSHA1:   []uint8{},
+				CertificateThumbprintSHA256: []uint8{},
 			},
 		},
 	}, nil
diff --git a/jwk/handler_test.go b/jwk/handler_test.go
index 77a6c763f..5b8a16f6c 100644
--- a/jwk/handler_test.go
+++ b/jwk/handler_test.go
@@ -40,7 +40,7 @@ import (
 
 func TestHandlerWellKnown(t *testing.T) {
 	conf := internal.NewConfigurationWithDefaults()
-	reg := internal.NewRegistryMemory(conf)
+	reg := internal.NewRegistryMemory(t, conf)
 
 	viper.Set(configuration.ViperKeyWellKnownKeys, []string{x.OpenIDConnectKeyName, x.OpenIDConnectKeyName})
 
diff --git a/jwk/jwt_strategy_test.go b/jwk/jwt_strategy_test.go
index 99673f3d9..c52788edd 100644
--- a/jwk/jwt_strategy_test.go
+++ b/jwk/jwt_strategy_test.go
@@ -36,7 +36,7 @@ import (
 
 func TestRS256JWTStrategy(t *testing.T) {
 	conf := internal.NewConfigurationWithDefaults()
-	reg := internal.NewRegistryMemory(conf)
+	reg := internal.NewRegistryMemory(t, conf)
 
 	testGenerator := &RS256Generator{}
 
diff --git a/jwk/manager.go b/jwk/manager.go
index d00cfbbdb..e2fe33d57 100644
--- a/jwk/manager.go
+++ b/jwk/manager.go
@@ -22,22 +22,36 @@ package jwk
 
 import (
 	"context"
+	"time"
 
 	jose "gopkg.in/square/go-jose.v2"
 )
 
-var _, _ Manager = new(SQLManager), new(MemoryManager)
+type (
+	Manager interface {
+		AddKey(ctx context.Context, set string, key *jose.JSONWebKey) error
 
-type Manager interface {
-	AddKey(ctx context.Context, set string, key *jose.JSONWebKey) error
+		AddKeySet(ctx context.Context, set string, keys *jose.JSONWebKeySet) error
 
-	AddKeySet(ctx context.Context, set string, keys *jose.JSONWebKeySet) error
+		GetKey(ctx context.Context, set, kid string) (*jose.JSONWebKeySet, error)
 
-	GetKey(ctx context.Context, set, kid string) (*jose.JSONWebKeySet, error)
+		GetKeySet(ctx context.Context, set string) (*jose.JSONWebKeySet, error)
 
-	GetKeySet(ctx context.Context, set string) (*jose.JSONWebKeySet, error)
+		DeleteKey(ctx context.Context, set, kid string) error
 
-	DeleteKey(ctx context.Context, set, kid string) error
+		DeleteKeySet(ctx context.Context, set string) error
+	}
 
-	DeleteKeySet(ctx context.Context, set string) error
+	SQLData struct {
+		ID        int       `db:"pk"`
+		Set       string    `db:"sid"`
+		KID       string    `db:"kid"`
+		Version   int       `db:"version"`
+		CreatedAt time.Time `db:"created_at"`
+		Key       string    `db:"keydata"`
+	}
+)
+
+func (d SQLData) TableName() string {
+	return "hydra_jwk"
 }
diff --git a/jwk/manager_memory.go b/jwk/manager_memory.go
deleted file mode 100644
index dd89d0c4f..000000000
--- a/jwk/manager_memory.go
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @license 	Apache-2.0
- */
-
-package jwk
-
-import (
-	"context"
-	"fmt"
-	"net/http"
-	"sync"
-
-	"github.com/pkg/errors"
-	jose "gopkg.in/square/go-jose.v2"
-
-	"github.com/ory/fosite"
-	"github.com/ory/hydra/x"
-)
-
-type MemoryManager struct {
-	Keys map[string]*jose.JSONWebKeySet
-	sync.RWMutex
-}
-
-func NewMemoryManager() *MemoryManager {
-	return &MemoryManager{
-		Keys: map[string]*jose.JSONWebKeySet{},
-	}
-}
-
-func (m *MemoryManager) AddKey(ctx context.Context, set string, key *jose.JSONWebKey) error {
-	m.Lock()
-	defer m.Unlock()
-
-	m.alloc()
-	if m.Keys[set] == nil {
-		m.Keys[set] = &jose.JSONWebKeySet{Keys: []jose.JSONWebKey{}}
-	}
-
-	for _, k := range m.Keys[set].Keys {
-		if k.KeyID == key.KeyID {
-			return errors.WithStack(&fosite.RFC6749Error{
-				Code:        http.StatusConflict,
-				Name:        http.StatusText(http.StatusConflict),
-				Description: fmt.Sprintf("Unable to create key with kid \"%s\" in set \"%s\" because that kid already exists in the set.", key.KeyID, set),
-			})
-		}
-	}
-
-	m.Keys[set].Keys = append([]jose.JSONWebKey{*key}, m.Keys[set].Keys...)
-	return nil
-}
-
-func (m *MemoryManager) AddKeySet(ctx context.Context, set string, keys *jose.JSONWebKeySet) error {
-	for k := range keys.Keys {
-		key := keys.Keys[k]
-		if err := m.AddKey(ctx, set, &key); err != nil {
-			return err
-		}
-	}
-	return nil
-}
-
-func (m *MemoryManager) GetKey(ctx context.Context, set, kid string) (*jose.JSONWebKeySet, error) {
-	m.RLock()
-	defer m.RUnlock()
-
-	m.alloc()
-	keys, found := m.Keys[set]
-	if !found {
-		return nil, errors.WithStack(x.ErrNotFound)
-	}
-
-	result := keys.Key(kid)
-	if len(result) == 0 {
-		return nil, errors.WithStack(x.ErrNotFound)
-	}
-
-	return &jose.JSONWebKeySet{
-		Keys: result,
-	}, nil
-}
-
-func (m *MemoryManager) GetKeySet(ctx context.Context, set string) (*jose.JSONWebKeySet, error) {
-	m.RLock()
-	defer m.RUnlock()
-
-	m.alloc()
-	keys, found := m.Keys[set]
-	if !found {
-		return nil, errors.WithStack(x.ErrNotFound)
-	}
-
-	if len(keys.Keys) == 0 {
-		return nil, errors.WithStack(x.ErrNotFound)
-	}
-
-	return keys, nil
-}
-
-func (m *MemoryManager) DeleteKey(ctx context.Context, set, kid string) error {
-	keys, err := m.GetKeySet(ctx, set)
-	if err != nil {
-		return err
-	}
-
-	m.Lock()
-	var results []jose.JSONWebKey
-	for _, key := range keys.Keys {
-		if key.KeyID != kid {
-			results = append(results, key)
-		}
-	}
-	m.Keys[set].Keys = results
-	defer m.Unlock()
-
-	return nil
-}
-
-func (m *MemoryManager) DeleteKeySet(ctx context.Context, set string) error {
-	m.Lock()
-	defer m.Unlock()
-
-	delete(m.Keys, set)
-	return nil
-}
-
-func (m *MemoryManager) alloc() {
-	if m.Keys == nil {
-		m.Keys = make(map[string]*jose.JSONWebKeySet)
-	}
-}
diff --git a/jwk/manager_sql.go b/jwk/manager_sql.go
deleted file mode 100644
index 01e01dabb..000000000
--- a/jwk/manager_sql.go
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @license 	Apache-2.0
- */
-
-package jwk
-
-import (
-	"context"
-	"encoding/json"
-	"time"
-
-	"github.com/jmoiron/sqlx"
-	"github.com/pkg/errors"
-	jose "gopkg.in/square/go-jose.v2"
-
-	"github.com/ory/hydra/x"
-	"github.com/ory/x/sqlcon"
-)
-
-type SQLManager struct {
-	DB *sqlx.DB
-	R  InternalRegistry
-}
-
-func NewSQLManager(db *sqlx.DB, r InternalRegistry) *SQLManager {
-	return &SQLManager{DB: db, R: r}
-}
-
-type SQLData struct {
-	PK        int       `db:"pk"`
-	Set       string    `db:"sid"`
-	KID       string    `db:"kid"`
-	Version   int       `db:"version"`
-	CreatedAt time.Time `db:"created_at"`
-	Key       string    `db:"keydata"`
-}
-
-func (d SQLData) TableName() string {
-	return "hydra_jwk"
-}
-
-func (m *SQLManager) AddKey(ctx context.Context, set string, key *jose.JSONWebKey) error {
-	out, err := json.Marshal(key)
-	if err != nil {
-		return errors.WithStack(err)
-	}
-
-	encrypted, err := m.R.KeyCipher().Encrypt(out)
-	if err != nil {
-		return errors.WithStack(err)
-	}
-
-	if _, err = m.DB.NamedExecContext(ctx, `INSERT INTO hydra_jwk (sid, kid, version, keydata) VALUES (:sid, :kid, :version, :keydata)`, &SQLData{
-		Set:     set,
-		KID:     key.KeyID,
-		Version: 0,
-		Key:     encrypted,
-	}); err != nil {
-		return sqlcon.HandleError(err)
-	}
-	return nil
-}
-
-func (m *SQLManager) AddKeySet(ctx context.Context, set string, keys *jose.JSONWebKeySet) error {
-	tx, err := m.DB.BeginTxx(ctx, nil)
-	if err != nil {
-		return errors.WithStack(err)
-	}
-
-	if err := m.addKeySet(ctx, tx, m.R.KeyCipher(), set, keys); err != nil {
-		if re := tx.Rollback(); re != nil {
-			return errors.Wrap(err, re.Error())
-		}
-		return sqlcon.HandleError(err)
-	}
-
-	if err := tx.Commit(); err != nil {
-		if re := tx.Rollback(); re != nil {
-			return errors.Wrap(err, re.Error())
-		}
-		return sqlcon.HandleError(err)
-	}
-	return nil
-}
-
-func (m *SQLManager) addKeySet(ctx context.Context, tx *sqlx.Tx, cipher *AEAD, set string, keys *jose.JSONWebKeySet) error {
-	for _, key := range keys.Keys {
-		out, err := json.Marshal(key)
-		if err != nil {
-			return errors.WithStack(err)
-		}
-
-		encrypted, err := cipher.Encrypt(out)
-		if err != nil {
-			return errors.WithStack(err)
-		}
-
-		if _, err = tx.NamedExecContext(ctx, `INSERT INTO hydra_jwk (sid, kid, version, keydata) VALUES (:sid, :kid, :version, :keydata)`, &SQLData{
-			Set:     set,
-			KID:     key.KeyID,
-			Version: 0,
-			Key:     encrypted,
-		}); err != nil {
-			return sqlcon.HandleError(err)
-		}
-	}
-
-	return nil
-}
-
-func (m *SQLManager) GetKey(ctx context.Context, set, kid string) (*jose.JSONWebKeySet, error) {
-	var d SQLData
-	if err := m.DB.GetContext(ctx, &d, m.DB.Rebind("SELECT * FROM hydra_jwk WHERE sid=? AND kid=? ORDER BY created_at DESC"), set, kid); err != nil {
-		return nil, sqlcon.HandleError(err)
-	}
-
-	key, err := m.R.KeyCipher().Decrypt(d.Key)
-	if err != nil {
-		return nil, errors.WithStack(err)
-	}
-
-	var c jose.JSONWebKey
-	if err := json.Unmarshal(key, &c); err != nil {
-		return nil, errors.WithStack(err)
-	}
-
-	return &jose.JSONWebKeySet{
-		Keys: []jose.JSONWebKey{c},
-	}, nil
-}
-
-func (m *SQLManager) GetKeySet(ctx context.Context, set string) (*jose.JSONWebKeySet, error) {
-	var ds []SQLData
-	if err := m.DB.SelectContext(ctx, &ds, m.DB.Rebind("SELECT * FROM hydra_jwk WHERE sid=? ORDER BY created_at DESC"), set); err != nil {
-		return nil, sqlcon.HandleError(err)
-	}
-
-	if len(ds) == 0 {
-		return nil, errors.Wrap(x.ErrNotFound, "")
-	}
-
-	keys := &jose.JSONWebKeySet{Keys: []jose.JSONWebKey{}}
-	for _, d := range ds {
-		key, err := m.R.KeyCipher().Decrypt(d.Key)
-		if err != nil {
-			return nil, errors.WithStack(err)
-		}
-
-		var c jose.JSONWebKey
-		if err := json.Unmarshal(key, &c); err != nil {
-			return nil, errors.WithStack(err)
-		}
-		keys.Keys = append(keys.Keys, c)
-	}
-
-	if len(keys.Keys) == 0 {
-		return nil, errors.WithStack(x.ErrNotFound)
-	}
-
-	return keys, nil
-}
-
-func (m *SQLManager) DeleteKey(ctx context.Context, set, kid string) error {
-	if _, err := m.DB.ExecContext(ctx, m.DB.Rebind(`DELETE FROM hydra_jwk WHERE sid=? AND kid=?`), set, kid); err != nil {
-		return sqlcon.HandleError(err)
-	}
-	return nil
-}
-
-func (m *SQLManager) DeleteKeySet(ctx context.Context, set string) error {
-	tx, err := m.DB.BeginTxx(ctx, nil)
-	if err != nil {
-		return errors.WithStack(err)
-	}
-
-	if err := m.deleteKeySet(ctx, tx, set); err != nil {
-		if re := tx.Rollback(); re != nil {
-			return errors.Wrap(err, re.Error())
-		}
-		return sqlcon.HandleError(err)
-	}
-
-	if err := tx.Commit(); err != nil {
-		if re := tx.Rollback(); re != nil {
-			return errors.Wrap(err, re.Error())
-		}
-		return sqlcon.HandleError(err)
-	}
-	return nil
-}
-
-func (m *SQLManager) deleteKeySet(ctx context.Context, tx *sqlx.Tx, set string) error {
-	if _, err := tx.ExecContext(ctx, m.DB.Rebind(`DELETE FROM hydra_jwk WHERE sid=?`), set); err != nil {
-		return sqlcon.HandleError(err)
-	}
-	return nil
-}
diff --git a/jwk/manager_test.go b/jwk/manager_test.go
index 6fc3d08a4..a3781d6f8 100644
--- a/jwk/manager_test.go
+++ b/jwk/manager_test.go
@@ -39,7 +39,7 @@ var testGenerator = &RS256Generator{}
 func TestManager(t *testing.T) {
 	conf := internal.NewConfigurationWithDefaults()
 	registries := map[string]driver.Registry{
-		"memory": internal.NewRegistryMemory(conf),
+		"memory": internal.NewRegistryMemory(t, conf),
 	}
 
 	if !testing.Short() {
diff --git a/jwk/sdk_test.go b/jwk/sdk_test.go
index 7544779f7..30d73df4f 100644
--- a/jwk/sdk_test.go
+++ b/jwk/sdk_test.go
@@ -43,7 +43,7 @@ import (
 
 func TestJWKSDK(t *testing.T) {
 	conf := internal.NewConfigurationWithDefaults()
-	reg := internal.NewRegistryMemory(conf)
+	reg := internal.NewRegistryMemory(t, conf)
 
 	router := x.NewRouterAdmin()
 	h := NewHandler(reg, conf)
diff --git a/oauth2/fosite_store_helpers.go b/oauth2/fosite_store_helpers.go
index 1e2b75b38..17acf8ff9 100644
--- a/oauth2/fosite_store_helpers.go
+++ b/oauth2/fosite_store_helpers.go
@@ -28,6 +28,8 @@ import (
 	"testing"
 	"time"
 
+	"github.com/gobuffalo/pop/v5"
+
 	"github.com/ory/hydra/x"
 
 	"github.com/ory/fosite/storage"
@@ -40,7 +42,6 @@ import (
 
 	"github.com/ory/fosite"
 	"github.com/ory/fosite/handler/openid"
-	"github.com/ory/herodot"
 	"github.com/ory/x/sqlcon"
 
 	"github.com/ory/hydra/client"
@@ -52,30 +53,35 @@ func signatureFromJTI(jti string) string {
 }
 
 type BlacklistedJTI struct {
-	JTI       string    `db:"-"`
-	Signature string    `db:"signature"`
-	Expiry    time.Time `db:"expires_at"`
+	JTI    string    `db:"-"`
+	ID     string    `db:"signature"`
+	Expiry time.Time `db:"expires_at"`
+}
+
+func (j *BlacklistedJTI) AfterFind(_ *pop.Connection) error {
+	j.Expiry = j.Expiry.UTC()
+	return nil
 }
 
 func (BlacklistedJTI) TableName() string {
 	return "hydra_oauth2_jti_blacklist"
 }
 
-func newBlacklistedJTI(jti string, exp time.Time) *BlacklistedJTI {
+func NewBlacklistedJTI(jti string, exp time.Time) *BlacklistedJTI {
 	return &BlacklistedJTI{
-		JTI:       jti,
-		Signature: signatureFromJTI(jti),
+		JTI: jti,
+		ID:  signatureFromJTI(jti),
 		// because the database timestamp types are not as accurate as time.Time we truncate to seconds (which should always work)
 		Expiry: exp.UTC().Truncate(time.Second),
 	}
 }
 
-type assertionJWTReader interface {
+type AssertionJWTReader interface {
 	x.FositeStorer
 
-	getClientAssertionJWT(ctx context.Context, jti string) (*BlacklistedJTI, error)
+	GetClientAssertionJWT(ctx context.Context, jti string) (*BlacklistedJTI, error)
 
-	setClientAssertionJWT(context.Context, *BlacklistedJTI) error
+	SetClientAssertionJWTRaw(context.Context, *BlacklistedJTI) error
 }
 
 var defaultRequest = fosite.Request{
@@ -125,18 +131,18 @@ func mockRequestForeignKey(t *testing.T, id string, x InternalRegistry, createCl
 	cl := &client.Client{ID: "foobar"}
 	cr := &consent.ConsentRequest{
 		Client: cl, OpenIDConnectContext: new(consent.OpenIDConnectContext), LoginChallenge: sqlxx.NullString(id),
-		Challenge: id, Verifier: id, AuthenticatedAt: sqlxx.NullTime(time.Now()), RequestedAt: time.Now(),
+		ID: id, Verifier: id, AuthenticatedAt: sqlxx.NullTime(time.Now()), RequestedAt: time.Now(),
 	}
 
 	if createClient {
 		require.NoError(t, x.ClientManager().CreateClient(context.Background(), cl))
 	}
 
-	require.NoError(t, x.ConsentManager().CreateLoginRequest(context.Background(), &consent.LoginRequest{Client: cl, OpenIDConnectContext: new(consent.OpenIDConnectContext), Challenge: id, Verifier: id, AuthenticatedAt: sqlxx.NullTime(time.Now()), RequestedAt: time.Now()}))
+	require.NoError(t, x.ConsentManager().CreateLoginRequest(context.Background(), &consent.LoginRequest{Client: cl, OpenIDConnectContext: new(consent.OpenIDConnectContext), ID: id, Verifier: id, AuthenticatedAt: sqlxx.NullTime(time.Now()), RequestedAt: time.Now()}))
 	require.NoError(t, x.ConsentManager().CreateConsentRequest(context.Background(), cr))
 	_, err := x.ConsentManager().HandleConsentRequest(context.Background(), id, &consent.HandledConsentRequest{
 		ConsentRequest: cr, Session: new(consent.ConsentRequestSessionData), AuthenticatedAt: sqlxx.NullTime(time.Now()),
-		Challenge:   id,
+		ID:          id,
 		RequestedAt: time.Now(),
 		HandledAt:   sqlxx.NullTime(time.Now()),
 	})
@@ -176,13 +182,11 @@ func TestHelperRunner(t *testing.T, store InternalRegistry, k string) {
 
 func testHelperUniqueConstraints(m InternalRegistry, storageType string) func(t *testing.T) {
 	return func(t *testing.T) {
-		dbErrorIsConstraintError := func(dbErr error) {
-			assert.Error(t, dbErr)
-			if ve := new(herodot.DefaultError); errors.As(dbErr, &ve) {
-				assert.Equal(t, sqlcon.ErrUniqueViolation, ve)
-				return
+		dbErrorIsConstraintError := func(err error) {
+			assert.Error(t, err)
+			if !errors.Is(err, sqlcon.ErrUniqueViolation) {
+				t.Errorf("unexpected error type %+v %T", err, err)
 			}
-			t.Errorf("unexpected error type %s", dbErr)
 		}
 
 		requestId := uuid.New()
@@ -589,51 +593,51 @@ func testFositeSqlStoreTransactionRollbackOpenIdConnectSession(m InternalRegistr
 func testFositeStoreSetClientAssertionJWT(m InternalRegistry) func(*testing.T) {
 	return func(t *testing.T) {
 		t.Run("case=basic setting works", func(t *testing.T) {
-			store, ok := m.OAuth2Storage().(assertionJWTReader)
+			store, ok := m.OAuth2Storage().(AssertionJWTReader)
 			require.True(t, ok)
-			jti := newBlacklistedJTI("basic jti", time.Now().Add(time.Minute))
+			jti := NewBlacklistedJTI("basic jti", time.Now().Add(time.Minute))
 
 			require.NoError(t, store.SetClientAssertionJWT(context.Background(), jti.JTI, jti.Expiry))
 
-			cmp, err := store.getClientAssertionJWT(context.Background(), jti.JTI)
+			cmp, err := store.GetClientAssertionJWT(context.Background(), jti.JTI)
 			require.NoError(t, err)
 			assert.Equal(t, jti, cmp)
 		})
 
 		t.Run("case=errors when the JTI is blacklisted", func(t *testing.T) {
-			store, ok := m.OAuth2Storage().(assertionJWTReader)
+			store, ok := m.OAuth2Storage().(AssertionJWTReader)
 			require.True(t, ok)
-			jti := newBlacklistedJTI("already set jti", time.Now().Add(time.Minute))
-			require.NoError(t, store.setClientAssertionJWT(context.Background(), jti))
+			jti := NewBlacklistedJTI("already set jti", time.Now().Add(time.Minute))
+			require.NoError(t, store.SetClientAssertionJWTRaw(context.Background(), jti))
 
 			assert.True(t, errors.Is(store.SetClientAssertionJWT(context.Background(), jti.JTI, jti.Expiry), fosite.ErrJTIKnown))
 		})
 
 		t.Run("case=deletes expired JTIs", func(t *testing.T) {
-			store, ok := m.OAuth2Storage().(assertionJWTReader)
+			store, ok := m.OAuth2Storage().(AssertionJWTReader)
 			require.True(t, ok)
-			expiredJTI := newBlacklistedJTI("expired jti", time.Now().Add(-time.Minute))
-			require.NoError(t, store.setClientAssertionJWT(context.Background(), expiredJTI))
-			newJTI := newBlacklistedJTI("some new jti", time.Now().Add(time.Minute))
+			expiredJTI := NewBlacklistedJTI("expired jti", time.Now().Add(-time.Minute))
+			require.NoError(t, store.SetClientAssertionJWTRaw(context.Background(), expiredJTI))
+			newJTI := NewBlacklistedJTI("some new jti", time.Now().Add(time.Minute))
 
 			require.NoError(t, store.SetClientAssertionJWT(context.Background(), newJTI.JTI, newJTI.Expiry))
 
-			_, err := store.getClientAssertionJWT(context.Background(), expiredJTI.JTI)
+			_, err := store.GetClientAssertionJWT(context.Background(), expiredJTI.JTI)
 			assert.True(t, errors.Is(err, sqlcon.ErrNoRows))
-			cmp, err := store.getClientAssertionJWT(context.Background(), newJTI.JTI)
+			cmp, err := store.GetClientAssertionJWT(context.Background(), newJTI.JTI)
 			require.NoError(t, err)
 			assert.Equal(t, newJTI, cmp)
 		})
 
 		t.Run("case=inserts same JTI if expired", func(t *testing.T) {
-			store, ok := m.OAuth2Storage().(assertionJWTReader)
+			store, ok := m.OAuth2Storage().(AssertionJWTReader)
 			require.True(t, ok)
-			jti := newBlacklistedJTI("going to be reused jti", time.Now().Add(-time.Minute))
-			require.NoError(t, store.setClientAssertionJWT(context.Background(), jti))
+			jti := NewBlacklistedJTI("going to be reused jti", time.Now().Add(-time.Minute))
+			require.NoError(t, store.SetClientAssertionJWTRaw(context.Background(), jti))
 
 			jti.Expiry = jti.Expiry.Add(2 * time.Minute)
 			assert.NoError(t, store.SetClientAssertionJWT(context.Background(), jti.JTI, jti.Expiry))
-			cmp, err := store.getClientAssertionJWT(context.Background(), jti.JTI)
+			cmp, err := store.GetClientAssertionJWT(context.Background(), jti.JTI)
 			assert.NoError(t, err)
 			assert.Equal(t, jti, cmp)
 		})
@@ -643,28 +647,28 @@ func testFositeStoreSetClientAssertionJWT(m InternalRegistry) func(*testing.T) {
 func testFositeStoreClientAssertionJWTValid(m InternalRegistry) func(*testing.T) {
 	return func(t *testing.T) {
 		t.Run("case=returns valid on unknown JTI", func(t *testing.T) {
-			store, ok := m.OAuth2Storage().(assertionJWTReader)
+			store, ok := m.OAuth2Storage().(AssertionJWTReader)
 			require.True(t, ok)
 
 			assert.NoError(t, store.ClientAssertionJWTValid(context.Background(), "unknown jti"))
 		})
 
 		t.Run("case=returns invalid on known JTI", func(t *testing.T) {
-			store, ok := m.OAuth2Storage().(assertionJWTReader)
+			store, ok := m.OAuth2Storage().(AssertionJWTReader)
 			require.True(t, ok)
-			jti := newBlacklistedJTI("known jti", time.Now().Add(time.Minute))
+			jti := NewBlacklistedJTI("known jti", time.Now().Add(time.Minute))
 
-			require.NoError(t, store.setClientAssertionJWT(context.Background(), jti))
+			require.NoError(t, store.SetClientAssertionJWTRaw(context.Background(), jti))
 
 			assert.True(t, errors.Is(store.ClientAssertionJWTValid(context.Background(), jti.JTI), fosite.ErrJTIKnown))
 		})
 
 		t.Run("case=returns valid on expired JTI", func(t *testing.T) {
-			store, ok := m.OAuth2Storage().(assertionJWTReader)
+			store, ok := m.OAuth2Storage().(AssertionJWTReader)
 			require.True(t, ok)
-			jti := newBlacklistedJTI("expired jti", time.Now().Add(-time.Minute))
+			jti := NewBlacklistedJTI("expired jti 2", time.Now().Add(-time.Minute))
 
-			require.NoError(t, store.setClientAssertionJWT(context.Background(), jti))
+			require.NoError(t, store.SetClientAssertionJWTRaw(context.Background(), jti))
 
 			assert.NoError(t, store.ClientAssertionJWTValid(context.Background(), jti.JTI))
 		})
diff --git a/oauth2/fosite_store_memory.go b/oauth2/fosite_store_memory.go
deleted file mode 100644
index e168a4f99..000000000
--- a/oauth2/fosite_store_memory.go
+++ /dev/null
@@ -1,426 +0,0 @@
-/*
- * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @license 	Apache-2.0
- */
-
-package oauth2
-
-import (
-	"context"
-	"sync"
-	"time"
-
-	"github.com/ory/hydra/client"
-
-	"github.com/pkg/errors"
-
-	"github.com/ory/fosite"
-	"github.com/ory/x/sqlcon"
-)
-
-type FositeMemoryStore struct {
-	AuthorizeCodes  map[string]authorizeCode
-	IDSessions      map[string]fosite.Requester
-	AccessTokens    map[string]fosite.Requester
-	RefreshTokens   map[string]fosite.Requester
-	PKCES           map[string]fosite.Requester
-	BlacklistedJTIs map[string]time.Time
-
-	c Configuration
-	r InternalRegistry
-
-	sync.RWMutex
-
-	//client.Manager
-}
-
-func NewFositeMemoryStore(
-	r InternalRegistry,
-	c Configuration,
-) *FositeMemoryStore {
-	return &FositeMemoryStore{
-		AuthorizeCodes:  make(map[string]authorizeCode),
-		IDSessions:      make(map[string]fosite.Requester),
-		AccessTokens:    make(map[string]fosite.Requester),
-		PKCES:           make(map[string]fosite.Requester),
-		RefreshTokens:   make(map[string]fosite.Requester),
-		BlacklistedJTIs: make(map[string]time.Time),
-
-		c: c,
-		r: r,
-	}
-}
-
-type authorizeCode struct {
-	active bool
-	fosite.Requester
-}
-
-func (s *FositeMemoryStore) GetClient(ctx context.Context, id string) (fosite.Client, error) {
-	return s.r.ClientManager().GetClient(ctx, id)
-}
-
-func (s *FositeMemoryStore) ClientAssertionJWTValid(_ context.Context, jti string) error {
-	s.RLock()
-	defer s.RUnlock()
-	if exp, exists := s.BlacklistedJTIs[jti]; exists && exp.After(time.Now()) {
-		return errors.WithStack(fosite.ErrJTIKnown)
-	}
-
-	return nil
-}
-
-func (s *FositeMemoryStore) SetClientAssertionJWT(_ context.Context, jti string, exp time.Time) error {
-	s.Lock()
-	defer s.Unlock()
-
-	for j, e := range s.BlacklistedJTIs {
-		if e.Before(time.Now()) {
-			delete(s.BlacklistedJTIs, j)
-		}
-	}
-
-	if _, exists := s.BlacklistedJTIs[jti]; exists {
-		return errors.WithStack(fosite.ErrJTIKnown)
-	}
-
-	s.BlacklistedJTIs[jti] = exp
-	return nil
-}
-
-func (s *FositeMemoryStore) getClientAssertionJWT(_ context.Context, jti string) (*BlacklistedJTI, error) {
-	s.RLock()
-	defer s.RUnlock()
-
-	if exp, exists := s.BlacklistedJTIs[jti]; exists {
-		return newBlacklistedJTI(jti, exp), nil
-	}
-
-	return nil, errors.WithStack(sqlcon.ErrNoRows)
-}
-
-func (s *FositeMemoryStore) setClientAssertionJWT(_ context.Context, jti *BlacklistedJTI) error {
-	s.Lock()
-	defer s.Unlock()
-
-	s.BlacklistedJTIs[jti.JTI] = jti.Expiry
-	return nil
-}
-
-func (s *FositeMemoryStore) Authenticate(ctx context.Context, id string, secret []byte) (*client.Client, error) {
-	return s.r.ClientManager().Authenticate(ctx, id, secret)
-}
-
-func (s *FositeMemoryStore) CreateClient(ctx context.Context, c *client.Client) error {
-	return s.r.ClientManager().CreateClient(ctx, c)
-
-}
-
-func (s *FositeMemoryStore) UpdateClient(ctx context.Context, c *client.Client) error {
-	return s.r.ClientManager().UpdateClient(ctx, c)
-
-}
-
-func (s *FositeMemoryStore) DeleteClient(ctx context.Context, id string) error {
-	return s.r.ClientManager().DeleteClient(ctx, id)
-}
-
-func (s *FositeMemoryStore) GetClients(ctx context.Context, limit, offset int) (map[string]client.Client, error) {
-	interim, err := s.r.ClientManager().GetClients(ctx, limit, offset)
-	if err != nil {
-		return nil, err
-	}
-
-	clients := map[string]client.Client{}
-	for _, c := range interim {
-		clients[c.GetID()] = c
-	}
-
-	return clients, nil
-}
-
-func (s *FositeMemoryStore) GetConcreteClient(ctx context.Context, id string) (*client.Client, error) {
-	return s.r.ClientManager().GetConcreteClient(ctx, id)
-}
-
-func (s *FositeMemoryStore) CreateOpenIDConnectSession(_ context.Context, authorizeCode string, requester fosite.Requester) error {
-	s.Lock()
-	defer s.Unlock()
-	s.IDSessions[authorizeCode] = requester
-	return nil
-}
-
-func (s *FositeMemoryStore) GetOpenIDConnectSession(ctx context.Context, code string, requester fosite.Requester) (fosite.Requester, error) {
-	s.RLock()
-	rel, ok := s.IDSessions[code]
-	s.RUnlock()
-
-	if !ok {
-		return nil, errors.Wrap(fosite.ErrNotFound, "")
-	}
-
-	if _, err := s.r.ClientManager().GetClient(ctx, rel.GetClient().GetID()); errors.Is(err, sqlcon.ErrNoRows) {
-		s.Lock()
-		delete(s.IDSessions, code)
-		s.Unlock()
-		return nil, err
-	} else if err != nil {
-		return nil, err
-	}
-
-	return rel, nil
-}
-
-func (s *FositeMemoryStore) DeleteOpenIDConnectSession(_ context.Context, authorizeCode string) error {
-	s.Lock()
-	defer s.Unlock()
-	delete(s.IDSessions, authorizeCode)
-	return nil
-}
-
-func (s *FositeMemoryStore) CreateAuthorizeCodeSession(_ context.Context, code string, req fosite.Requester) error {
-	s.Lock()
-	defer s.Unlock()
-	s.AuthorizeCodes[code] = authorizeCode{active: true, Requester: req}
-	return nil
-}
-
-func (s *FositeMemoryStore) GetAuthorizeCodeSession(ctx context.Context, code string, _ fosite.Session) (fosite.Requester, error) {
-	s.RLock()
-	rel, ok := s.AuthorizeCodes[code]
-	s.RUnlock()
-
-	if !ok {
-		return nil, errors.Wrap(fosite.ErrNotFound, "")
-	}
-
-	if !rel.active {
-		return rel.Requester, errors.WithStack(fosite.ErrInvalidatedAuthorizeCode)
-	}
-
-	if _, err := s.r.ClientManager().GetClient(ctx, rel.GetClient().GetID()); errors.Is(err, sqlcon.ErrNoRows) {
-		s.Lock()
-		delete(s.AuthorizeCodes, code)
-		s.Unlock()
-		return nil, err
-	} else if err != nil {
-		return nil, err
-	}
-
-	return rel.Requester, nil
-}
-
-func (s *FositeMemoryStore) InvalidateAuthorizeCodeSession(ctx context.Context, code string) error {
-	s.Lock()
-	defer s.Unlock()
-
-	rel, ok := s.AuthorizeCodes[code]
-	if !ok {
-		return errors.WithStack(fosite.ErrNotFound)
-	}
-	rel.active = false
-	s.AuthorizeCodes[code] = rel
-	return nil
-}
-
-func (s *FositeMemoryStore) CreateAccessTokenSession(_ context.Context, signature string, req fosite.Requester) error {
-	s.Lock()
-	defer s.Unlock()
-	s.AccessTokens[signature] = req
-	return nil
-}
-
-func (s *FositeMemoryStore) GetAccessTokenSession(ctx context.Context, signature string, _ fosite.Session) (fosite.Requester, error) {
-	s.RLock()
-	rel, ok := s.AccessTokens[signature]
-	s.RUnlock()
-
-	if !ok {
-		return nil, errors.Wrap(fosite.ErrNotFound, "")
-	}
-
-	if _, err := s.r.ClientManager().GetClient(ctx, rel.GetClient().GetID()); errors.Is(err, sqlcon.ErrNoRows) {
-		s.Lock()
-		delete(s.AccessTokens, signature)
-		s.Unlock()
-		return nil, err
-	} else if err != nil {
-		return nil, err
-	}
-
-	return rel, nil
-}
-
-func (s *FositeMemoryStore) DeleteAccessTokenSession(ctx context.Context, signature string) error {
-	s.Lock()
-	defer s.Unlock()
-	return s.deleteAccessTokenSession(ctx, signature)
-}
-
-func (s *FositeMemoryStore) deleteAccessTokenSession(_ context.Context, signature string) error {
-	delete(s.AccessTokens, signature)
-	return nil
-}
-
-func (s *FositeMemoryStore) CreateRefreshTokenSession(_ context.Context, signature string, req fosite.Requester) error {
-	s.Lock()
-	defer s.Unlock()
-	s.RefreshTokens[signature] = req
-	return nil
-}
-
-func (s *FositeMemoryStore) GetRefreshTokenSession(ctx context.Context, signature string, _ fosite.Session) (fosite.Requester, error) {
-	s.RLock()
-	rel, ok := s.RefreshTokens[signature]
-	s.RUnlock()
-
-	if !ok {
-		return nil, errors.Wrap(fosite.ErrNotFound, "")
-	}
-
-	if _, err := s.r.ClientManager().GetClient(ctx, rel.GetClient().GetID()); errors.Is(err, sqlcon.ErrNoRows) {
-		s.Lock()
-		delete(s.RefreshTokens, signature)
-		s.Unlock()
-		return nil, err
-	} else if err != nil {
-		return nil, err
-	}
-
-	return rel, nil
-}
-
-func (s *FositeMemoryStore) DeleteRefreshTokenSession(ctx context.Context, signature string) error {
-	s.Lock()
-	defer s.Unlock()
-	return s.deleteRefreshTokenSession(ctx, signature)
-}
-
-func (s *FositeMemoryStore) deleteRefreshTokenSession(_ context.Context, signature string) error {
-	delete(s.RefreshTokens, signature)
-	return nil
-}
-
-func (s *FositeMemoryStore) CreateImplicitAccessTokenSession(ctx context.Context, code string, req fosite.Requester) error {
-	return s.CreateAccessTokenSession(ctx, code, req)
-}
-
-func (s *FositeMemoryStore) RevokeRefreshToken(ctx context.Context, id string) error {
-	s.Lock()
-	defer s.Unlock()
-	var found bool
-	for sig, token := range s.RefreshTokens {
-		if token.GetID() == id {
-			if err := s.deleteRefreshTokenSession(ctx, sig); err != nil {
-				return err
-			}
-			found = true
-		}
-	}
-	if !found {
-		return errors.WithStack(fosite.ErrNotFound)
-	}
-	return nil
-}
-
-func (s *FositeMemoryStore) RevokeAccessToken(ctx context.Context, id string) error {
-	s.Lock()
-	defer s.Unlock()
-	var found bool
-	for sig, token := range s.AccessTokens {
-		if token.GetID() == id {
-			if err := s.deleteAccessTokenSession(ctx, sig); err != nil {
-				return err
-			}
-			found = true
-		}
-	}
-	if !found {
-		return errors.WithStack(fosite.ErrNotFound)
-	}
-	return nil
-}
-
-func (s *FositeMemoryStore) FlushInactiveAccessTokens(ctx context.Context, notAfter time.Time) error {
-	s.Lock()
-	defer s.Unlock()
-
-	now := time.Now()
-	for sig, token := range s.AccessTokens {
-		expiresAt := token.GetRequestedAt().Add(s.c.AccessTokenLifespan())
-		isExpired := expiresAt.Before(now)
-		isNotAfter := token.GetRequestedAt().Before(notAfter)
-
-		if isExpired && isNotAfter {
-			if err := s.deleteAccessTokenSession(ctx, sig); err != nil {
-				return err
-			}
-		}
-	}
-
-	return nil
-}
-
-func (s *FositeMemoryStore) CreatePKCERequestSession(_ context.Context, code string, req fosite.Requester) error {
-	s.Lock()
-	s.PKCES[code] = req
-	s.Unlock()
-	return nil
-}
-
-func (s *FositeMemoryStore) GetPKCERequestSession(ctx context.Context, code string, _ fosite.Session) (fosite.Requester, error) {
-	s.RLock()
-	rel, ok := s.PKCES[code]
-	s.RUnlock()
-	if !ok {
-		return nil, errors.WithStack(fosite.ErrNotFound)
-	}
-
-	if _, err := s.r.ClientManager().GetClient(ctx, rel.GetClient().GetID()); errors.Is(err, sqlcon.ErrNoRows) {
-		s.Lock()
-		delete(s.RefreshTokens, code)
-		s.Unlock()
-		return nil, err
-	} else if err != nil {
-		return nil, err
-	}
-
-	return rel, nil
-}
-
-func (s *FositeMemoryStore) DeletePKCERequestSession(_ context.Context, code string) error {
-	s.Lock()
-	delete(s.PKCES, code)
-	s.Unlock()
-	return nil
-}
-
-func (s *FositeMemoryStore) DeleteAccessTokens(ctx context.Context, clientID string) error {
-	s.Lock()
-	defer s.Unlock()
-
-	for sig, token := range s.AccessTokens {
-		if token.GetClient().GetID() == clientID {
-			if err := s.deleteAccessTokenSession(ctx, sig); err != nil {
-				return err
-			}
-		}
-	}
-
-	return nil
-}
diff --git a/oauth2/fosite_store_sql.go b/oauth2/fosite_store_sql.go
deleted file mode 100644
index 8aa72cc31..000000000
--- a/oauth2/fosite_store_sql.go
+++ /dev/null
@@ -1,531 +0,0 @@
-/*
- * Copyright © 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
- * @license 	Apache-2.0
- */
-
-package oauth2
-
-import (
-	"context"
-	"crypto/sha512"
-	"database/sql"
-	"encoding/json"
-	"fmt"
-	"net/url"
-	"strings"
-	"time"
-
-	"github.com/jmoiron/sqlx"
-	"github.com/pkg/errors"
-	"github.com/tidwall/gjson"
-
-	"github.com/ory/x/logrusx"
-
-	"github.com/ory/herodot"
-
-	"github.com/ory/fosite"
-	"github.com/ory/x/sqlcon"
-	"github.com/ory/x/stringsx"
-
-	"github.com/ory/hydra/client"
-	"github.com/ory/hydra/jwk"
-)
-
-type FositeSQLStore struct {
-	DB *sqlx.DB
-
-	r  InternalRegistry
-	c  Configuration
-	kc *jwk.AEAD
-
-	HashSignature bool
-}
-
-type sqlxDB interface {
-	sqlx.ExecerContext
-	sqlx.Ext
-	NamedExecContext(ctx context.Context, query string, arg interface{}) (sql.Result, error)
-	GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
-}
-
-func NewFositeSQLStore(db *sqlx.DB, r InternalRegistry, c Configuration, kc *jwk.AEAD) *FositeSQLStore {
-	return &FositeSQLStore{r: r, c: c, kc: kc, DB: db}
-}
-
-type tableName string
-
-const (
-	sqlTableOpenID         tableName = "oidc"
-	sqlTableAccess         tableName = "access"
-	sqlTableRefresh        tableName = "refresh"
-	sqlTableCode           tableName = "code"
-	sqlTablePKCE           tableName = "pkce"
-	sqlTableBlacklistedJTI tableName = "jti_blacklist"
-)
-
-type transactionKey int
-
-const txKey transactionKey = iota
-
-var sqlParams = []string{
-	"signature",
-	"request_id",
-	"requested_at",
-	"client_id",
-	"scope",
-	"granted_scope",
-	"form_data",
-	"session_data",
-	"subject",
-	"active",
-	"requested_audience",
-	"granted_audience",
-	"challenge_id",
-}
-
-type SQLData struct {
-	PK                int            `db:"pk"`
-	Signature         string         `db:"signature"`
-	Request           string         `db:"request_id"`
-	ConsentChallenge  sql.NullString `db:"challenge_id"`
-	RequestedAt       time.Time      `db:"requested_at"`
-	Client            string         `db:"client_id"`
-	Scopes            string         `db:"scope"`
-	GrantedScope      string         `db:"granted_scope"`
-	RequestedAudience string         `db:"requested_audience"`
-	GrantedAudience   string         `db:"granted_audience"`
-	Form              string         `db:"form_data"`
-	Subject           string         `db:"subject"`
-	Active            bool           `db:"active"`
-	Session           []byte         `db:"session_data"`
-}
-
-func sqlSchemaFromRequest(signature string, r fosite.Requester, c Configuration, kc *jwk.AEAD, logger *logrusx.Logger) (*SQLData, error) {
-	subject := ""
-	if r.GetSession() == nil {
-		logger.Debugf("Got an empty session in sqlSchemaFromRequest")
-	} else {
-		subject = r.GetSession().GetSubject()
-	}
-
-	session, err := json.Marshal(r.GetSession())
-	if err != nil {
-		return nil, errors.WithStack(err)
-	}
-
-	if c.EncryptSessionData() {
-		ciphertext, err := kc.Encrypt(session)
-		if err != nil {
-			return nil, errors.WithStack(err)
-		}
-		session = []byte(ciphertext)
-	}
-
-	var challenge sql.NullString
-	rr, ok := r.GetSession().(*Session)
-	if !ok && r.GetSession() != nil {
-		return nil, errors.Errorf("Expected request to be of type *Session, but got: %T", r.GetSession())
-	} else if ok {
-		if len(rr.ConsentChallenge) > 0 {
-			challenge = sql.NullString{Valid: true, String: rr.ConsentChallenge}
-		}
-	}
-
-	return &SQLData{
-		Request:           r.GetID(),
-		ConsentChallenge:  challenge,
-		Signature:         signature,
-		RequestedAt:       r.GetRequestedAt(),
-		Client:            r.GetClient().GetID(),
-		Scopes:            strings.Join([]string(r.GetRequestedScopes()), "|"),
-		GrantedScope:      strings.Join([]string(r.GetGrantedScopes()), "|"),
-		GrantedAudience:   strings.Join([]string(r.GetGrantedAudience()), "|"),
-		RequestedAudience: strings.Join([]string(r.GetRequestedAudience()), "|"),
-		Form:              r.GetRequestForm().Encode(),
-		Session:           session,
-		Subject:           subject,
-		Active:            true,
-	}, nil
-}
-
-func (s *SQLData) toRequest(session fosite.Session, cm client.Manager, conf Configuration, kc *jwk.AEAD, logger *logrusx.Logger) (*fosite.Request, error) {
-	sess := s.Session
-	if !gjson.ValidBytes(sess) {
-		var err error
-		sess, err = kc.Decrypt(string(sess))
-		if err != nil {
-			return nil, errors.WithStack(err)
-		}
-	}
-
-	if session != nil {
-		if err := json.Unmarshal(sess, session); err != nil {
-			return nil, errors.WithStack(err)
-		}
-	} else {
-		logger.Debugf("Got an empty session in toRequest")
-	}
-
-	c, err := cm.GetClient(context.Background(), s.Client)
-	if err != nil {
-		return nil, err
-	}
-
-	val, err := url.ParseQuery(s.Form)
-	if err != nil {
-		return nil, errors.WithStack(err)
-	}
-
-	r := &fosite.Request{
-		ID:                s.Request,
-		RequestedAt:       s.RequestedAt,
-		Client:            c,
-		RequestedScope:    fosite.Arguments(stringsx.Splitx(s.Scopes, "|")),
-		GrantedScope:      fosite.Arguments(stringsx.Splitx(s.GrantedScope, "|")),
-		RequestedAudience: fosite.Arguments(stringsx.Splitx(s.RequestedAudience, "|")),
-		GrantedAudience:   fosite.Arguments(stringsx.Splitx(s.GrantedAudience, "|")),
-		Form:              val,
-		Session:           session,
-	}
-
-	return r, nil
-}
-
-func (s *FositeSQLStore) GetClient(ctx context.Context, id string) (fosite.Client, error) {
-	return s.r.ClientManager().GetClient(ctx, id)
-}
-
-func (s *FositeSQLStore) ClientAssertionJWTValid(ctx context.Context, jti string) error {
-	d, err := s.getClientAssertionJWT(ctx, jti)
-	if errors.Is(err, sqlcon.ErrNoRows) {
-		// the jti is not known => valid
-		return nil
-	} else if err != nil {
-		return err
-	}
-	if d.Expiry.After(time.Now()) {
-		// the jti is not expired yet => invalid
-		return errors.WithStack(fosite.ErrJTIKnown)
-	}
-	// the jti is expired => valid
-	return nil
-}
-
-func (s *FositeSQLStore) SetClientAssertionJWT(ctx context.Context, j string, exp time.Time) error {
-	db := s.db(ctx)
-
-	// delete expired
-	if _, err := db.ExecContext(ctx, fmt.Sprintf("DELETE FROM hydra_oauth2_%s WHERE expires_at < now()", sqlTableBlacklistedJTI)); err != nil {
-		return sqlcon.HandleError(err)
-	}
-
-	if err := s.setClientAssertionJWT(ctx, newBlacklistedJTI(j, exp)); errors.Is(err, sqlcon.ErrUniqueViolation) {
-		// found a jti
-		return errors.WithStack(fosite.ErrJTIKnown)
-	} else if err != nil {
-		return err
-	}
-	// setting worked without a problem
-	return nil
-}
-
-func (s *FositeSQLStore) getClientAssertionJWT(ctx context.Context, j string) (*BlacklistedJTI, error) {
-	sig := signatureFromJTI(j)
-	jti := BlacklistedJTI{
-		JTI: j,
-	}
-	db := s.db(ctx)
-
-	return &jti, sqlcon.HandleError(db.GetContext(ctx, &jti, db.Rebind(fmt.Sprintf("SELECT * FROM hydra_oauth2_%s WHERE signature=?", sqlTableBlacklistedJTI)), sig))
-}
-
-func (s *FositeSQLStore) setClientAssertionJWT(ctx context.Context, jti *BlacklistedJTI) error {
-	db := s.db(ctx)
-	_, err := db.ExecContext(ctx, db.Rebind(fmt.Sprintf("INSERT INTO hydra_oauth2_%s (signature, expires_at) VALUES (?, ?)", sqlTableBlacklistedJTI)), jti.Signature, jti.Expiry)
-
-	return sqlcon.HandleError(err)
-}
-
-func (s *FositeSQLStore) Authenticate(ctx context.Context, id string, secret []byte) (*client.Client, error) {
-	return s.r.ClientManager().Authenticate(ctx, id, secret)
-}
-
-func (s *FositeSQLStore) CreateClient(ctx context.Context, c *client.Client) error {
-	return s.r.ClientManager().CreateClient(ctx, c)
-
-}
-
-func (s *FositeSQLStore) UpdateClient(ctx context.Context, c *client.Client) error {
-	return s.r.ClientManager().UpdateClient(ctx, c)
-
-}
-
-func (s *FositeSQLStore) DeleteClient(ctx context.Context, id string) error {
-	return s.r.ClientManager().DeleteClient(ctx, id)
-
-}
-
-func (s *FositeSQLStore) GetClients(ctx context.Context, limit, offset int) (map[string]client.Client, error) {
-	interim, err := s.r.ClientManager().GetClients(ctx, limit, offset)
-	if err != nil {
-		return nil, err
-	}
-
-	clients := map[string]client.Client{}
-	for _, c := range interim {
-		clients[c.GetID()] = c
-	}
-
-	return clients, nil
-}
-
-func (s *FositeSQLStore) GetConcreteClient(ctx context.Context, id string) (*client.Client, error) {
-	return s.r.ClientManager().GetConcreteClient(ctx, id)
-}
-
-// hashSignature prevents errors where the signature is longer than 128 characters (and thus doesn't fit into the pk).
-func (s *FositeSQLStore) hashSignature(signature string, table tableName) string {
-	if table == sqlTableAccess && s.c.IsUsingJWTAsAccessTokens() {
-		return fmt.Sprintf("%x", sha512.Sum384([]byte(signature)))
-	}
-	return signature
-}
-
-func (s *FositeSQLStore) createSession(ctx context.Context, signature string, requester fosite.Requester, table tableName) error {
-	db := s.db(ctx)
-	signature = s.hashSignature(signature, table)
-
-	data, err := sqlSchemaFromRequest(signature, requester, s.c, s.kc, s.r.Logger())
-	if err != nil {
-		return err
-	}
-
-	/* #nosec G201 - sqlParams is a "constant" array */
-	query := fmt.Sprintf(
-		"INSERT INTO hydra_oauth2_%s (%s) VALUES (%s)",
-		table,
-		strings.Join(sqlParams, ", "),
-		":"+strings.Join(sqlParams, ", :"),
-	)
-	if _, err := db.NamedExecContext(ctx, query, data); err != nil {
-		err = sqlcon.HandleError(err)
-		switch errCause := errors.Cause(err).(type) {
-		case *herodot.DefaultError:
-			if errCause == sqlcon.ErrConcurrentUpdate {
-				return errors.Wrap(fosite.ErrSerializationFailure, err.Error())
-			}
-		}
-		return err
-	}
-	return nil
-}
-
-func (s *FositeSQLStore) db(ctx context.Context) sqlxDB {
-	if tx, ok := ctx.Value(txKey).(*sqlx.Tx); ok {
-		return tx
-	} else {
-		return s.DB
-	}
-}
-
-func (s *FositeSQLStore) findSessionBySignature(ctx context.Context, signature string, session fosite.Session, table tableName) (fosite.Requester, error) {
-	db := s.db(ctx)
-	signature = s.hashSignature(signature, table)
-
-	var d SQLData
-	/* #nosec G201 - table is a fixed enum */
-	if err := db.GetContext(ctx, &d, db.Rebind(fmt.Sprintf("SELECT * FROM hydra_oauth2_%s WHERE signature=?", table)), signature); err == sql.ErrNoRows {
-		return nil, errors.Wrap(fosite.ErrNotFound, "")
-	} else if err != nil {
-		return nil, sqlcon.HandleError(err)
-	} else if !d.Active && table == sqlTableCode {
-		if r, err := d.toRequest(session, s.r.ClientManager(), s.c, s.kc, s.r.Logger()); err != nil {
-			return nil, err
-		} else {
-			return r, errors.WithStack(fosite.ErrInvalidatedAuthorizeCode)
-		}
-	} else if !d.Active {
-		return nil, errors.WithStack(fosite.ErrInactiveToken)
-	}
-
-	return d.toRequest(session, s.r.ClientManager(), s.c, s.kc, s.r.Logger())
-}
-
-func (s *FositeSQLStore) deleteSession(ctx context.Context, signature string, table tableName) error {
-	db := s.db(ctx)
-	signature = s.hashSignature(signature, table)
-
-	/* #nosec G201 - table is a const */
-	if _, err := db.ExecContext(ctx, s.DB.Rebind(fmt.Sprintf("DELETE FROM hydra_oauth2_%s WHERE signature=?", table)), signature); err != nil {
-		return sqlcon.HandleError(err)
-	}
-	return nil
-}
-
-func (s *FositeSQLStore) CreateOpenIDConnectSession(ctx context.Context, signature string, requester fosite.Requester) error {
-	return s.createSession(ctx, signature, requester, sqlTableOpenID)
-}
-
-func (s *FositeSQLStore) GetOpenIDConnectSession(ctx context.Context, signature string, requester fosite.Requester) (fosite.Requester, error) {
-	return s.findSessionBySignature(ctx, signature, requester.GetSession(), sqlTableOpenID)
-}
-
-func (s *FositeSQLStore) DeleteOpenIDConnectSession(ctx context.Context, signature string) error {
-	return s.deleteSession(ctx, signature, sqlTableOpenID)
-}
-
-func (s *FositeSQLStore) CreateAuthorizeCodeSession(ctx context.Context, signature string, requester fosite.Requester) error {
-	return s.createSession(ctx, signature, requester, sqlTableCode)
-}
-
-func (s *FositeSQLStore) GetAuthorizeCodeSession(ctx context.Context, signature string, session fosite.Session) (fosite.Requester, error) {
-	return s.findSessionBySignature(ctx, signature, session, sqlTableCode)
-}
-
-func (s *FositeSQLStore) InvalidateAuthorizeCodeSession(ctx context.Context, signature string) error {
-	db := s.db(ctx)
-	if _, err := db.ExecContext(ctx, db.Rebind(fmt.Sprintf(
-		"UPDATE hydra_oauth2_%s SET active=false WHERE signature=?",
-		sqlTableCode,
-	)), signature); err != nil {
-		return sqlcon.HandleError(err)
-	}
-
-	return nil
-}
-
-func (s *FositeSQLStore) CreateAccessTokenSession(ctx context.Context, signature string, requester fosite.Requester) error {
-	return s.createSession(ctx, signature, requester, sqlTableAccess)
-}
-
-func (s *FositeSQLStore) GetAccessTokenSession(ctx context.Context, signature string, session fosite.Session) (fosite.Requester, error) {
-	return s.findSessionBySignature(ctx, signature, session, sqlTableAccess)
-}
-
-func (s *FositeSQLStore) DeleteAccessTokenSession(ctx context.Context, signature string) error {
-	return s.deleteSession(ctx, signature, sqlTableAccess)
-}
-
-func (s *FositeSQLStore) CreateRefreshTokenSession(ctx context.Context, signature string, requester fosite.Requester) error {
-	return s.createSession(ctx, signature, requester, sqlTableRefresh)
-}
-
-func (s *FositeSQLStore) GetRefreshTokenSession(ctx context.Context, signature string, session fosite.Session) (fosite.Requester, error) {
-	return s.findSessionBySignature(ctx, signature, session, sqlTableRefresh)
-}
-
-func (s *FositeSQLStore) DeleteRefreshTokenSession(ctx context.Context, signature string) error {
-	return s.deleteSession(ctx, signature, sqlTableRefresh)
-}
-
-func (s *FositeSQLStore) CreatePKCERequestSession(ctx context.Context, signature string, requester fosite.Requester) error {
-	return s.createSession(ctx, signature, requester, sqlTablePKCE)
-}
-
-func (s *FositeSQLStore) GetPKCERequestSession(ctx context.Context, signature string, session fosite.Session) (fosite.Requester, error) {
-	return s.findSessionBySignature(ctx, signature, session, sqlTablePKCE)
-}
-
-func (s *FositeSQLStore) DeletePKCERequestSession(ctx context.Context, signature string) error {
-	return s.deleteSession(ctx, signature, sqlTablePKCE)
-}
-
-func (s *FositeSQLStore) CreateImplicitAccessTokenSession(ctx context.Context, signature string, requester fosite.Requester) error {
-	return s.CreateAccessTokenSession(ctx, signature, requester)
-}
-
-func (s *FositeSQLStore) RevokeRefreshToken(ctx context.Context, id string) error {
-	return s.revokeSession(ctx, id, sqlTableRefresh)
-}
-
-func (s *FositeSQLStore) RevokeAccessToken(ctx context.Context, id string) error {
-	return s.revokeSession(ctx, id, sqlTableAccess)
-}
-
-func (s *FositeSQLStore) revokeSession(ctx context.Context, id string, table tableName) error {
-	db := s.db(ctx)
-	/* #nosec G201 - table is a const enum */
-	if _, err := db.ExecContext(ctx, db.Rebind(fmt.Sprintf("DELETE FROM hydra_oauth2_%s WHERE request_id=?", table)), id); err == sql.ErrNoRows {
-		return errors.Wrap(fosite.ErrNotFound, "")
-	} else if err := sqlcon.HandleError(err); err != nil {
-		switch errCause := errors.Cause(err).(type) {
-		case *herodot.DefaultError:
-			if errCause == sqlcon.ErrConcurrentUpdate {
-				return errors.Wrap(fosite.ErrSerializationFailure, err.Error())
-			}
-		}
-		return err
-	}
-	return nil
-}
-
-func (s *FositeSQLStore) FlushInactiveAccessTokens(ctx context.Context, notAfter time.Time) error {
-	if _, err := s.DB.ExecContext(ctx, s.DB.Rebind(fmt.Sprintf("DELETE FROM hydra_oauth2_%s WHERE requested_at < ? AND requested_at < ?", sqlTableAccess)), time.Now().Add(-s.c.AccessTokenLifespan()), notAfter); err == sql.ErrNoRows {
-		return errors.Wrap(fosite.ErrNotFound, "")
-	} else if err != nil {
-		return sqlcon.HandleError(err)
-	}
-
-	return nil
-}
-
-func (s *FositeSQLStore) BeginTX(ctx context.Context) (context.Context, error) {
-	if tx, err := s.DB.BeginTxx(ctx, &sql.TxOptions{
-		Isolation: sql.LevelRepeatableRead,
-		ReadOnly:  false,
-	}); err != nil {
-		return ctx, err
-	} else {
-		return context.WithValue(ctx, txKey, tx), nil
-	}
-}
-
-func (s *FositeSQLStore) Commit(ctx context.Context) error {
-	if tx, ok := ctx.Value(txKey).(*sqlx.Tx); !ok {
-		return errors.Wrap(fosite.ErrServerError, "commit failed: no transaction stored in context")
-	} else {
-		if err := sqlcon.HandleError(tx.Commit()); err != nil {
-			switch errCause := errors.Cause(err).(type) {
-			case *herodot.DefaultError:
-				if errCause == sqlcon.ErrConcurrentUpdate {
-					return errors.Wrap(fosite.ErrSerializationFailure, err.Error())
-				}
-			}
-			return err
-		}
-		return nil
-	}
-}
-
-func (s *FositeSQLStore) Rollback(ctx context.Context) error {
-	if tx, ok := ctx.Value(txKey).(*sqlx.Tx); !ok {
-		return errors.Wrap(fosite.ErrServerError, "rollback failed: no transaction stored in context")
-	} else {
-		return tx.Rollback()
-	}
-}
-
-func (s *FositeSQLStore) DeleteAccessTokens(ctx context.Context, clientID string) error {
-	if _, err := s.DB.ExecContext(ctx, s.DB.Rebind(fmt.Sprintf("DELETE FROM hydra_oauth2_%s WHERE client_id=?", sqlTableAccess)), clientID); err == sql.ErrNoRows {
-		return errors.Wrap(fosite.ErrNotFound, "")
-	} else if err != nil {
-		return sqlcon.HandleError(err)
-	}
-
-	return nil
-}
diff --git a/oauth2/fosite_store_test.go b/oauth2/fosite_store_test.go
index c571ccdd7..712d379ad 100644
--- a/oauth2/fosite_store_test.go
+++ b/oauth2/fosite_store_test.go
@@ -45,8 +45,8 @@ func TestMain(m *testing.M) {
 }
 
 var registries = make(map[string]driver.Registry)
-var cleanRegistries = func(*testing.T) {
-	registries["memory"] = internal.NewRegistryMemory(internal.NewConfigurationWithDefaults())
+var cleanRegistries = func(t *testing.T) {
+	registries["memory"] = internal.NewRegistryMemory(t, internal.NewConfigurationWithDefaults())
 }
 
 // returns clean registries that can safely be used for one test
diff --git a/oauth2/handler.go b/oauth2/handler.go
index e1639cf8b..d6594ca41 100644
--- a/oauth2/handler.go
+++ b/oauth2/handler.go
@@ -676,7 +676,7 @@ func (h *Handler) AuthHandler(w http.ResponseWriter, r *http.Request, _ httprout
 		}
 	}
 
-	authorizeRequest.SetID(session.Challenge)
+	authorizeRequest.SetID(session.ID)
 
 	claims := &jwt.IDTokenClaims{
 		Subject:                             session.ConsentRequest.SubjectIdentifier,
@@ -708,7 +708,7 @@ func (h *Handler) AuthHandler(w http.ResponseWriter, r *http.Request, _ httprout
 		Extra:            session.Session.AccessToken,
 		KID:              accessTokenKeyID,
 		ClientID:         authorizeRequest.GetClient().GetID(),
-		ConsentChallenge: session.Challenge,
+		ConsentChallenge: session.ID,
 	})
 	if err != nil {
 		x.LogError(r, err, h.r.Logger())
diff --git a/oauth2/handler_fallback_endpoints_test.go b/oauth2/handler_fallback_endpoints_test.go
index 4ac25ca77..1d247016e 100644
--- a/oauth2/handler_fallback_endpoints_test.go
+++ b/oauth2/handler_fallback_endpoints_test.go
@@ -40,7 +40,7 @@ import (
 func TestHandlerConsent(t *testing.T) {
 	conf := internal.NewConfigurationWithDefaults()
 	viper.Set(configuration.ViperKeyScopeStrategy, "DEPRECATED_HIERARCHICAL_SCOPE_STRATEGY")
-	reg := internal.NewRegistryMemory(conf)
+	reg := internal.NewRegistryMemory(t, conf)
 
 	h := reg.OAuth2Handler()
 	r := x.NewRouterAdmin()
diff --git a/oauth2/handler_test.go b/oauth2/handler_test.go
index bccf2d041..0fc5cc58c 100644
--- a/oauth2/handler_test.go
+++ b/oauth2/handler_test.go
@@ -94,7 +94,7 @@ var flushRequests = []*fosite.Request{
 func TestHandlerDeleteHandler(t *testing.T) {
 	conf := internal.NewConfigurationWithDefaults()
 	viper.Set(configuration.ViperKeyIssuerURL, "http://hydra.localhost")
-	reg := internal.NewRegistryMemory(conf)
+	reg := internal.NewRegistryMemory(t, conf)
 
 	cm := reg.ClientManager()
 	store := reg.OAuth2Storage()
@@ -110,8 +110,8 @@ func TestHandlerDeleteHandler(t *testing.T) {
 		Form:           url.Values{"foo": []string{"bar", "baz"}},
 		Session:        &oauth2.Session{DefaultSession: &openid.DefaultSession{Subject: "bar"}},
 	}
-	require.NoError(t, store.CreateAccessTokenSession(nil, deleteRequest.ID, deleteRequest))
-	_ = cm.CreateClient(nil, deleteRequest.Client.(*client.Client))
+	require.NoError(t, cm.CreateClient(context.Background(), deleteRequest.Client.(*client.Client)))
+	require.NoError(t, store.CreateAccessTokenSession(context.Background(), deleteRequest.ID, deleteRequest))
 
 	r := x.NewRouterAdmin()
 	h.SetRoutes(r, r.RouterPublic(), func(h http.Handler) http.Handler {
@@ -134,15 +134,15 @@ func TestHandlerFlushHandler(t *testing.T) {
 	conf := internal.NewConfigurationWithDefaults()
 	viper.Set(configuration.ViperKeyScopeStrategy, "DEPRECATED_HIERARCHICAL_SCOPE_STRATEGY")
 	viper.Set(configuration.ViperKeyIssuerURL, "http://hydra.localhost")
-	reg := internal.NewRegistryMemory(conf)
+	reg := internal.NewRegistryMemory(t, conf)
 
 	cl := reg.ClientManager()
 	store := reg.OAuth2Storage()
 
 	h := oauth2.NewHandler(reg, conf)
 	for _, r := range flushRequests {
-		require.NoError(t, store.CreateAccessTokenSession(nil, r.ID, r))
-		_ = cl.CreateClient(nil, r.Client.(*client.Client))
+		_ = cl.CreateClient(context.Background(), r.Client.(*client.Client))
+		require.NoError(t, store.CreateAccessTokenSession(context.Background(), r.ID, r))
 	}
 
 	r := x.NewRouterAdmin()
@@ -192,7 +192,7 @@ func TestUserinfo(t *testing.T) {
 	viper.Set(configuration.ViperKeyScopeStrategy, "")
 	viper.Set(configuration.ViperKeyAuthCodeLifespan, lifespan)
 	viper.Set(configuration.ViperKeyIssuerURL, "http://hydra.localhost")
-	reg := internal.NewRegistryMemory(conf)
+	reg := internal.NewRegistryMemory(t, conf)
 	internal.MustEnsureRegistryKeys(reg, x.OpenIDConnectKeyName)
 
 	ctrl := gomock.NewController(t)
@@ -430,7 +430,7 @@ func TestHandlerWellKnown(t *testing.T) {
 	viper.Set(configuration.ViperKeyOIDCDiscoverySupportedClaims, []string{"sub"})
 	viper.Set(configuration.ViperKeyOAuth2ClientRegistrationURL, "http://client-register/registration")
 	viper.Set(configuration.ViperKeyOIDCDiscoveryUserinfoEndpoint, "/userinfo")
-	reg := internal.NewRegistryMemory(conf)
+	reg := internal.NewRegistryMemory(t, conf)
 
 	h := oauth2.NewHandler(reg, conf)
 
diff --git a/oauth2/introspector_test.go b/oauth2/introspector_test.go
index 60f548753..61d97a8e9 100644
--- a/oauth2/introspector_test.go
+++ b/oauth2/introspector_test.go
@@ -54,7 +54,7 @@ func TestIntrospectorSDK(t *testing.T) {
 	conf := internal.NewConfigurationWithDefaults()
 	viper.Set(configuration.ViperKeyScopeStrategy, "wildcard")
 	viper.Set(configuration.ViperKeyIssuerURL, "foobariss")
-	reg := internal.NewRegistryMemory(conf)
+	reg := internal.NewRegistryMemory(t, conf)
 
 	internal.MustEnsureRegistryKeys(reg, x.OpenIDConnectKeyName)
 	internal.AddFositeExamples(reg)
diff --git a/oauth2/oauth2_auth_code_test.go b/oauth2/oauth2_auth_code_test.go
index 712286d53..97c237cfd 100644
--- a/oauth2/oauth2_auth_code_test.go
+++ b/oauth2/oauth2_auth_code_test.go
@@ -165,11 +165,11 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 					var m sync.Mutex
 					l := logrus.New()
 					l.Level = logrus.DebugLevel
-					var lph, cph func(w http.ResponseWriter, r *http.Request)
-					lp := mockProvider(&lph)
-					defer lp.Close()
-					cp := mockProvider(&cph)
-					defer lp.Close()
+					var loginProviderHandler, consentProviderHandler func(w http.ResponseWriter, r *http.Request)
+					loginProvider := mockProvider(&loginProviderHandler)
+					defer loginProvider.Close()
+					consentProvider := mockProvider(&consentProviderHandler)
+					defer consentProvider.Close()
 
 					fooUserIDToken, _, err := reg.OpenIDJWTStrategy().Generate(context.TODO(), jwt.IDTokenClaims{
 						Subject:   "foouser",
@@ -195,8 +195,8 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 					api := httptest.NewServer(apiRouter)
 					defer api.Close()
 
-					viper.Set(configuration.ViperKeyLoginURL, lp.URL)
-					viper.Set(configuration.ViperKeyConsentURL, cp.URL)
+					viper.Set(configuration.ViperKeyLoginURL, loginProvider.URL)
+					viper.Set(configuration.ViperKeyConsentURL, consentProvider.URL)
 					viper.Set(configuration.ViperKeyIssuerURL, ts.URL)
 					viper.Set(configuration.ViperKeyConsentRequestMaxAge, time.Hour)
 
@@ -213,37 +213,37 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 						RedirectURL: client.RedirectURIs[0], Scopes: []string{"hydra", "offline", "openid"},
 					}
 
-					require.NoError(t, reg.OAuth2Storage().(clientCreator).CreateClient(context.TODO(), &client))
+					require.NoError(t, reg.ClientManager().CreateClient(context.Background(), &client))
 					apiClient := hydra.NewHTTPClientWithConfig(nil, &hydra.TransportConfig{Schemes: []string{"http"}, Host: urlx.ParseOrPanic(api.URL).Host})
 
 					persistentCJ := newCookieJar()
 					var code string
 					for k, tc := range []struct {
-						authURL               string
-						cj                    http.CookieJar
-						d                     string
-						cb                    func(t *testing.T) httprouter.Handle
-						expectOAuthAuthError  bool
-						expectOAuthTokenError bool
-						lph, cph              func(t *testing.T) func(w http.ResponseWriter, r *http.Request)
-						setup                 func()
-						expectRefreshToken    bool
-						expectIDToken         bool
+						authURL                                      string
+						cookieJar                                    http.CookieJar
+						desc                                         string
+						callbackHandler                              func(t *testing.T) httprouter.Handle
+						expectOAuthAuthError                         bool
+						expectOAuthTokenError                        bool
+						loginProviderHandler, consentProviderHandler func(t *testing.T) func(w http.ResponseWriter, r *http.Request)
+						setup                                        func()
+						expectRefreshToken                           bool
+						expectIDToken                                bool
 
 						assertAccessToken, assertIDToken func(*testing.T, string)
 						assertRefreshToken               func(*testing.T, *oauth2.Token)
 					}{
 						{
-							d:       "Checks if request fails when audience doesn't match",
-							authURL: oauthConfig.AuthCodeURL("some-hardcoded-state", oauth2.SetAuthURLParam("audience", "https://not-ory-api/")),
-							cj:      newCookieJar(),
-							lph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							desc:      "Checks if request fails when audience doesn't match",
+							authURL:   oauthConfig.AuthCodeURL("some-hardcoded-state", oauth2.SetAuthURLParam("audience", "https://not-ory-api/")),
+							cookieJar: newCookieJar(),
+							loginProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) { t.Fatal("This should not have been called") }
 							},
-							cph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							consentProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) { t.Fatal("This should not have been called") }
 							},
-							cb: func(t *testing.T) httprouter.Handle {
+							callbackHandler: func(t *testing.T) httprouter.Handle {
 								return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
 									code = r.URL.Query().Get("code")
 									require.Empty(t, code)
@@ -259,10 +259,10 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 							},
 						},
 						{
-							d:       "Perform OAuth2 flow with openid connect id token and verify the id token",
-							authURL: oauthConfig.AuthCodeURL("some-hardcoded-state", oauth2.SetAuthURLParam("nonce", "what-a-cool-nonce")),
-							cj:      newCookieJar(),
-							lph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							desc:      "Perform OAuth2 flow with openid connect id token and verify the id token",
+							authURL:   oauthConfig.AuthCodeURL("some-hardcoded-state", oauth2.SetAuthURLParam("nonce", "what-a-cool-nonce")),
+							cookieJar: newCookieJar(),
+							loginProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									rr, err := apiClient.Admin.GetLoginRequest(admin.NewGetLoginRequestParams().WithLoginChallenge(r.URL.Query().Get("login_challenge")))
 									require.NoError(t, err)
@@ -279,7 +279,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.Payload.RedirectTo, http.StatusFound)
 								}
 							},
-							cph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							consentProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									rr, err := apiClient.Admin.GetConsentRequest(admin.NewGetConsentRequestParams().WithConsentChallenge(r.URL.Query().Get("consent_challenge")))
 									require.NoError(t, err)
@@ -300,7 +300,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.Payload.RedirectTo, http.StatusFound)
 								}
 							},
-							cb: func(t *testing.T) httprouter.Handle {
+							callbackHandler: func(t *testing.T) httprouter.Handle {
 								return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
 									code = r.URL.Query().Get("code")
 									assert.NotEmpty(t, code, "%s", r.URL.String())
@@ -327,10 +327,10 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 							},
 						},
 						{
-							d:       "Perform OAuth2 flow with refreshing which fails due to expiry",
-							authURL: oauthConfig.AuthCodeURL("some-hardcoded-state", oauth2.SetAuthURLParam("nonce", "what-a-cool-nonce")),
-							cj:      newCookieJar(),
-							lph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							desc:      "Perform OAuth2 flow with refreshing which fails due to expiry",
+							authURL:   oauthConfig.AuthCodeURL("some-hardcoded-state", oauth2.SetAuthURLParam("nonce", "what-a-cool-nonce")),
+							cookieJar: newCookieJar(),
+							loginProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									_, err := apiClient.Admin.GetLoginRequest(admin.NewGetLoginRequestParams().WithLoginChallenge(r.URL.Query().Get("login_challenge")))
 									require.NoError(t, err)
@@ -344,7 +344,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.Payload.RedirectTo, http.StatusFound)
 								}
 							},
-							cph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							consentProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									rrr, err := apiClient.Admin.GetConsentRequest(admin.NewGetConsentRequestParams().WithConsentChallenge(r.URL.Query().Get("consent_challenge")))
 									require.NoError(t, err)
@@ -364,7 +364,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.RedirectTo, http.StatusFound)
 								}
 							},
-							cb: func(t *testing.T) httprouter.Handle {
+							callbackHandler: func(t *testing.T) httprouter.Handle {
 								return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
 									code = r.URL.Query().Get("code")
 									require.NotEmpty(t, code)
@@ -382,10 +382,10 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 								require.Error(t, err)
 							},
 						}, {
-							d:       "Checks if request fails when subject is empty",
-							authURL: oauthConfig.AuthCodeURL("some-hardcoded-state", oauth2.SetAuthURLParam("audience", "https://not-ory-api/")),
-							cj:      newCookieJar(),
-							lph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							desc:      "Checks if request fails when subject is empty",
+							authURL:   oauthConfig.AuthCodeURL("some-hardcoded-state", oauth2.SetAuthURLParam("audience", "https://not-ory-api/")),
+							cookieJar: newCookieJar(),
+							loginProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									challenge, err := apiClient.Admin.GetLoginRequest(admin.NewGetLoginRequestParams().WithLoginChallenge(r.URL.Query().Get("login_challenge")))
 									require.NoError(t, err)
@@ -401,10 +401,10 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.Payload.RedirectTo, http.StatusFound)
 								}
 							},
-							cph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							consentProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) { t.Fatal("This should not have been called") }
 							},
-							cb: func(t *testing.T) httprouter.Handle {
+							callbackHandler: func(t *testing.T) httprouter.Handle {
 								return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
 									code = r.URL.Query().Get("code")
 									require.Empty(t, code)
@@ -420,10 +420,10 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 							},
 						},
 						{
-							d:       "Perform OAuth2 flow with refreshing which works just fine",
-							authURL: oauthConfig.AuthCodeURL("some-hardcoded-state", oauth2.SetAuthURLParam("nonce", "what-a-cool-nonce")),
-							cj:      newCookieJar(),
-							lph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							desc:      "Perform OAuth2 flow with refreshing which works just fine",
+							authURL:   oauthConfig.AuthCodeURL("some-hardcoded-state", oauth2.SetAuthURLParam("nonce", "what-a-cool-nonce")),
+							cookieJar: newCookieJar(),
+							loginProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									_, err := apiClient.Admin.GetLoginRequest(admin.NewGetLoginRequestParams().WithLoginChallenge(r.URL.Query().Get("login_challenge")))
 									require.NoError(t, err)
@@ -439,7 +439,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.Payload.RedirectTo, http.StatusFound)
 								}
 							},
-							cph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							consentProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									rrr, err := apiClient.Admin.GetConsentRequest(admin.NewGetConsentRequestParams().WithConsentChallenge(r.URL.Query().Get("consent_challenge")))
 									require.NoError(t, err)
@@ -459,7 +459,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.RedirectTo, http.StatusFound)
 								}
 							},
-							cb: func(t *testing.T) httprouter.Handle {
+							callbackHandler: func(t *testing.T) httprouter.Handle {
 								return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
 									code = r.URL.Query().Get("code")
 									require.NotEmpty(t, code)
@@ -479,10 +479,10 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 							},
 						},
 						{
-							d:       "Perform OAuth2 flow with audience",
-							authURL: oauthConfig.AuthCodeURL("some-hardcoded-state", oauth2.SetAuthURLParam("audience", "https://api.ory.sh/")),
-							cj:      newCookieJar(),
-							lph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							desc:      "Perform OAuth2 flow with audience",
+							authURL:   oauthConfig.AuthCodeURL("some-hardcoded-state", oauth2.SetAuthURLParam("audience", "https://api.ory.sh/")),
+							cookieJar: newCookieJar(),
+							loginProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									rrr, err := apiClient.Admin.GetLoginRequest(admin.NewGetLoginRequestParams().WithLoginChallenge(r.URL.Query().Get("login_challenge")))
 									require.NoError(t, err)
@@ -511,13 +511,15 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.Payload.RedirectTo, http.StatusFound)
 								}
 							},
-							cph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							consentProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
-									rrr, err := apiClient.Admin.GetConsentRequest(admin.NewGetConsentRequestParams().WithConsentChallenge(r.URL.Query().Get("consent_challenge")))
+									challenge := r.URL.Query().Get("consent_challenge")
+									t.Logf("\n\n%s\n\n", r.URL)
+									rrr, err := apiClient.Admin.GetConsentRequest(admin.NewGetConsentRequestParams().WithConsentChallenge(challenge))
 									require.NoError(t, err)
 
 									rr := rrr.Payload
-									assert.True(t, rr.Skip)
+									assert.True(t, rr.Skip, "%+v", rr)
 									assert.EqualValues(t, "user-a", rr.Subject)
 									assert.EqualValues(t, client.GetID(), rr.Client.ClientID)
 									assert.EqualValues(t, client.GrantTypes, rr.Client.GrantTypes)
@@ -545,7 +547,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.RedirectTo, http.StatusFound)
 								}
 							},
-							cb: func(t *testing.T) httprouter.Handle {
+							callbackHandler: func(t *testing.T) httprouter.Handle {
 								return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
 									code = r.URL.Query().Get("code")
 									require.NotEmpty(t, code)
@@ -597,10 +599,10 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 						{
 							// First we need to create a persistent session in order to check if the other things work
 							// as expected
-							d:       "Creates a persisting session for the next test cases",
-							authURL: oauthConfig.AuthCodeURL("some-hardcoded-state") + "&prompt=login+consent&max_age=1",
-							cj:      persistentCJ,
-							lph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							desc:      "Creates a persisting session for the next test cases",
+							authURL:   oauthConfig.AuthCodeURL("some-hardcoded-state") + "&prompt=login+consent&max_age=1",
+							cookieJar: persistentCJ,
+							loginProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									rrr, err := apiClient.Admin.GetLoginRequest(admin.NewGetLoginRequestParams().WithLoginChallenge(r.URL.Query().Get("login_challenge")))
 									require.NoError(t, err)
@@ -628,7 +630,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.RedirectTo, http.StatusFound)
 								}
 							},
-							cph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							consentProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									rrr, err := apiClient.Admin.GetConsentRequest(admin.NewGetConsentRequestParams().WithConsentChallenge(r.URL.Query().Get("consent_challenge")))
 									require.NoError(t, err)
@@ -660,7 +662,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.RedirectTo, http.StatusFound)
 								}
 							},
-							cb: func(t *testing.T) httprouter.Handle {
+							callbackHandler: func(t *testing.T) httprouter.Handle {
 								return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
 									code = r.URL.Query().Get("code")
 									require.NotEmpty(t, code)
@@ -695,17 +697,17 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 							},
 						},
 						{
-							d: "checks if authenticatedAt/requestedAt is properly forwarded across the lifecycle by checking if prompt=none works",
+							desc: "checks if authenticatedAt/requestedAt is properly forwarded across the lifecycle by checking if prompt=none works",
 							setup: func() {
 								// In order to check if authenticatedAt/requestedAt works, we'll sleep first in order to ensure that authenticatedAt is in the past
 								// if handled correctly.
 								time.Sleep(time.Second + time.Millisecond)
 							},
-							authURL: oauthConfig.AuthCodeURL("some-hardcoded-state") + "&prompt=none&max_age=60",
-							cj:      persistentCJ,
-							lph:     acceptLogin(apiClient, "user-a", true, "user-a"),
-							cph:     acceptConsent(apiClient, []string{"hydra", "offline"}, true, "user-a"),
-							cb: func(t *testing.T) httprouter.Handle {
+							authURL:                oauthConfig.AuthCodeURL("some-hardcoded-state") + "&prompt=none&max_age=60",
+							cookieJar:              persistentCJ,
+							loginProviderHandler:   acceptLogin(apiClient, "user-a", true, "user-a"),
+							consentProviderHandler: acceptConsent(apiClient, []string{"hydra", "offline"}, true, "user-a"),
+							callbackHandler: func(t *testing.T) httprouter.Handle {
 								return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
 									code = r.URL.Query().Get("code")
 									require.NotEmpty(t, code)
@@ -755,22 +757,22 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 							},
 						},
 						{
-							d:                     "checks if prompt=none fails when no session is set",
+							desc:                  "checks if prompt=none fails when no session is set",
 							authURL:               oauthConfig.AuthCodeURL("some-hardcoded-state") + "&prompt=none",
-							cj:                    newCookieJar(),
+							cookieJar:             newCookieJar(),
 							expectOAuthAuthError:  true,
 							expectOAuthTokenError: false,
 						},
 						{
-							d:                     "checks if consecutive authentications cause any issues (1/3)",
-							authURL:               oauthConfig.AuthCodeURL("some-hardcoded-state") + "&prompt=none&max_age=60",
-							cj:                    persistentCJ,
-							lph:                   acceptLogin(apiClient, "user-a", true, "user-a"),
-							cph:                   acceptConsent(apiClient, []string{"hydra", "offline"}, true, "user-a"),
-							expectOAuthAuthError:  false,
-							expectOAuthTokenError: false,
-							expectRefreshToken:    true,
-							cb: func(t *testing.T) httprouter.Handle {
+							desc:                   "checks if consecutive authentications cause any issues (1/3)",
+							authURL:                oauthConfig.AuthCodeURL("some-hardcoded-state") + "&prompt=none&max_age=60",
+							cookieJar:              persistentCJ,
+							loginProviderHandler:   acceptLogin(apiClient, "user-a", true, "user-a"),
+							consentProviderHandler: acceptConsent(apiClient, []string{"hydra", "offline"}, true, "user-a"),
+							expectOAuthAuthError:   false,
+							expectOAuthTokenError:  false,
+							expectRefreshToken:     true,
+							callbackHandler: func(t *testing.T) httprouter.Handle {
 								return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
 									code = r.URL.Query().Get("code")
 									require.NotEmpty(t, code)
@@ -779,15 +781,15 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 							},
 						},
 						{
-							d:                     "checks if consecutive authentications cause any issues (2/3)",
-							authURL:               oauthConfig.AuthCodeURL("some-hardcoded-state") + "&prompt=none&max_age=60",
-							cj:                    persistentCJ,
-							lph:                   acceptLogin(apiClient, "user-a", true, "user-a"),
-							cph:                   acceptConsent(apiClient, []string{"hydra", "offline"}, true, "user-a"),
-							expectOAuthAuthError:  false,
-							expectOAuthTokenError: false,
-							expectRefreshToken:    true,
-							cb: func(t *testing.T) httprouter.Handle {
+							desc:                   "checks if consecutive authentications cause any issues (2/3)",
+							authURL:                oauthConfig.AuthCodeURL("some-hardcoded-state") + "&prompt=none&max_age=60",
+							cookieJar:              persistentCJ,
+							loginProviderHandler:   acceptLogin(apiClient, "user-a", true, "user-a"),
+							consentProviderHandler: acceptConsent(apiClient, []string{"hydra", "offline"}, true, "user-a"),
+							expectOAuthAuthError:   false,
+							expectOAuthTokenError:  false,
+							expectRefreshToken:     true,
+							callbackHandler: func(t *testing.T) httprouter.Handle {
 								return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
 									code = r.URL.Query().Get("code")
 									require.NotEmpty(t, code)
@@ -796,15 +798,15 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 							},
 						},
 						{
-							d:                     "checks if consecutive authentications cause any issues (3/3)",
-							authURL:               oauthConfig.AuthCodeURL("some-hardcoded-state") + "&prompt=none&max_age=60",
-							cj:                    persistentCJ,
-							lph:                   acceptLogin(apiClient, "user-a", true, "user-a"),
-							cph:                   acceptConsent(apiClient, []string{"hydra", "offline"}, true, "user-a"),
-							expectOAuthAuthError:  false,
-							expectOAuthTokenError: false,
-							expectRefreshToken:    true,
-							cb: func(t *testing.T) httprouter.Handle {
+							desc:                   "checks if consecutive authentications cause any issues (3/3)",
+							authURL:                oauthConfig.AuthCodeURL("some-hardcoded-state") + "&prompt=none&max_age=60",
+							cookieJar:              persistentCJ,
+							loginProviderHandler:   acceptLogin(apiClient, "user-a", true, "user-a"),
+							consentProviderHandler: acceptConsent(apiClient, []string{"hydra", "offline"}, true, "user-a"),
+							expectOAuthAuthError:   false,
+							expectOAuthTokenError:  false,
+							expectRefreshToken:     true,
+							callbackHandler: func(t *testing.T) httprouter.Handle {
 								return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
 									code = r.URL.Query().Get("code")
 									require.NotEmpty(t, code)
@@ -813,17 +815,17 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 							},
 						},
 						{
-							d:                     "checks if authenticatedAt/requestedAt is properly forwarded across the lifecycle by checking if prompt=none fails when maxAge is reached",
+							desc:                  "checks if authenticatedAt/requestedAt is properly forwarded across the lifecycle by checking if prompt=none fails when maxAge is reached",
 							authURL:               oauthConfig.AuthCodeURL("some-hardcoded-state") + "&prompt=none&max_age=1",
-							cj:                    persistentCJ,
+							cookieJar:             persistentCJ,
 							expectOAuthAuthError:  true,
 							expectOAuthTokenError: false,
 						},
 						{
-							d:       "checks if authenticatedAt/requestedAt is properly forwarded across the lifecycle by checking if prompt=login works",
-							authURL: oauthConfig.AuthCodeURL("some-hardcoded-state") + "&prompt=login",
-							cj:      persistentCJ,
-							lph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							desc:      "checks if authenticatedAt/requestedAt is properly forwarded across the lifecycle by checking if prompt=login works",
+							authURL:   oauthConfig.AuthCodeURL("some-hardcoded-state") + "&prompt=login",
+							cookieJar: persistentCJ,
+							loginProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									rrr, err := apiClient.Admin.GetLoginRequest(admin.NewGetLoginRequestParams().WithLoginChallenge(r.URL.Query().Get("login_challenge")))
 									require.NoError(t, err)
@@ -844,7 +846,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.RedirectTo, http.StatusFound)
 								}
 							},
-							cph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							consentProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									rrr, err := apiClient.Admin.GetConsentRequest(admin.NewGetConsentRequestParams().WithConsentChallenge(r.URL.Query().Get("consent_challenge")))
 									require.NoError(t, err)
@@ -869,7 +871,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.RedirectTo, http.StatusFound)
 								}
 							},
-							cb: func(t *testing.T) httprouter.Handle {
+							callbackHandler: func(t *testing.T) httprouter.Handle {
 								return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
 									code = r.URL.Query().Get("code")
 									require.NotEmpty(t, code)
@@ -882,10 +884,10 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 							expectRefreshToken:    false,
 						},
 						{
-							d:       "requires re-authentication when id_token_hint is set to a user (\"foouser\") but the session is \"user-a\" and it also fails because the user id from the log in endpoint is not foouser",
-							authURL: oauthConfig.AuthCodeURL("some-hardcoded-state") + "&id_token_hint=" + fooUserIDToken,
-							cj:      persistentCJ,
-							lph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							desc:      "requires re-authentication when id_token_hint is set to a user (\"foouser\") but the session is \"user-a\" and it also fails because the user id from the log in endpoint is not foouser",
+							authURL:   oauthConfig.AuthCodeURL("some-hardcoded-state") + "&id_token_hint=" + fooUserIDToken,
+							cookieJar: persistentCJ,
+							loginProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									rrr, err := apiClient.Admin.GetLoginRequest(admin.NewGetLoginRequestParams().WithLoginChallenge(r.URL.Query().Get("login_challenge")))
 									require.NoError(t, err)
@@ -907,7 +909,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.RedirectTo, http.StatusFound)
 								}
 							},
-							cph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							consentProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									rrr, err := apiClient.Admin.GetConsentRequest(admin.NewGetConsentRequestParams().WithConsentChallenge(r.URL.Query().Get("consent_challenge")))
 									require.NoError(t, err)
@@ -932,7 +934,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.RedirectTo, http.StatusFound)
 								}
 							},
-							cb: func(t *testing.T) httprouter.Handle {
+							callbackHandler: func(t *testing.T) httprouter.Handle {
 								return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
 									code = r.URL.Query().Get("code")
 									require.Empty(t, code)
@@ -968,10 +970,10 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 							},
 						},
 						{
-							d:       "should not cause issues if max_age is very low and consent takes a long time",
+							desc:    "should not cause issues if max_age is very low and consent takes a long time",
 							authURL: oauthConfig.AuthCodeURL("some-hardcoded-state") + "&max_age=1",
-							// cj:      persistentCJ,
-							lph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							// cookieJar:      persistentCJ,
+							loginProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									_, err := apiClient.Admin.GetLoginRequest(admin.NewGetLoginRequestParams().WithLoginChallenge(r.URL.Query().Get("login_challenge")))
 									require.NoError(t, err)
@@ -990,7 +992,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.RedirectTo, http.StatusFound)
 								}
 							},
-							cph: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
+							consentProviderHandler: func(t *testing.T) func(w http.ResponseWriter, r *http.Request) {
 								return func(w http.ResponseWriter, r *http.Request) {
 									_, err := apiClient.Admin.GetConsentRequest(admin.NewGetConsentRequestParams().WithConsentChallenge(r.URL.Query().Get("consent_challenge")))
 									require.NoError(t, err)
@@ -1011,7 +1013,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 									http.Redirect(w, r, *v.RedirectTo, http.StatusFound)
 								}
 							},
-							cb: func(t *testing.T) httprouter.Handle {
+							callbackHandler: func(t *testing.T) httprouter.Handle {
 								return func(w http.ResponseWriter, r *http.Request, _ httprouter.Params) {
 									code = r.URL.Query().Get("code")
 									require.NotEmpty(t, code)
@@ -1024,7 +1026,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 							expectRefreshToken:    false,
 						},
 					} {
-						t.Run(fmt.Sprintf("case=%d/description=%s", k, tc.d), func(t *testing.T) {
+						t.Run(fmt.Sprintf("case=%d/description=%s", k, tc.desc), func(t *testing.T) {
 							m.Lock()
 							defer m.Unlock()
 
@@ -1034,37 +1036,37 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 								tc.setup()
 							}
 
-							if tc.lph != nil {
-								lph = tc.lph(t)
+							if tc.loginProviderHandler != nil {
+								loginProviderHandler = tc.loginProviderHandler(t)
 							} else {
-								lph = noopHandlerDefaultStrategy(t)
+								loginProviderHandler = noopHandlerDefaultStrategy(t)
 							}
 
-							if tc.cph != nil {
-								cph = tc.cph(t)
+							if tc.consentProviderHandler != nil {
+								consentProviderHandler = tc.consentProviderHandler(t)
 							} else {
-								cph = noopHandlerDefaultStrategy(t)
+								consentProviderHandler = noopHandlerDefaultStrategy(t)
 							}
 
-							if tc.cb == nil {
-								tc.cb = noopHandler
+							if tc.callbackHandler == nil {
+								tc.callbackHandler = noopHandler
 							}
 
-							cb := tc.cb(t)
+							cb := tc.callbackHandler(t)
 							callbackHandler = &cb
 
 							req, err := http.NewRequest("GET", tc.authURL, nil)
 							require.NoError(t, err)
 
-							if tc.cj == nil {
-								tc.cj = newCookieJar()
+							if tc.cookieJar == nil {
+								tc.cookieJar = newCookieJar()
 							}
 
-							resp, err := (&http.Client{Jar: tc.cj}).Do(req)
+							resp, err := (&http.Client{Jar: tc.cookieJar}).Do(req)
 							require.NoError(t, err)
 							defer resp.Body.Close()
 
-							t.Logf("Cookies: %+v", tc.cj)
+							t.Logf("Cookies: %+v\nURL: %+v", tc.cookieJar, tc.authURL)
 
 							time.Sleep(time.Millisecond * 5)
 
@@ -1079,7 +1081,7 @@ func TestAuthCodeWithDefaultStrategy(t *testing.T) {
 							}
 							require.NotEmpty(t, code, "body: %s\nreq: %s\nts: %s", body, req.URL.String(), ts.URL)
 
-							token, err := oauthConfig.Exchange(oauth2.NoContext, code)
+							token, err := oauthConfig.Exchange(context.Background(), code)
 
 							if tc.expectOAuthTokenError {
 								require.Error(t, err)
@@ -1132,7 +1134,7 @@ func TestAuthCodeWithMockStrategy(t *testing.T) {
 			viper.Set(configuration.ViperKeyAccessTokenLifespan, time.Second*2)
 			viper.Set(configuration.ViperKeyScopeStrategy, "DEPRECATED_HIERARCHICAL_SCOPE_STRATEGY")
 			viper.Set(configuration.ViperKeyAccessTokenStrategy, strat.d)
-			reg := internal.NewRegistryMemory(conf)
+			reg := internal.NewRegistryMemory(t, conf)
 			internal.MustEnsureRegistryKeys(reg, x.OpenIDConnectKeyName)
 			internal.MustEnsureRegistryKeys(reg, x.OAuth2JWTKeyName)
 
diff --git a/oauth2/oauth2_client_credentials_test.go b/oauth2/oauth2_client_credentials_test.go
index 4a408ddd6..ca5176e01 100644
--- a/oauth2/oauth2_client_credentials_test.go
+++ b/oauth2/oauth2_client_credentials_test.go
@@ -52,7 +52,7 @@ func TestClientCredentials(t *testing.T) {
 			conf := internal.NewConfigurationWithDefaults()
 			viper.Set(configuration.ViperKeyAccessTokenLifespan, time.Second)
 			viper.Set(configuration.ViperKeyAccessTokenStrategy, tc.d)
-			reg := internal.NewRegistryMemory(conf)
+			reg := internal.NewRegistryMemory(t, conf)
 
 			router := x.NewRouterPublic()
 			ts := httptest.NewServer(router)
diff --git a/oauth2/oauth2_refresh_token_test.go b/oauth2/oauth2_refresh_token_test.go
index ac4dcb764..02e16fb0c 100644
--- a/oauth2/oauth2_refresh_token_test.go
+++ b/oauth2/oauth2_refresh_token_test.go
@@ -2,6 +2,7 @@ package oauth2_test
 
 import (
 	"context"
+	"errors"
 	"fmt"
 	"math/rand"
 	"net/url"
@@ -19,7 +20,6 @@ import (
 	"github.com/ory/hydra/driver"
 	"github.com/ory/hydra/oauth2"
 	"github.com/ory/x/dbal"
-	"github.com/ory/x/errorsx"
 )
 
 // TestCreateRefreshTokenSessionStress is a sanity test to verify the fix for https://github.com/ory/hydra/issues/1719 &
@@ -75,13 +75,18 @@ func TestCreateRefreshTokenSessionStress(t *testing.T) {
 	setupRegistries(t)
 
 	for dbName, dbRegistry := range registries {
+		if dbName == "memory" {
+			// todo check why sqlite fails with "no such table: hydra_oauth2_refresh \n sqlite create"
+			// should be fine though as nobody should use sqlite in production
+			continue
+		}
 		ctx, _ := context.WithDeadline(context.Background(), time.Now().Add(30*time.Second))
 		require.NoError(t, dbRegistry.OAuth2Storage().(clientCreator).CreateClient(ctx, &testClient))
 		require.NoError(t, dbRegistry.OAuth2Storage().CreateRefreshTokenSession(ctx, tokenSignature, request))
 		_, err := dbRegistry.OAuth2Storage().GetRefreshTokenSession(ctx, tokenSignature, nil)
 		require.NoError(t, err)
 		provider := dbRegistry.OAuth2Provider()
-		storageVersion := dbVersion(ctx, dbRegistry)
+		storageVersion := dbVersion(t, ctx, dbRegistry)
 
 		var wg sync.WaitGroup
 		for run := 0; run < testRuns; run++ {
@@ -120,9 +125,8 @@ func TestCreateRefreshTokenSessionStress(t *testing.T) {
 			var successCount int
 			for err := range errorsCh {
 				if err != nil {
-					switch cause := errorsx.Cause(err).(type) {
-					case *fosite.RFC6749Error:
-						switch cause.Name {
+					if e := (&fosite.RFC6749Error{}); errors.As(err, &e) {
+						switch e.Name {
 
 						// change logic below when the refresh handler starts returning 'fosite.ErrInvalidRequest' for other reasons.
 						// as of now, this error is only returned due to concurrent transactions competing to refresh using the same token.
@@ -130,7 +134,7 @@ func TestCreateRefreshTokenSessionStress(t *testing.T) {
 						case fosite.ErrInvalidRequest.Name:
 							// the error description copy is defined by RFC 6749 and should not be different regardless of
 							// the underlying transactional aware storage backend used by hydra
-							assert.Equal(t, fosite.ErrInvalidRequest.Description, cause.Description)
+							assert.Equal(t, fosite.ErrInvalidRequest.Description, e.Description)
 							// the database error debug copy will be different depending on the underlying database used
 							switch dbName {
 							case dbal.DriverMySQL:
@@ -143,8 +147,16 @@ func TestCreateRefreshTokenSessionStress(t *testing.T) {
 									// possible if one worker starts the transaction AFTER another worker has successfully
 									// refreshed the token and committed the transaction
 									"not_found",
+									// postgres: duplicate key value violates unique constraint "hydra_oauth2_access_request_id_idx": Unable to insert or update resource because a resource with that value exists already: The request could not be completed due to concurrent access
+									"duplicate key",
+									// cockroach: restart transaction: TransactionRetryWithProtoRefreshError: TransactionRetryError: retry txn (RETRY_WRITE_TOO_OLD - WriteTooOld flag converted to WriteTooOldError): "sql txn" meta={id=7f069400 key=/Table/62/2/"02a55d6e-509b-4d7a-8458-5828b2f831a1"/0 pri=0.00598277 epo=0 ts=1600955431.566576173,2 min=1600955431.566576173,0 seq=6} lock=true stat=PENDING rts=1600955431.566576173,2 wto=false max=1600955431.566576173,0: Unable to serialize access due to a concurrent update in another session: The request could not be completed due to concurrent access
+									"RETRY_WRITE_TOO_OLD",
+									// postgres: pq: deadlock detected
+									"deadlock detected",
+									// postgres: pq: could not serialize access due to concurrent update: Unable to serialize access due to a concurrent update in another session: The request could not be completed due to concurrent access
+									"concurrent update",
 								} {
-									if strings.Contains(cause.Debug, errSubstr) {
+									if strings.Contains(e.Debug, errSubstr) {
 										matched = true
 										break
 									}
@@ -155,13 +167,21 @@ func TestCreateRefreshTokenSessionStress(t *testing.T) {
 									"Error description: %s\n"+
 									"Error debug: %s\n"+
 									"Error hint: %s\n"+
-									"Raw error: %+v",
+									"Raw error: %T %+v\n"+
+									"Raw cause: %T %+v",
 									storageVersion,
-									cause.Description,
-									cause.Debug,
-									cause.Hint,
-									err)
+									e.Description,
+									e.Debug,
+									e.Hint,
+									err, err,
+									e, e)
+							}
+						case fosite.ErrServerError.Name:
+							// this happens when there is an error with the storage
+							if dbName == dbal.DriverCockroachDB && strings.Contains(e.Debug, "RETRY_WRITE_TOO_OLD") {
+								break
 							}
+							fallthrough
 						default:
 							// unfortunately, MySQL does not offer the same behaviour under the "REPEATABLE_READ" isolation
 							// level so we have to relax this assertion just for MySQL for the time being as server_errors
@@ -177,15 +197,15 @@ func TestCreateRefreshTokenSessionStress(t *testing.T) {
 									"Error debug: %s\n"+
 									"Error hint: %s\n"+
 									"Raw error: %+v",
-									cause.Name,
+									e.Name,
 									storageVersion,
-									cause.Description,
-									cause.Debug,
-									cause.Hint,
+									e.Description,
+									e.Debug,
+									e.Hint,
 									err)
 							}
 						}
-					default:
+					} else {
 						t.Errorf("expected underlying error to be of type '*fosite.RFC6749Error', but it was "+
 							"actually of type %T: %+v - DB version: %s", err, err, storageVersion)
 					}
@@ -221,11 +241,20 @@ func TestCreateRefreshTokenSessionStress(t *testing.T) {
 	}
 }
 
-func dbVersion(ctx context.Context, registry driver.Registry) string {
-	var version string
-	if sqlRegistry, ok := registry.(*driver.RegistrySQL); ok {
-		_ = sqlRegistry.DB().QueryRowxContext(ctx, "select version()").Scan(&version)
-		version = fmt.Sprintf("%s-%s", sqlRegistry.DB().DriverName(), version)
+type version struct {
+	Version string `db:"version"`
+}
+
+func dbVersion(t *testing.T, ctx context.Context, registry driver.Registry) string {
+	var v version
+
+	versionFunc := "version()"
+	c := registry.Persister().Connection(ctx)
+	if c.Dialect.Name() == "sqlite3" {
+		versionFunc = "sqlite_version()"
 	}
-	return version
+	/* #nosec G201 - versionFunc is an enum */
+	require.NoError(t, registry.Persister().Connection(ctx).RawQuery(fmt.Sprintf("select %s as version", versionFunc)).First(&v))
+
+	return v.Version
 }
diff --git a/oauth2/revocator_test.go b/oauth2/revocator_test.go
index c947eff9b..f1732f631 100644
--- a/oauth2/revocator_test.go
+++ b/oauth2/revocator_test.go
@@ -21,12 +21,17 @@
 package oauth2_test
 
 import (
+	"context"
 	"fmt"
 	"net/http"
 	"net/http/httptest"
 	"testing"
 	"time"
 
+	"github.com/gobuffalo/pop/v5"
+
+	"github.com/ory/hydra/persistence/sql"
+
 	"github.com/ory/hydra/internal/httpclient/client/public"
 	"github.com/ory/x/urlx"
 
@@ -61,14 +66,20 @@ func createAccessTokenSessionPairwise(subject, client string, token string, expi
 		ar.Session.(*oauth2.Session).Claims.Subject = obfuscated
 	}
 
-	if err := fs.CreateAccessTokenSession(nil, token, ar); err != nil {
+	if err := fs.CreateAccessTokenSession(context.Background(), token, ar); err != nil {
 		panic(err)
 	}
 }
 
+func countAccessTokens(t *testing.T, c *pop.Connection) int {
+	n, err := c.Count(&sql.OAuth2RequestSQL{Table: "access"})
+	require.NoError(t, err)
+	return n
+}
+
 func TestRevoke(t *testing.T) {
 	conf := internal.NewConfigurationWithDefaults()
-	reg := internal.NewRegistryMemory(conf)
+	reg := internal.NewRegistryMemory(t, conf)
 
 	internal.MustEnsureRegistryKeys(reg, x.OpenIDConnectKeyName)
 	internal.AddFositeExamples(reg)
@@ -89,7 +100,7 @@ func TestRevoke(t *testing.T) {
 	createAccessTokenSession("siri", "my-client", tokens[2][0], now.Add(-time.Hour), reg.OAuth2Storage(), nil)
 	createAccessTokenSession("siri", "encoded:client", tokens[3][0], now.Add(-time.Hour), reg.OAuth2Storage(), nil)
 
-	require.Len(t, reg.OAuth2Storage().(*oauth2.FositeMemoryStore).AccessTokens, 4)
+	require.Equal(t, 4, countAccessTokens(t, reg.Persister().Connection(context.Background())))
 
 	client := hydra.NewHTTPClientWithConfig(nil, &hydra.TransportConfig{Schemes: []string{"http"}, Host: urlx.ParseOrPanic(server.URL).Host})
 
@@ -100,20 +111,20 @@ func TestRevoke(t *testing.T) {
 		{
 			token: "invalid",
 			assert: func(t *testing.T) {
-				assert.Len(t, reg.OAuth2Storage().(*oauth2.FositeMemoryStore).AccessTokens, 4)
+				assert.Equal(t, 4, countAccessTokens(t, reg.Persister().Connection(context.Background())))
 			},
 		},
 		{
 			token: tokens[3][1],
 			assert: func(t *testing.T) {
-				assert.Len(t, reg.OAuth2Storage().(*oauth2.FositeMemoryStore).AccessTokens, 4)
+				assert.Equal(t, 4, countAccessTokens(t, reg.Persister().Connection(context.Background())))
 			},
 		},
 		{
 			token: tokens[0][1],
 			assert: func(t *testing.T) {
 				t.Logf("Tried to delete: %s %s", tokens[0][0], tokens[0][1])
-				assert.Len(t, reg.OAuth2Storage().(*oauth2.FositeMemoryStore).AccessTokens, 3)
+				assert.Equal(t, 3, countAccessTokens(t, reg.Persister().Connection(context.Background())))
 			},
 		},
 		{
@@ -122,13 +133,13 @@ func TestRevoke(t *testing.T) {
 		{
 			token: tokens[2][1],
 			assert: func(t *testing.T) {
-				assert.Len(t, reg.OAuth2Storage().(*oauth2.FositeMemoryStore).AccessTokens, 2)
+				assert.Equal(t, 2, countAccessTokens(t, reg.Persister().Connection(context.Background())))
 			},
 		},
 		{
 			token: tokens[1][1],
 			assert: func(t *testing.T) {
-				assert.Len(t, reg.OAuth2Storage().(*oauth2.FositeMemoryStore).AccessTokens, 1)
+				assert.Equal(t, 1, countAccessTokens(t, reg.Persister().Connection(context.Background())))
 			},
 		},
 	} {
diff --git a/persistence/definitions.go b/persistence/definitions.go
index a2b8b92fc..0df8c0390 100644
--- a/persistence/definitions.go
+++ b/persistence/definitions.go
@@ -4,11 +4,21 @@ import (
 	"context"
 	"io"
 
+	"github.com/ory/hydra/client"
+	"github.com/ory/hydra/consent"
+	"github.com/ory/hydra/jwk"
+	"github.com/ory/hydra/x"
+
 	"github.com/gobuffalo/pop/v5"
 )
 
 type (
 	Persister interface {
+		consent.Manager
+		client.Manager
+		x.FositeStorer
+		jwk.Manager
+
 		MigrationStatus(context.Context, io.Writer) error
 		MigrateDown(context.Context, int) error
 		MigrateUp(context.Context) error
diff --git a/persistence/memory/persister.go b/persistence/memory/persister.go
deleted file mode 100644
index 8f5f3d957..000000000
--- a/persistence/memory/persister.go
+++ /dev/null
@@ -1,34 +0,0 @@
-package memory
-
-import (
-	"context"
-	"io"
-
-	"github.com/gobuffalo/pop/v5"
-
-	"github.com/ory/hydra/persistence"
-)
-
-var _ persistence.Persister = new(Persister)
-
-type Persister struct{}
-
-func (*Persister) MigrationStatus(_ context.Context, _ io.Writer) error {
-	return nil
-}
-
-func (*Persister) MigrateDown(_ context.Context, steps int) error {
-	return nil
-}
-
-func (*Persister) MigrateUp(_ context.Context) error {
-	return nil
-}
-
-func (*Persister) PrepareMigration(context.Context) error {
-	return nil
-}
-
-func (*Persister) Connection(_ context.Context) *pop.Connection {
-	return nil
-}
diff --git a/persistence/sql/migratest/assertion_helpers.go b/persistence/sql/migratest/assertion_helpers.go
index 43fb47d9b..f662964ad 100644
--- a/persistence/sql/migratest/assertion_helpers.go
+++ b/persistence/sql/migratest/assertion_helpers.go
@@ -11,6 +11,7 @@ import (
 	"github.com/ory/hydra/consent"
 	"github.com/ory/hydra/jwk"
 	"github.com/ory/hydra/oauth2"
+	sqlPersister "github.com/ory/hydra/persistence/sql"
 	"github.com/ory/x/sqlxx"
 )
 
@@ -104,7 +105,7 @@ func assertEqualForcedObfucscatedLoginSessions(t *testing.T, expected, actual *c
 	assert.Equal(t, expected, actual)
 }
 
-func assertEqualOauth2Data(t *testing.T, expected, actual *oauth2.SQLData) {
+func assertEqualOauth2Data(t *testing.T, expected, actual *sqlPersister.OAuth2RequestSQL) {
 	now := time.Now()
 	expected.RequestedAt = now
 	actual.RequestedAt = now
diff --git a/persistence/sql/migratest/exptected_data.go b/persistence/sql/migratest/exptected_data.go
index af835ffe7..6613355d2 100644
--- a/persistence/sql/migratest/exptected_data.go
+++ b/persistence/sql/migratest/exptected_data.go
@@ -10,6 +10,7 @@ import (
 	"github.com/ory/hydra/consent"
 	"github.com/ory/hydra/jwk"
 	"github.com/ory/hydra/oauth2"
+	sqlPersister "github.com/ory/hydra/persistence/sql"
 	"github.com/ory/hydra/x"
 	"github.com/ory/x/sqlxx"
 )
@@ -87,7 +88,7 @@ func expectedClient(i int) *client.Client {
 
 func expectedJWK(i int) *jwk.SQLData {
 	return &jwk.SQLData{
-		PK:      i,
+		ID:      i,
 		Set:     fmt.Sprintf("sid-%04d", i),
 		KID:     fmt.Sprintf("kid-%04d", i),
 		Version: i,
@@ -97,7 +98,7 @@ func expectedJWK(i int) *jwk.SQLData {
 
 func expectedConsent(i int) (*consent.ConsentRequest, *consent.LoginRequest, *consent.LoginSession, *consent.HandledConsentRequest, *consent.HandledLoginRequest, *consent.ForcedObfuscatedLoginSession, *consent.LogoutRequest) {
 	cr := &consent.ConsentRequest{
-		Challenge:              fmt.Sprintf("challenge-%04d", i),
+		ID:                     fmt.Sprintf("challenge-%04d", i),
 		RequestedScope:         sqlxx.StringSlicePipeDelimiter{fmt.Sprintf("requested_scope-%04d_1", i)},
 		RequestedAudience:      sqlxx.StringSlicePipeDelimiter{fmt.Sprintf("requested_audience-%04d_1", i)},
 		Skip:                   true,
@@ -114,7 +115,7 @@ func expectedConsent(i int) (*consent.ConsentRequest, *consent.LoginRequest, *co
 		WasHandled:             true,
 	}
 	lr := &consent.LoginRequest{
-		Challenge:            fmt.Sprintf("challenge-%04d", i),
+		ID:                   fmt.Sprintf("challenge-%04d", i),
 		RequestedScope:       sqlxx.StringSlicePipeDelimiter{fmt.Sprintf("requested_scope-%04d_1", i)},
 		RequestedAudience:    sqlxx.StringSlicePipeDelimiter{fmt.Sprintf("requested_audience-%04d_1", i)},
 		Skip:                 true,
@@ -136,7 +137,7 @@ func expectedConsent(i int) (*consent.ConsentRequest, *consent.LoginRequest, *co
 		GrantedAudience: sqlxx.StringSlicePipeDelimiter{fmt.Sprintf("granted_audience-%04d_1", i)},
 		Remember:        true,
 		RememberFor:     i,
-		Challenge:       fmt.Sprintf("challenge-%04d", i),
+		ID:              fmt.Sprintf("challenge-%04d", i),
 		WasUsed:         true,
 		Error:           &consent.RequestDeniedError{},
 		SessionIDToken: map[string]interface{}{
@@ -154,7 +155,7 @@ func expectedConsent(i int) (*consent.ConsentRequest, *consent.LoginRequest, *co
 		ForceSubjectIdentifier: fmt.Sprintf("force_subject_id-%04d", i),
 		Context:                sqlxx.JSONRawMessage(fmt.Sprintf("{\"context\": \"%04d\"}", i)),
 		Error:                  &consent.RequestDeniedError{},
-		Challenge:              fmt.Sprintf("challenge-%04d", i),
+		ID:                     fmt.Sprintf("challenge-%04d", i),
 		WasUsed:                true,
 	}
 	fols := &consent.ForcedObfuscatedLoginSession{
@@ -162,7 +163,7 @@ func expectedConsent(i int) (*consent.ConsentRequest, *consent.LoginRequest, *co
 		SubjectObfuscated: fmt.Sprintf("subject_obfuscated-%04d", i),
 	}
 	lor := &consent.LogoutRequest{
-		Challenge:             fmt.Sprintf("challenge-%04d", i),
+		ID:                    fmt.Sprintf("challenge-%04d", i),
 		Subject:               fmt.Sprintf("subject-%04d", i),
 		SessionID:             fmt.Sprintf("session_id-%04d", i),
 		RequestURL:            fmt.Sprintf("http://request/%04d", i),
@@ -211,10 +212,10 @@ func expectedConsent(i int) (*consent.ConsentRequest, *consent.LoginRequest, *co
 	return cr, lr, ls, hcr, hlr, fols, lor
 }
 
-func expectedOauth2(i int) (*oauth2.SQLData, *oauth2.BlacklistedJTI) {
-	d := &oauth2.SQLData{
-		Signature: fmt.Sprintf("sig-%04d", i),
-		Request:   fmt.Sprintf("req-%04d", i),
+func expectedOauth2(i int) (*sqlPersister.OAuth2RequestSQL, *oauth2.BlacklistedJTI) {
+	d := &sqlPersister.OAuth2RequestSQL{
+		ID:      fmt.Sprintf("sig-%04d", i),
+		Request: fmt.Sprintf("req-%04d", i),
 		ConsentChallenge: sql.NullString{
 			Valid: true,
 		},
@@ -228,7 +229,7 @@ func expectedOauth2(i int) (*oauth2.SQLData, *oauth2.BlacklistedJTI) {
 		Session:           []byte(fmt.Sprintf("session-%04d", i)),
 	}
 	j := &oauth2.BlacklistedJTI{
-		Signature: fmt.Sprintf("sig-%04d", i),
+		ID: fmt.Sprintf("sig-%04d", i),
 	}
 	switch i {
 	case 1:
diff --git a/persistence/sql/migratest/migration_test.go b/persistence/sql/migratest/migration_test.go
index 6102a1a6d..617cde414 100644
--- a/persistence/sql/migratest/migration_test.go
+++ b/persistence/sql/migratest/migration_test.go
@@ -5,6 +5,8 @@ import (
 	"fmt"
 	"testing"
 
+	"github.com/ory/hydra/persistence/sql"
+
 	"github.com/ory/x/logrusx"
 	"github.com/ory/x/popx"
 
@@ -93,7 +95,7 @@ func TestMigrations(t *testing.T) {
 				t.Run(fmt.Sprintf("case=jwk migration %d", i), func(t *testing.T) {
 					expected := expectedJWK(i)
 					actual := &jwk.SQLData{}
-					require.NoError(t, c.Where("pk = ?", expected.PK).First(actual))
+					require.NoError(t, c.Where("pk = ?", expected.ID).First(actual))
 					assertEqualJWKs(t, expected, actual)
 				})
 			}
@@ -105,11 +107,11 @@ func TestMigrations(t *testing.T) {
 				t.Run(fmt.Sprintf("case=consent migration %d", i), func(t *testing.T) {
 					ecr, elr, els, ehcr, ehlr, efols, elor := expectedConsent(i)
 
-					acr, err := d.Registry().ConsentManager().GetConsentRequest(context.Background(), ecr.Challenge)
+					acr, err := d.Registry().ConsentManager().GetConsentRequest(context.Background(), ecr.ID)
 					require.NoError(t, err)
 					assertEqualConsentRequests(t, ecr, acr)
 
-					alr, err := d.Registry().ConsentManager().GetLoginRequest(context.Background(), elr.Challenge)
+					alr, err := d.Registry().ConsentManager().GetLoginRequest(context.Background(), elr.ID)
 					require.NoError(t, err)
 					assertEqualLoginRequests(t, elr, alr)
 
@@ -118,11 +120,12 @@ func TestMigrations(t *testing.T) {
 					assertEqualLoginSessions(t, els, als)
 
 					ahcr := &consent.HandledConsentRequest{}
-					require.NoError(t, c.Q().Where("challenge = ?", ehcr.Challenge).First(ahcr))
+					require.NoError(t, c.Q().Where("challenge = ?", ehcr.ID).First(ahcr))
+					require.NoError(t, ehcr.AfterFind(c))
 					assertEqualHandledConsentRequests(t, ehcr, ahcr)
 
 					ahlr := &consent.HandledLoginRequest{}
-					require.NoError(t, c.Q().Where("challenge = ?", ehlr.Challenge).First(ahlr))
+					require.NoError(t, c.Q().Where("challenge = ?", ehlr.ID).First(ahlr))
 					assertEqualHandledLoginRequests(t, ehlr, ahlr)
 
 					if efols != nil {
@@ -133,7 +136,7 @@ func TestMigrations(t *testing.T) {
 
 					if elor != nil {
 						alor := &consent.LogoutRequest{}
-						require.NoError(t, dbx.Get(alor, dbx.Rebind("select * from hydra_oauth2_logout_request where challenge = ?"), elor.Challenge))
+						require.NoError(t, dbx.Get(alor, dbx.Rebind("select * from hydra_oauth2_logout_request where challenge = ?"), elor.ID))
 						assertEqualLogoutRequests(t, elor, alor)
 					}
 				})
@@ -152,15 +155,15 @@ func TestMigrations(t *testing.T) {
 					tables = append(tables, "hydra_oauth2_pkce")
 				}
 				ed, ebjti := expectedOauth2(i)
-				ad := &oauth2.SQLData{}
+				ad := &sql.OAuth2RequestSQL{}
 				for _, table := range tables {
-					require.NoError(t, dbx.Get(ad, dbx.Rebind(fmt.Sprintf("select * from %s where signature = ?", table)), ed.Signature), "table: %s\n%+v", table, ed)
+					require.NoError(t, dbx.Get(ad, dbx.Rebind(fmt.Sprintf("select * from %s where signature = ?", table)), ed.ID), "table: %s\n%+v", table, ed)
 					assertEqualOauth2Data(t, ed, ad)
 				}
 
 				if i >= 11 {
 					abjti := &oauth2.BlacklistedJTI{}
-					require.NoError(t, c.Where("signature = ?", ebjti.Signature).First(abjti))
+					require.NoError(t, c.Where("signature = ?", ebjti.ID).First(abjti))
 					assertEqualOauth2BlacklistedJTIs(t, ebjti, abjti)
 				}
 			}
diff --git a/persistence/sql/migrations/20190100000001_client.sqlite.down.sql b/persistence/sql/migrations/20190100000001_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000001_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000001_client.sqlite.up.sql b/persistence/sql/migrations/20190100000001_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000001_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000002_client.sqlite.down.sql b/persistence/sql/migrations/20190100000002_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000002_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000002_client.sqlite.up.sql b/persistence/sql/migrations/20190100000002_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000002_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000003_client.sqlite.down.sql b/persistence/sql/migrations/20190100000003_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000003_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000003_client.sqlite.up.sql b/persistence/sql/migrations/20190100000003_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000003_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000004_client.sqlite.down.sql b/persistence/sql/migrations/20190100000004_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000004_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000004_client.sqlite.up.sql b/persistence/sql/migrations/20190100000004_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000004_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000005_client.sqlite.down.sql b/persistence/sql/migrations/20190100000005_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000005_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000005_client.sqlite.up.sql b/persistence/sql/migrations/20190100000005_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000005_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000006_client.sqlite.down.sql b/persistence/sql/migrations/20190100000006_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000006_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000006_client.sqlite.up.sql b/persistence/sql/migrations/20190100000006_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000006_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000007_client.sqlite.down.sql b/persistence/sql/migrations/20190100000007_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000007_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000007_client.sqlite.up.sql b/persistence/sql/migrations/20190100000007_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000007_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000008_client.sqlite.down.sql b/persistence/sql/migrations/20190100000008_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000008_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000008_client.sqlite.up.sql b/persistence/sql/migrations/20190100000008_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000008_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000009_client.sqlite.down.sql b/persistence/sql/migrations/20190100000009_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000009_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000009_client.sqlite.up.sql b/persistence/sql/migrations/20190100000009_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000009_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000010_client.sqlite.down.sql b/persistence/sql/migrations/20190100000010_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000010_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000010_client.sqlite.up.sql b/persistence/sql/migrations/20190100000010_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000010_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000011_client.sqlite.down.sql b/persistence/sql/migrations/20190100000011_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000011_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000011_client.sqlite.up.sql b/persistence/sql/migrations/20190100000011_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000011_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000012_client.sqlite.down.sql b/persistence/sql/migrations/20190100000012_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000012_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000012_client.sqlite.up.sql b/persistence/sql/migrations/20190100000012_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000012_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000013_client.sqlite.down.sql b/persistence/sql/migrations/20190100000013_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000013_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000013_client.sqlite.up.sql b/persistence/sql/migrations/20190100000013_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000013_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000014_client.sqlite.down.sql b/persistence/sql/migrations/20190100000014_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000014_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190100000014_client.sqlite.up.sql b/persistence/sql/migrations/20190100000014_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190100000014_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190200000001_jwk.sqlite.down.sql b/persistence/sql/migrations/20190200000001_jwk.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190200000001_jwk.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190200000001_jwk.sqlite.up.sql b/persistence/sql/migrations/20190200000001_jwk.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190200000001_jwk.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190200000002_jwk.sqlite.down.sql b/persistence/sql/migrations/20190200000002_jwk.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190200000002_jwk.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190200000002_jwk.sqlite.up.sql b/persistence/sql/migrations/20190200000002_jwk.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190200000002_jwk.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190200000003_jwk.sqlite.down.sql b/persistence/sql/migrations/20190200000003_jwk.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190200000003_jwk.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190200000003_jwk.sqlite.up.sql b/persistence/sql/migrations/20190200000003_jwk.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190200000003_jwk.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190200000004_jwk.sqlite.down.sql b/persistence/sql/migrations/20190200000004_jwk.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190200000004_jwk.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190200000004_jwk.sqlite.up.sql b/persistence/sql/migrations/20190200000004_jwk.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190200000004_jwk.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000001_consent.sqlite.down.sql b/persistence/sql/migrations/20190300000001_consent.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000001_consent.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000001_consent.sqlite.up.sql b/persistence/sql/migrations/20190300000001_consent.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000001_consent.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000002_consent.sqlite.down.sql b/persistence/sql/migrations/20190300000002_consent.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000002_consent.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000002_consent.sqlite.up.sql b/persistence/sql/migrations/20190300000002_consent.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000002_consent.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000003_consent.sqlite.down.sql b/persistence/sql/migrations/20190300000003_consent.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000003_consent.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000003_consent.sqlite.up.sql b/persistence/sql/migrations/20190300000003_consent.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000003_consent.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000004_consent.sqlite.down.sql b/persistence/sql/migrations/20190300000004_consent.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000004_consent.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000004_consent.sqlite.up.sql b/persistence/sql/migrations/20190300000004_consent.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000004_consent.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000005_consent.sqlite.down.sql b/persistence/sql/migrations/20190300000005_consent.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000005_consent.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000005_consent.sqlite.up.sql b/persistence/sql/migrations/20190300000005_consent.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000005_consent.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000006_consent.sqlite.down.sql b/persistence/sql/migrations/20190300000006_consent.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000006_consent.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000006_consent.sqlite.up.sql b/persistence/sql/migrations/20190300000006_consent.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000006_consent.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000007_consent.sqlite.down.sql b/persistence/sql/migrations/20190300000007_consent.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000007_consent.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000007_consent.sqlite.up.sql b/persistence/sql/migrations/20190300000007_consent.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000007_consent.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000008_consent.sqlite.down.sql b/persistence/sql/migrations/20190300000008_consent.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000008_consent.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000008_consent.sqlite.up.sql b/persistence/sql/migrations/20190300000008_consent.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000008_consent.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000009_consent.sqlite.down.sql b/persistence/sql/migrations/20190300000009_consent.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000009_consent.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000009_consent.sqlite.up.sql b/persistence/sql/migrations/20190300000009_consent.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000009_consent.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000010_consent.sqlite.down.sql b/persistence/sql/migrations/20190300000010_consent.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000010_consent.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000010_consent.sqlite.up.sql b/persistence/sql/migrations/20190300000010_consent.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000010_consent.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000011_consent.sqlite.down.sql b/persistence/sql/migrations/20190300000011_consent.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000011_consent.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000011_consent.sqlite.up.sql b/persistence/sql/migrations/20190300000011_consent.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000011_consent.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000012_consent.sqlite.down.sql b/persistence/sql/migrations/20190300000012_consent.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000012_consent.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000012_consent.sqlite.up.sql b/persistence/sql/migrations/20190300000012_consent.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000012_consent.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000013_consent.sqlite.down.sql b/persistence/sql/migrations/20190300000013_consent.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000013_consent.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000013_consent.sqlite.up.sql b/persistence/sql/migrations/20190300000013_consent.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000013_consent.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000014_consent.sqlite.down.sql b/persistence/sql/migrations/20190300000014_consent.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000014_consent.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190300000014_consent.sqlite.up.sql b/persistence/sql/migrations/20190300000014_consent.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190300000014_consent.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000001_oauth2.sqlite.down.sql b/persistence/sql/migrations/20190400000001_oauth2.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000001_oauth2.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000001_oauth2.sqlite.up.sql b/persistence/sql/migrations/20190400000001_oauth2.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000001_oauth2.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000002_oauth2.sqlite.down.sql b/persistence/sql/migrations/20190400000002_oauth2.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000002_oauth2.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000002_oauth2.sqlite.up.sql b/persistence/sql/migrations/20190400000002_oauth2.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000002_oauth2.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000003_oauth2.sqlite.down.sql b/persistence/sql/migrations/20190400000003_oauth2.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000003_oauth2.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000003_oauth2.sqlite.up.sql b/persistence/sql/migrations/20190400000003_oauth2.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000003_oauth2.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000004_oauth2.sqlite.down.sql b/persistence/sql/migrations/20190400000004_oauth2.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000004_oauth2.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000004_oauth2.sqlite.up.sql b/persistence/sql/migrations/20190400000004_oauth2.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000004_oauth2.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000005_oauth2.sqlite.down.sql b/persistence/sql/migrations/20190400000005_oauth2.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000005_oauth2.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000005_oauth2.sqlite.up.sql b/persistence/sql/migrations/20190400000005_oauth2.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000005_oauth2.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000006_oauth2.sqlite.down.sql b/persistence/sql/migrations/20190400000006_oauth2.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000006_oauth2.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000006_oauth2.sqlite.up.sql b/persistence/sql/migrations/20190400000006_oauth2.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000006_oauth2.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000007_oauth2.sqlite.down.sql b/persistence/sql/migrations/20190400000007_oauth2.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000007_oauth2.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000007_oauth2.sqlite.up.sql b/persistence/sql/migrations/20190400000007_oauth2.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000007_oauth2.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000008_oauth2.sqlite.down.sql b/persistence/sql/migrations/20190400000008_oauth2.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000008_oauth2.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000008_oauth2.sqlite.up.sql b/persistence/sql/migrations/20190400000008_oauth2.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000008_oauth2.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000009_oauth2.sqlite.down.sql b/persistence/sql/migrations/20190400000009_oauth2.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000009_oauth2.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000009_oauth2.sqlite.up.sql b/persistence/sql/migrations/20190400000009_oauth2.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000009_oauth2.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000010_oauth2.sqlite.down.sql b/persistence/sql/migrations/20190400000010_oauth2.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000010_oauth2.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000010_oauth2.sqlite.up.sql b/persistence/sql/migrations/20190400000010_oauth2.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000010_oauth2.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000011_oauth2.sqlite.down.sql b/persistence/sql/migrations/20190400000011_oauth2.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000011_oauth2.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20190400000011_oauth2.sqlite.up.sql b/persistence/sql/migrations/20190400000011_oauth2.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20190400000011_oauth2.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20200521071434_consent.sqlite.down.sql b/persistence/sql/migrations/20200521071434_consent.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20200521071434_consent.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20200521071434_consent.sqlite.up.sql b/persistence/sql/migrations/20200521071434_consent.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20200521071434_consent.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20200527215731_client.sqlite.down.sql b/persistence/sql/migrations/20200527215731_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20200527215731_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20200527215731_client.sqlite.up.sql b/persistence/sql/migrations/20200527215731_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20200527215731_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20200527215732_client.sqlite.down.sql b/persistence/sql/migrations/20200527215732_client.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20200527215732_client.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20200527215732_client.sqlite.up.sql b/persistence/sql/migrations/20200527215732_client.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20200527215732_client.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20200819163013_add_client_id_subject_idx_to_access_and_refresh.sqlite.down.sql b/persistence/sql/migrations/20200819163013_add_client_id_subject_idx_to_access_and_refresh.sqlite.down.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20200819163013_add_client_id_subject_idx_to_access_and_refresh.sqlite.down.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20200819163013_add_client_id_subject_idx_to_access_and_refresh.sqlite.up.sql b/persistence/sql/migrations/20200819163013_add_client_id_subject_idx_to_access_and_refresh.sqlite.up.sql
new file mode 100644
index 000000000..35acabf7e
--- /dev/null
+++ b/persistence/sql/migrations/20200819163013_add_client_id_subject_idx_to_access_and_refresh.sqlite.up.sql
@@ -0,0 +1 @@
+-- sqlite support added later
diff --git a/persistence/sql/migrations/20200913192340_initial_sqlite.down.sql b/persistence/sql/migrations/20200913192340_initial_sqlite.down.sql
new file mode 100644
index 000000000..680efba49
--- /dev/null
+++ b/persistence/sql/migrations/20200913192340_initial_sqlite.down.sql
@@ -0,0 +1 @@
+-- this migration is only for sqlite
diff --git a/persistence/sql/migrations/20200913192340_initial_sqlite.sqlite.down.sql b/persistence/sql/migrations/20200913192340_initial_sqlite.sqlite.down.sql
new file mode 100644
index 000000000..59411049f
--- /dev/null
+++ b/persistence/sql/migrations/20200913192340_initial_sqlite.sqlite.down.sql
@@ -0,0 +1,29 @@
+DROP TABLE hydra_client;
+
+DROP TABLE hydra_jwk;
+
+DROP TABLE hydra_oauth2_authentication_session;
+
+DROP TABLE hydra_oauth2_authentication_request;
+
+DROP TABLE hydra_oauth2_consent_request;
+
+DROP TABLE hydra_oauth2_consent_request_handled;
+
+DROP TABLE hydra_oauth2_access;
+
+DROP TABLE hydra_oauth2_authentication_request_handled;
+
+DROP TABLE hydra_oauth2_code;
+
+DROP TABLE hydra_oauth2_jti_blacklist;
+
+DROP TABLE hydra_oauth2_logout_request;
+
+DROP TABLE hydra_oauth2_obfuscated_authentication_session;
+
+DROP TABLE hydra_oauth2_oidc;
+
+DROP TABLE hydra_oauth2_pkce;
+
+DROP TABLE hydra_oauth2_refresh;
diff --git a/persistence/sql/migrations/20200913192340_initial_sqlite.sqlite.up.sql b/persistence/sql/migrations/20200913192340_initial_sqlite.sqlite.up.sql
new file mode 100644
index 000000000..be2523500
--- /dev/null
+++ b/persistence/sql/migrations/20200913192340_initial_sqlite.sqlite.up.sql
@@ -0,0 +1,281 @@
+CREATE TABLE IF NOT EXISTS hydra_client
+(
+    id                                   VARCHAR(255) NOT NULL,
+    client_name                          TEXT         NOT NULL,
+    client_secret                        TEXT         NOT NULL,
+    redirect_uris                        TEXT         NOT NULL,
+    grant_types                          TEXT         NOT NULL,
+    response_types                       TEXT         NOT NULL,
+    scope                                TEXT         NOT NULL,
+    owner                                TEXT         NOT NULL,
+    policy_uri                           TEXT         NOT NULL,
+    tos_uri                              TEXT         NOT NULL,
+    client_uri                           TEXT         NOT NULL,
+    logo_uri                             TEXT         NOT NULL,
+    contacts                             TEXT         NOT NULL,
+    client_secret_expires_at             INTEGER      NOT NULL DEFAULT 0,
+    sector_identifier_uri                TEXT         NOT NULL,
+    jwks                                 TEXT         NOT NULL,
+    jwks_uri                             TEXT         NOT NULL,
+    request_uris                         TEXT         NOT NULL,
+    token_endpoint_auth_method           VARCHAR(25)  NOT NULL DEFAULT '',
+    request_object_signing_alg           VARCHAR(10)  NOT NULL DEFAULT '',
+    userinfo_signed_response_alg         VARCHAR(10)  NOT NULL DEFAULT '',
+    subject_type                         VARCHAR(15)  NOT NULL DEFAULT '',
+    allowed_cors_origins                 TEXT         NOT NULL,
+    pk                                   INTEGER PRIMARY KEY,
+    audience                             TEXT         NOT NULL,
+    created_at                           TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
+    updated_at                           TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
+    frontchannel_logout_uri              TEXT         NOT NULL DEFAULT '',
+    frontchannel_logout_session_required INTEGER      NOT NULL DEFAULT false,
+    post_logout_redirect_uris            TEXT         NOT NULL DEFAULT '',
+    backchannel_logout_uri               TEXT         NOT NULL DEFAULT '',
+    backchannel_logout_session_required  INTEGER      NOT NULL DEFAULT false,
+    metadata                             TEXT         NOT NULL DEFAULT '{}',
+    token_endpoint_auth_signing_alg      VARCHAR(10)  NOT NULL DEFAULT ''
+);
+
+CREATE UNIQUE INDEX hydra_client_id_idx ON hydra_client (id);
+
+CREATE TABLE IF NOT EXISTS hydra_jwk
+(
+    sid        VARCHAR(255) NOT NULL,
+    kid        VARCHAR(255) NOT NULL,
+    version    INTEGER      NOT NULL DEFAULT 0,
+    keydata    TEXT         NOT NULL,
+    created_at TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
+    pk         INTEGER PRIMARY KEY
+);
+
+CREATE UNIQUE INDEX hydra_jwk_sid_kid_key ON hydra_jwk (sid, kid);
+
+CREATE TABLE hydra_oauth2_authentication_session
+(
+    id               VARCHAR(40)  NOT NULL PRIMARY KEY,
+    authenticated_at TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
+    subject          VARCHAR(255) NOT NULL,
+    remember         INTEGER      NOT NULL DEFAULT false
+);
+
+CREATE INDEX hydra_oauth2_authentication_session_subject_idx ON hydra_oauth2_authentication_session (subject);
+
+CREATE TABLE hydra_oauth2_authentication_request
+(
+    challenge             VARCHAR(40)  NOT NULL PRIMARY KEY,
+    requested_scope       TEXT         NOT NULL,
+    verifier              VARCHAR(40)  NOT NULL,
+    csrf                  VARCHAR(40)  NOT NULL,
+    subject               VARCHAR(255) NOT NULL,
+    request_url           TEXT         NOT NULL,
+    skip                  INTEGER      NOT NULL,
+    client_id             VARCHAR(255) NOT NULL REFERENCES hydra_client (id) ON DELETE CASCADE,
+    requested_at          TIMESTAMP    NOT NULL                                                                               DEFAULT CURRENT_TIMESTAMP,
+    authenticated_at      TIMESTAMP    NULL,
+    oidc_context          TEXT         NOT NULL,
+    login_session_id      VARCHAR(40)  NULL REFERENCES hydra_oauth2_authentication_session (id) ON DELETE CASCADE DEFAULT '',
+    requested_at_audience TEXT         NULL                                                                                   DEFAULT ''
+);
+
+CREATE INDEX hydra_oauth2_authentication_request_client_id_idx ON hydra_oauth2_authentication_request (client_id);
+CREATE INDEX hydra_oauth2_authentication_request_login_session_id_idx ON hydra_oauth2_authentication_request (login_session_id);
+CREATE INDEX hydra_oauth2_authentication_request_subject_idx ON hydra_oauth2_authentication_request (subject);
+CREATE UNIQUE INDEX hydra_oauth2_authentication_request_verifier_idx ON hydra_oauth2_authentication_request (verifier);
+
+CREATE TABLE hydra_oauth2_consent_request
+(
+    challenge                 VARCHAR(40)  NOT NULL PRIMARY KEY,
+    verifier                  VARCHAR(40)  NOT NULL,
+    client_id                 VARCHAR(255) NOT NULL REFERENCES hydra_client (id) ON DELETE CASCADE,
+    subject                   VARCHAR(255) NOT NULL,
+    request_url               TEXT         NOT NULL,
+    skip                      INTEGER      NOT NULL,
+    requested_scope           TEXT         NOT NULL,
+    csrf                      VARCHAR(40)  NOT NULL,
+    authenticated_at          TIMESTAMP    NULL,
+    requested_at              TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
+    oidc_context              TEXT         NOT NULL,
+    forced_subject_identifier VARCHAR(255) NULL     DEFAULT '',
+    login_session_id          VARCHAR(40)  NULL REFERENCES hydra_oauth2_authentication_session (id) ON DELETE SET NULL,
+    login_challenge           VARCHAR(40)  NULL REFERENCES hydra_oauth2_authentication_request (challenge) ON DELETE SET NULL,
+    requested_at_audience     TEXT         NULL     DEFAULT '',
+    acr                       TEXT         NULL     DEFAULT '',
+    context                   TEXT         NOT NULL DEFAULT '{}'
+);
+
+CREATE INDEX hydra_oauth2_consent_request_client_id_idx ON hydra_oauth2_consent_request (client_id);
+CREATE INDEX hydra_oauth2_consent_request_subject_idx ON hydra_oauth2_consent_request (subject);
+CREATE INDEX hydra_oauth2_consent_request_login_session_id_idx ON hydra_oauth2_consent_request (login_session_id);
+CREATE INDEX hydra_oauth2_consent_request_login_challenge_idx ON hydra_oauth2_consent_request (login_challenge);
+
+CREATE TABLE hydra_oauth2_consent_request_handled
+(
+    challenge            VARCHAR(40) NOT NULL PRIMARY KEY REFERENCES hydra_oauth2_consent_request (challenge) ON DELETE CASCADE,
+    granted_scope        TEXT        NOT NULL,
+    remember             INTEGER     NOT NULL,
+    remember_for         INTEGER     NOT NULL,
+    error                TEXT        NOT NULL,
+    requested_at         TIMESTAMP   NOT NULL DEFAULT CURRENT_TIMESTAMP,
+    session_access_token TEXT        NOT NULL,
+    session_id_token     TEXT        NOT NULL,
+    authenticated_at     TIMESTAMP   NULL,
+    was_used             INTEGER     NOT NULL,
+    granted_at_audience  TEXT        NULL     DEFAULT '',
+    handled_at           TIMESTAMP   NULL
+);
+
+CREATE TABLE hydra_oauth2_access
+(
+    signature          VARCHAR(255) NOT NULL PRIMARY KEY,
+    request_id         VARCHAR(40)  NOT NULL,
+    requested_at       TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
+    client_id          VARCHAR(255) NOT NULL REFERENCES hydra_client (id) ON DELETE CASCADE,
+    scope              TEXT         NOT NULL,
+    granted_scope      TEXT         NOT NULL,
+    form_data          TEXT         NOT NULL,
+    session_data       TEXT         NOT NULL,
+    subject            VARCHAR(255) NOT NULL DEFAULT '',
+    active             INTEGER      NOT NULL DEFAULT true,
+    requested_audience TEXT         NULL     DEFAULT '',
+    granted_audience   TEXT         NULL     DEFAULT '',
+    challenge_id       VARCHAR(40)  NULL REFERENCES hydra_oauth2_consent_request_handled (challenge) ON DELETE CASCADE,
+    UNIQUE (request_id)
+);
+
+CREATE INDEX hydra_oauth2_access_requested_at_idx ON hydra_oauth2_access (requested_at);
+CREATE INDEX hydra_oauth2_access_client_id_idx ON hydra_oauth2_access (client_id);
+CREATE INDEX hydra_oauth2_access_challenge_id_idx ON hydra_oauth2_access (challenge_id);
+CREATE INDEX hydra_oauth2_access_client_id_subject_idx ON hydra_oauth2_access (client_id, subject);
+
+CREATE TABLE hydra_oauth2_authentication_request_handled
+(
+    challenge                 VARCHAR(40)  NOT NULL PRIMARY KEY REFERENCES hydra_oauth2_authentication_request (challenge) ON DELETE CASCADE,
+    subject                   VARCHAR(255) NOT NULL,
+    remember                  INTEGER      NOT NULL,
+    remember_for              INTEGER      NOT NULL,
+    error                     TEXT         NOT NULL,
+    acr                       TEXT         NOT NULL,
+    requested_at              TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
+    authenticated_at          TIMESTAMP    NULL,
+    was_used                  INTEGER      NOT NULL,
+    forced_subject_identifier VARCHAR(255) NULL     DEFAULT '',
+    context                   TEXT         NOT NULL DEFAULT '{}'
+);
+
+CREATE TABLE hydra_oauth2_code
+(
+    signature          VARCHAR(255) NOT NULL,
+    request_id         VARCHAR(40)  NOT NULL,
+    requested_at       TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
+    client_id          VARCHAR(255) NOT NULL REFERENCES hydra_client (id) ON DELETE CASCADE,
+    scope              TEXT         NOT NULL,
+    granted_scope      TEXT         NOT NULL,
+    form_data          TEXT         NOT NULL,
+    session_data       TEXT         NOT NULL,
+    subject            VARCHAR(255) NOT NULL DEFAULT '',
+    active             INTEGER      NOT NULL DEFAULT true,
+    requested_audience TEXT         NULL     DEFAULT '',
+    granted_audience   TEXT         NULL     DEFAULT '',
+    challenge_id       VARCHAR(40)  NULL REFERENCES hydra_oauth2_consent_request_handled (challenge) ON DELETE CASCADE
+);
+
+CREATE INDEX hydra_oauth2_code_client_id_idx ON hydra_oauth2_code (client_id);
+CREATE INDEX hydra_oauth2_code_challenge_id_idx ON hydra_oauth2_code (challenge_id);
+
+CREATE TABLE hydra_oauth2_jti_blacklist
+(
+    signature  VARCHAR(64) NOT NULL PRIMARY KEY,
+    expires_at TIMESTAMP   NOT NULL DEFAULT CURRENT_TIMESTAMP
+);
+
+CREATE INDEX hydra_oauth2_jti_blacklist_expires_at_idx ON hydra_oauth2_jti_blacklist (expires_at);
+
+CREATE TABLE hydra_oauth2_logout_request
+(
+    challenge    VARCHAR(36)  NOT NULL PRIMARY KEY,
+    verifier     VARCHAR(36)  NOT NULL,
+    subject      VARCHAR(255) NOT NULL,
+    sid          VARCHAR(36)  NOT NULL,
+    client_id    VARCHAR(255) NULL REFERENCES hydra_client (id) ON DELETE CASCADE,
+    request_url  TEXT         NOT NULL,
+    redir_url    TEXT         NOT NULL,
+    was_used     INTEGER      NOT NULL DEFAULT false,
+    accepted     INTEGER      NOT NULL DEFAULT false,
+    rejected     INTEGER      NOT NULL DEFAULT false,
+    rp_initiated INTEGER      NOT NULL DEFAULT false,
+    UNIQUE (verifier)
+);
+
+CREATE INDEX hydra_oauth2_logout_request_client_id_idx ON hydra_oauth2_logout_request (client_id);
+
+CREATE TABLE hydra_oauth2_obfuscated_authentication_session
+(
+    subject            VARCHAR(255) NOT NULL,
+    client_id          VARCHAR(255) NOT NULL REFERENCES hydra_client (id) ON DELETE CASCADE,
+    subject_obfuscated VARCHAR(255) NOT NULL,
+    PRIMARY KEY (subject, client_id)
+);
+
+CREATE INDEX hydra_oauth2_obfuscated_authentication_session_client_id_subject_obfuscated_idx ON hydra_oauth2_obfuscated_authentication_session (client_id, subject_obfuscated);
+
+CREATE TABLE hydra_oauth2_oidc
+(
+    signature          VARCHAR(255) NOT NULL PRIMARY KEY,
+    request_id         VARCHAR(40)  NOT NULL,
+    requested_at       TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
+    client_id          VARCHAR(255) NOT NULL REFERENCES hydra_client (id) ON DELETE CASCADE,
+    scope              TEXT         NOT NULL,
+    granted_scope      TEXT         NOT NULL,
+    form_data          TEXT         NOT NULL,
+    session_data       TEXT         NOT NULL,
+    subject            VARCHAR(255) NOT NULL DEFAULT '',
+    active             INTEGER      NOT NULL DEFAULT true,
+    requested_audience TEXT         NULL     DEFAULT '',
+    granted_audience   TEXT         NULL     DEFAULT '',
+    challenge_id       VARCHAR(40)  NULL REFERENCES hydra_oauth2_consent_request_handled (challenge) ON DELETE CASCADE
+);
+
+CREATE INDEX hydra_oauth2_oidc_client_id_idx ON hydra_oauth2_oidc (client_id);
+CREATE INDEX hydra_oauth2_oidc_challenge_id_idx ON hydra_oauth2_oidc (challenge_id);
+
+CREATE TABLE hydra_oauth2_pkce
+(
+    signature          VARCHAR(255) NOT NULL PRIMARY KEY,
+    request_id         VARCHAR(40)  NOT NULL,
+    requested_at       TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
+    client_id          VARCHAR(255) NOT NULL REFERENCES hydra_client (id) ON DELETE CASCADE,
+    scope              TEXT         NOT NULL,
+    granted_scope      TEXT         NOT NULL,
+    form_data          TEXT         NOT NULL,
+    session_data       TEXT         NOT NULL,
+    subject            VARCHAR(255) NOT NULL,
+    active             INTEGER      NOT NULL DEFAULT true,
+    requested_audience TEXT         NULL     DEFAULT '',
+    granted_audience   TEXT         NULL     DEFAULT '',
+    challenge_id       VARCHAR(40)  NULL REFERENCES hydra_oauth2_consent_request_handled (challenge) ON DELETE CASCADE
+);
+
+CREATE INDEX hydra_oauth2_pkce_client_id_idx ON hydra_oauth2_pkce (client_id);
+CREATE INDEX hydra_oauth2_pkce_challenge_id_idx ON hydra_oauth2_pkce (challenge_id);
+
+CREATE TABLE hydra_oauth2_refresh
+(
+    signature          VARCHAR(255) NOT NULL PRIMARY KEY,
+    request_id         VARCHAR(40)  NOT NULL,
+    requested_at       TIMESTAMP    NOT NULL DEFAULT CURRENT_TIMESTAMP,
+    client_id          VARCHAR(255) NOT NULL REFERENCES hydra_client (id) ON DELETE CASCADE,
+    scope              TEXT         NOT NULL,
+    granted_scope      TEXT         NOT NULL,
+    form_data          TEXT         NOT NULL,
+    session_data       TEXT         NOT NULL,
+    subject            VARCHAR(255) NOT NULL DEFAULT '',
+    active             INTEGER      NOT NULL DEFAULT true,
+    requested_audience TEXT         NULL     DEFAULT '',
+    granted_audience   TEXT         NULL     DEFAULT '',
+    challenge_id       VARCHAR(40)  NULL REFERENCES hydra_oauth2_consent_request_handled (challenge) ON DELETE CASCADE,
+    UNIQUE (request_id)
+);
+
+CREATE INDEX hydra_oauth2_refresh_client_id_idx ON hydra_oauth2_refresh (client_id);
+CREATE INDEX hydra_oauth2_refresh_challenge_id_idx ON hydra_oauth2_refresh (challenge_id);
+CREATE INDEX hydra_oauth2_refresh_client_id_subject_idx ON hydra_oauth2_refresh (client_id, subject);
diff --git a/persistence/sql/migrations/20200913192340_initial_sqlite.up.sql b/persistence/sql/migrations/20200913192340_initial_sqlite.up.sql
new file mode 100644
index 000000000..680efba49
--- /dev/null
+++ b/persistence/sql/migrations/20200913192340_initial_sqlite.up.sql
@@ -0,0 +1 @@
+-- this migration is only for sqlite
diff --git a/persistence/sql/persister.go b/persistence/sql/persister.go
index ab7b85639..b0ee1955d 100644
--- a/persistence/sql/persister.go
+++ b/persistence/sql/persister.go
@@ -2,138 +2,135 @@ package sql
 
 import (
 	"context"
-	"fmt"
-	"io"
-	"strconv"
-	"strings"
-	"time"
+	"database/sql"
 
-	"github.com/ory/x/sqlcon"
+	"github.com/gobuffalo/x/randx"
+
+	"github.com/ory/fosite/storage"
 
 	"github.com/gobuffalo/packr/v2"
 	"github.com/gobuffalo/pop/v5"
 	"github.com/pkg/errors"
 
+	"github.com/ory/fosite"
+	"github.com/ory/hydra/driver/configuration"
+	"github.com/ory/hydra/jwk"
 	"github.com/ory/hydra/persistence"
+	"github.com/ory/x/logrusx"
 )
 
 var _ persistence.Persister = new(Persister)
-var migrations = packr.New("migrations", "migrations")
+var _ storage.Transactional = new(Persister)
 
-type Persister struct {
-	c  *pop.Connection
-	mb pop.MigrationBox
-}
+const transactionContextKey transactionContextType = "transactionConnection"
 
-func NewPersister(c *pop.Connection) (*Persister, error) {
-	mb, err := pop.NewMigrationBox(migrations, c)
-	if err != nil {
-		return nil, errors.WithStack(err)
-	}
+var (
+	migrations = packr.New("migrations", "migrations")
 
-	return &Persister{
-		c,
-		mb,
-	}, nil
-}
+	ErrTransactionOpen   = errors.New("There is already a transaction in this context.")
+	ErrNoTransactionOpen = errors.New("There is no transaction in this context.")
+)
 
-func (p *Persister) MigrationStatus(_ context.Context, w io.Writer) error {
-	return errors.WithStack(p.mb.Status(w))
-}
+type (
+	Persister struct {
+		conn   *pop.Connection
+		mb     pop.MigrationBox
+		r      Dependencies
+		config configuration.Provider
+		l      *logrusx.Logger
+	}
+	Dependencies interface {
+		ClientHasher() fosite.Hasher
+		KeyCipher() *jwk.AEAD
+	}
+	transactionContextType string
+)
 
-func (p *Persister) MigrateDown(_ context.Context, steps int) error {
-	return errors.WithStack(p.mb.Down(steps))
-}
+func (p *Persister) BeginTX(ctx context.Context) (context.Context, error) {
+	_, ok := ctx.Value(transactionContextKey).(*pop.Connection)
+	if ok {
+		return ctx, errors.WithStack(ErrTransactionOpen)
+	}
 
-func (p *Persister) MigrateUp(_ context.Context) error {
-	if err := p.migrateOldMigrationTables(); err != nil {
-		return err
+	tx, err := p.conn.Store.TransactionContextOptions(ctx, &sql.TxOptions{
+		Isolation: sql.LevelRepeatableRead,
+		ReadOnly:  false,
+	})
+	c := &pop.Connection{
+		TX:      tx,
+		Store:   tx,
+		ID:      randx.String(30),
+		Dialect: p.conn.Dialect,
 	}
-	return errors.WithStack(p.mb.Up())
+	return context.WithValue(ctx, transactionContextKey, c), err
 }
 
-func (p *Persister) MigrateUpTo(_ context.Context, steps int) (int, error) {
-	if err := p.migrateOldMigrationTables(); err != nil {
-		return 0, err
+func (p *Persister) Commit(ctx context.Context) error {
+	c, ok := ctx.Value(transactionContextKey).(*pop.Connection)
+	if !ok || c.TX == nil {
+		return errors.WithStack(ErrNoTransactionOpen)
 	}
-	n, err := p.mb.UpTo(steps)
-	return n, errors.WithStack(err)
-}
 
-func (p *Persister) PrepareMigration(_ context.Context) error {
-	return p.migrateOldMigrationTables()
+	return c.TX.Commit()
 }
 
-func (p *Persister) Connection(_ context.Context) *pop.Connection {
-	return p.c
-}
+func (p *Persister) Rollback(ctx context.Context) error {
+	c, ok := ctx.Value(transactionContextKey).(*pop.Connection)
+	if !ok || c.TX == nil {
+		return errors.WithStack(ErrNoTransactionOpen)
+	}
 
-type oldTableName string
+	return c.TX.Rollback()
+}
 
-const (
-	clientMigrationTableName  oldTableName = "hydra_client_migration"
-	jwkMigrationTableName     oldTableName = "hydra_jwk_migration"
-	consentMigrationTableName oldTableName = "hydra_oauth2_authentication_consent_migration"
-	oauth2MigrationTableName  oldTableName = "hydra_oauth2_migration"
-)
+func NewPersister(c *pop.Connection, r Dependencies, config configuration.Provider, l *logrusx.Logger) (*Persister, error) {
+	mb, err := pop.NewMigrationBox(migrations, c)
+	if err != nil {
+		return nil, errors.WithStack(err)
+	}
 
-// this type is copied from sql-migrate to remove the dependency
-type OldMigrationRecord struct {
-	ID        string    `db:"id"`
-	AppliedAt time.Time `db:"applied_at"`
+	return &Persister{
+		conn:   c,
+		mb:     mb,
+		r:      r,
+		config: config,
+		l:      l,
+	}, nil
 }
 
-// this function is idempotent
-func (p *Persister) migrateOldMigrationTables() error {
-	if err := p.c.RawQuery(fmt.Sprintf("SELECT * FROM %s", clientMigrationTableName)).Exec(); err != nil {
-		// assume there are no old migration tables => done
-		return nil
+func (p *Persister) Connection(ctx context.Context) *pop.Connection {
+	if c := ctx.Value(transactionContextKey); c != nil {
+		return c.(*pop.Connection)
 	}
+	return p.conn
+}
 
-	if err := pop.CreateSchemaMigrations(p.c); err != nil {
-		return errors.WithStack(err)
-	}
+func (p *Persister) transaction(ctx context.Context, f func(ctx context.Context, c *pop.Connection) error) error {
+	isNested := true
+	c, ok := ctx.Value(transactionContextKey).(*pop.Connection)
+	if !ok {
+		isNested = false
 
-	// in this order the migrations only depend on already done ones
-	for i, table := range []oldTableName{clientMigrationTableName, jwkMigrationTableName, consentMigrationTableName, oauth2MigrationTableName} {
-		// If table does not exist, we will skip it. Previously, we created a stub table here which
-		// caused the cached statements to fail, see:
-		//
-		// https://github.com/flynn/flynn/pull/2306/files
-		// https://github.com/jackc/pgx/issues/110
-		// https://github.com/flynn/flynn/issues/2235
-		// get old migrations
-		var migrations []OldMigrationRecord
-
-		/* #nosec G201 table is static */
-		if err := p.c.RawQuery(fmt.Sprintf("SELECT * FROM %s", table)).All(&migrations); err != nil {
-			if strings.Contains(err.Error(), string(table)) {
-				continue
-			}
-			return err
-		}
+		var err error
+		c, err = p.conn.NewTransaction()
 
-		// translate migrations
-		for _, m := range migrations {
-			// mark the migration as run for fizz
-			// fizz standard version pattern: YYYYMMDDhhmmss
-			migrationNumber, err := strconv.ParseInt(m.ID, 10, 0)
-			if err != nil {
-				return errors.WithStack(err)
-			}
+		if err != nil {
+			return errors.WithStack(err)
+		}
+	}
 
-			/* #nosec G201 - i is static (0..3) and migrationNumber is from the database */
-			if err := p.c.RawQuery(
-				fmt.Sprintf("INSERT INTO schema_migration (version) VALUES ('2019%02d%08d')", i+1, migrationNumber)).
-				Exec(); err != nil {
+	if err := f(context.WithValue(ctx, transactionContextKey, c), c); err != nil {
+		if !isNested {
+			if err := c.TX.Rollback(); err != nil {
 				return errors.WithStack(err)
 			}
 		}
+		return err
+	}
 
-		// delete old migration table
-		if err := p.c.RawQuery(fmt.Sprintf("DROP TABLE %s", table)).Exec(); err != nil {
-			return sqlcon.HandleError(err)
-		}
+	// commit if there is no wrapping transaction
+	if !isNested {
+		return errors.WithStack(c.TX.Commit())
 	}
 
 	return nil
diff --git a/persistence/sql/persister_client.go b/persistence/sql/persister_client.go
new file mode 100644
index 000000000..dfb430499
--- /dev/null
+++ b/persistence/sql/persister_client.go
@@ -0,0 +1,83 @@
+package sql
+
+import (
+	"context"
+
+	"github.com/gobuffalo/pop/v5"
+	"github.com/pkg/errors"
+
+	"github.com/ory/fosite"
+	"github.com/ory/hydra/client"
+	"github.com/ory/x/sqlcon"
+)
+
+func (p *Persister) GetClient(ctx context.Context, id string) (fosite.Client, error) {
+	return p.GetConcreteClient(ctx, id)
+}
+
+func (p *Persister) CreateClient(ctx context.Context, c *client.Client) error {
+	h, err := p.r.ClientHasher().Hash(ctx, []byte(c.Secret))
+	if err != nil {
+		return err
+	}
+	c.Secret = string(h)
+
+	return sqlcon.HandleError(p.Connection(ctx).Create(c, "pk"))
+}
+
+func (p *Persister) UpdateClient(ctx context.Context, cl *client.Client) error {
+	return p.transaction(ctx, func(ctx context.Context, c *pop.Connection) error {
+		o, err := p.GetClient(ctx, cl.GetID())
+		if err != nil {
+			return err
+		}
+
+		if cl.Secret == "" {
+			cl.Secret = string(o.GetHashedSecret())
+		} else {
+			h, err := p.r.ClientHasher().Hash(ctx, []byte(cl.Secret))
+			if err != nil {
+				return errors.WithStack(err)
+			}
+			cl.Secret = string(h)
+		}
+
+		return sqlcon.HandleError(c.Update(cl))
+	})
+}
+
+func (p *Persister) DeleteClient(ctx context.Context, id string) error {
+	return sqlcon.HandleError(p.Connection(ctx).Destroy(&client.Client{ID: id}))
+}
+
+func (p *Persister) GetClients(ctx context.Context, limit, offset int) ([]client.Client, error) {
+	cs := make([]client.Client, 0)
+	return cs, sqlcon.HandleError(
+		p.Connection(ctx).
+			Paginate(offset/limit+1, limit).
+			Order("id").
+			All(&cs))
+}
+
+func (p *Persister) CountClients(ctx context.Context) (int, error) {
+	n, err := p.Connection(ctx).Count(&client.Client{})
+	return n, sqlcon.HandleError(err)
+}
+
+func (p *Persister) GetConcreteClient(ctx context.Context, id string) (*client.Client, error) {
+	var cl client.Client
+	return &cl, sqlcon.HandleError(p.Connection(ctx).Find(&cl, id))
+}
+
+func (p *Persister) Authenticate(ctx context.Context, id string, secret []byte) (*client.Client, error) {
+	c, err := p.GetConcreteClient(ctx, id)
+	if err != nil {
+		return nil, errors.WithStack(err)
+	}
+
+	if err := p.r.ClientHasher().Compare(ctx, c.GetHashedSecret(), secret); err != nil {
+		return nil, errors.WithStack(err)
+	}
+
+	return c, nil
+}
diff --git a/persistence/sql/persister_consent.go b/persistence/sql/persister_consent.go
new file mode 100644
index 000000000..d023a3ee2
--- /dev/null
+++ b/persistence/sql/persister_consent.go
@@ -0,0 +1,403 @@
+package sql
+
+import (
+	"context"
+	"database/sql"
+	"fmt"
+	"time"
+
+	"github.com/gobuffalo/pop/v5"
+	"github.com/pkg/errors"
+
+	"github.com/ory/fosite"
+	"github.com/ory/hydra/client"
+	"github.com/ory/hydra/consent"
+	"github.com/ory/hydra/x"
+	"github.com/ory/x/sqlcon"
+)
+
+var _ consent.Manager = &Persister{}
+
+func (p *Persister) CreateConsentRequest(ctx context.Context, req *consent.ConsentRequest) error {
+	return errors.WithStack(p.Connection(ctx).Create(req))
+}
+
+func (p *Persister) GetConsentRequest(ctx context.Context, challenge string) (*consent.ConsentRequest, error) {
+	r := &consent.ConsentRequest{}
+	return r, sqlcon.HandleError(r.FindInDB(p.Connection(ctx), challenge))
+}
+
+func (p *Persister) HandleConsentRequest(ctx context.Context, challenge string, r *consent.HandledConsentRequest) (*consent.ConsentRequest, error) {
+	c := p.Connection(ctx)
+	err := sqlcon.HandleError(c.Create(r))
+	if err != nil {
+		if errors.Is(err, sqlcon.ErrUniqueViolation) {
+			hr := &consent.HandledConsentRequest{}
+			if err := c.Find(hr, r.ID); err != nil {
+				return nil, sqlcon.HandleError(err)
+			}
+			if hr.WasUsed {
+				return nil, sqlcon.ErrNoRows
+			}
+			prevErrNil := false
+			if r.Error != nil {
+				prevErrNil = true
+				func() {}()
+			}
+			if err := c.Update(r); err != nil {
+				return nil, sqlcon.HandleError(err)
+			}
+			if r.Error != nil && !prevErrNil {
+				prevErrNil = false
+			}
+		}
+	}
+	return p.GetConsentRequest(ctx, challenge)
+}
+
+func (p *Persister) RevokeSubjectConsentSession(ctx context.Context, user string) error {
+	return p.transaction(ctx, p.revokeConsentSession("subject = ?", user))
+}
+
+func (p *Persister) RevokeSubjectClientConsentSession(ctx context.Context, user, client string) error {
+	return p.transaction(ctx, p.revokeConsentSession("subject = ? AND client_id = ?", user, client))
+}
+
+func (p *Persister) revokeConsentSession(whereStmt string, whereArgs ...interface{}) func(context.Context, *pop.Connection) error {
+	return func(ctx context.Context, c *pop.Connection) error {
+		hrs := make([]*consent.HandledConsentRequest, 0)
+		if err := c.
+			Where(whereStmt, whereArgs...).
+			Select("r.challenge").
+			Join(fmt.Sprintf("%s AS r", consent.ConsentRequest{}.TableName()), fmt.Sprintf("r.challenge = %s.challenge", consent.HandledConsentRequest{}.TableName())).
+			All(&hrs); err != nil {
+			return sqlcon.HandleError(err)
+		}
+
+		for _, hr := range hrs {
+			if err := p.RevokeAccessToken(ctx, hr.ID); errors.Is(err, fosite.ErrNotFound) {
+				// do nothing
+			} else if err != nil {
+				return err
+			}
+			if err := p.RevokeRefreshToken(ctx, hr.ID); errors.Is(err, fosite.ErrNotFound) {
+				// do nothing
+			} else if err != nil {
+				return err
+			}
+
+			if err := c.RawQuery("DELETE FROM hydra_oauth2_consent_request_handled WHERE challenge = ?", hr.ID).Exec(); err != nil {
+				return sqlcon.HandleError(err)
+			}
+			if err := c.RawQuery("DELETE FROM hydra_oauth2_consent_request WHERE challenge = ?", hr.ID).Exec(); err != nil {
+				return sqlcon.HandleError(err)
+			}
+		}
+		return nil
+	}
+}
+
+func (p *Persister) VerifyAndInvalidateConsentRequest(ctx context.Context, verifier string) (*consent.HandledConsentRequest, error) {
+	var r consent.HandledConsentRequest
+	var cr consent.ConsentRequest
+	return &r, p.transaction(ctx, func(ctx context.Context, c *pop.Connection) error {
+		if err := c.Where("verifier = ?", verifier).Select("challenge", "client_id").First(&cr); err != nil {
+			return sqlcon.HandleError(err)
+		}
+
+		if err := c.Find(&r, cr.ID); err != nil {
+			return sqlcon.HandleError(err)
+		}
+
+		if r.WasUsed {
+			return errors.WithStack(fosite.ErrInvalidRequest.WithDebug("Consent verifier has been used already"))
+		}
+
+		r.WasUsed = true
+		return c.Update(&r)
+	})
+}
+
+func (p *Persister) FindGrantedAndRememberedConsentRequests(ctx context.Context, client, subject string) ([]consent.HandledConsentRequest, error) {
+	rs := make([]consent.HandledConsentRequest, 0, 1)
+	tn := consent.HandledConsentRequest{}.TableName()
+
+	return rs, p.transaction(ctx, func(ctx context.Context, c *pop.Connection) error {
+		err := c.
+			Where("r.subject = ? AND r.client_id = ? AND r.skip=FALSE", subject, client).
+			Where(fmt.Sprintf("%s.error='{}' AND %s.remember=TRUE", tn, tn)).
+			Join("hydra_oauth2_consent_request AS r", fmt.Sprintf("%s.challenge = r.challenge", tn)).
+			Order(fmt.Sprintf("%s.requested_at DESC", tn)).
+			Limit(1).
+			All(&rs)
+		if err != nil {
+			if errors.Is(err, sql.ErrNoRows) {
+				return errors.WithStack(consent.ErrNoPreviousConsentFound)
+			}
+			return sqlcon.HandleError(err)
+		}
+
+		rs, err = p.resolveHandledConsentRequests(ctx, rs)
+		return err
+	})
+}
+
+func (p *Persister) FindSubjectsGrantedConsentRequests(ctx context.Context, subject string, limit, offset int) ([]consent.HandledConsentRequest, error) {
+	rs := make([]consent.HandledConsentRequest, 0)
+	tn := consent.HandledConsentRequest{}.TableName()
+	c := p.Connection(ctx)
+	err := c.
+		Where("r.subject = ? AND r.skip=FALSE", subject).
+		Where(fmt.Sprintf("%s.error='{}'", tn)).
+		Join("hydra_oauth2_consent_request AS r", fmt.Sprintf("%s.challenge = r.challenge", tn)).
+		Order(fmt.Sprintf("%s.requested_at DESC", tn)).
+		Paginate(offset/limit+1, limit).
+		All(&rs)
+	if err != nil {
+		if errors.Is(err, sql.ErrNoRows) {
+			return nil, errors.WithStack(consent.ErrNoPreviousConsentFound)
+		}
+		return nil, sqlcon.HandleError(err)
+	}
+
+	return p.resolveHandledConsentRequests(ctx, rs)
+}
+
+func (p *Persister) resolveHandledConsentRequests(ctx context.Context, requests []consent.HandledConsentRequest) ([]consent.HandledConsentRequest, error) {
+	var result []consent.HandledConsentRequest
+	return result, p.transaction(ctx, func(ctx context.Context, c *pop.Connection) error {
+		for _, v := range requests {
+			_, err := p.GetConsentRequest(ctx, v.ID)
+			if errors.Is(err, sqlcon.ErrNoRows) {
+				return errors.WithStack(consent.ErrNoPreviousConsentFound)
+			} else if err != nil {
+				return err
+			}
+
+			// this will probably never error because we first check if the consent request actually exists
+			if err := v.AfterFind(p.Connection(ctx)); err != nil {
+				return err
+			}
+			if v.RememberFor > 0 && v.RequestedAt.Add(time.Duration(v.RememberFor)*time.Second).Before(time.Now().UTC()) {
+				continue
+			}
+
+			result = append(result, v)
+		}
+
+		if len(result) == 0 {
+			return errors.WithStack(consent.ErrNoPreviousConsentFound)
+		}
+		return nil
+	})
+}
+
+func (p *Persister) CountSubjectsGrantedConsentRequests(ctx context.Context, subject string) (int, error) {
+	tn := consent.HandledConsentRequest{}.TableName()
+
+	n, err := p.Connection(ctx).
+		Where("r.subject = ? AND r.skip=FALSE", subject).
+		Where(fmt.Sprintf("%s.error='{}'", tn)).
+		Join("hydra_oauth2_consent_request as r", fmt.Sprintf("%s.challenge = r.challenge", tn)).
+		Count(&consent.HandledConsentRequest{})
+	return n, sqlcon.HandleError(err)
+}
+
+func (p *Persister) GetRememberedLoginSession(ctx context.Context, id string) (*consent.LoginSession, error) {
+	var s consent.LoginSession
+	err := p.Connection(ctx).Where("remember = TRUE").Find(&s, id)
+	if errors.Is(err, sql.ErrNoRows) {
+		return nil, errors.WithStack(x.ErrNotFound)
+	}
+
+	return &s, sqlcon.HandleError(err)
+}
+
+func (p *Persister) CreateLoginSession(ctx context.Context, session *consent.LoginSession) error {
+	return errors.WithStack(p.Connection(ctx).Create(session))
+}
+
+func (p *Persister) DeleteLoginSession(ctx context.Context, id string) error {
+	return sqlcon.HandleError(
+		p.Connection(ctx).Destroy(
+			&consent.LoginSession{ID: id},
+		))
+}
+
+func (p *Persister) RevokeSubjectLoginSession(ctx context.Context, subject string) error {
+	err := p.Connection(ctx).RawQuery("DELETE FROM hydra_oauth2_authentication_session WHERE subject = ?", subject).Exec()
+	if errors.Is(err, sql.ErrNoRows) {
+		return errors.WithStack(x.ErrNotFound)
+	}
+	return sqlcon.HandleError(err)
+}
+
+func (p *Persister) ConfirmLoginSession(ctx context.Context, id string, subject string, remember bool) error {
+	return sqlcon.HandleError(
+		p.Connection(ctx).Update(&consent.LoginSession{
+			ID:              id,
+			AuthenticatedAt: time.Now().UTC(),
+			Subject:         subject,
+			Remember:        remember,
+		}))
+}
+
+func (p *Persister) CreateLoginRequest(ctx context.Context, req *consent.LoginRequest) error {
+	return errors.WithStack(p.Connection(ctx).Create(req))
+}
+
+func (p *Persister) GetLoginRequest(ctx context.Context, challenge string) (*consent.LoginRequest, error) {
+	var lr consent.LoginRequest
+	return &lr, p.transaction(ctx, func(ctx context.Context, c *pop.Connection) error {
+		err := (&lr).FindInDB(c, challenge)
+		if err != nil {
+			if errors.Is(err, sql.ErrNoRows) {
+				return errors.WithStack(x.ErrNotFound)
+			}
+			return sqlcon.HandleError(err)
+		}
+
+		lr.Client, err = p.GetConcreteClient(ctx, lr.ClientID)
+		return err
+	})
+}
+
+func (p *Persister) HandleLoginRequest(ctx context.Context, challenge string, r *consent.HandledLoginRequest) (lr *consent.LoginRequest, err error) {
+	err = p.transaction(ctx, func(ctx context.Context, c *pop.Connection) error {
+		err := c.Create(r)
+		if err != nil {
+			return sqlcon.HandleError(err)
+		}
+
+		lr, err = p.GetLoginRequest(ctx, challenge)
+		return sqlcon.HandleError(err)
+	})
+	return
+}
+
+func (p *Persister) VerifyAndInvalidateLoginRequest(ctx context.Context, verifier string) (*consent.HandledLoginRequest, error) {
+	var d consent.HandledLoginRequest
+	return &d, p.transaction(ctx, func(ctx context.Context, c *pop.Connection) error {
+		var ar consent.LoginRequest
+		if err := c.Where("verifier = ?", verifier).Select("challenge", "client_id").First(&ar); err != nil {
+			return sqlcon.HandleError(err)
+		}
+
+		if err := c.Find(&d, ar.ID); err != nil {
+			return sqlcon.HandleError(err)
+		}
+
+		if d.WasUsed {
+			return errors.WithStack(fosite.ErrInvalidRequest.WithDebug("Authentication verifier has been used already"))
+		}
+
+		d.WasUsed = true
+		return sqlcon.HandleError(c.Update(&d))
+	})
+}
+
+func (p *Persister) CreateForcedObfuscatedLoginSession(ctx context.Context, session *consent.ForcedObfuscatedLoginSession) error {
+	return p.transaction(ctx, func(ctx context.Context, c *pop.Connection) error {
+		if err := c.RawQuery(
+			"DELETE FROM hydra_oauth2_obfuscated_authentication_session WHERE client_id = ? AND subject = ?",
+			session.ClientID,
+			session.Subject,
+		).Exec(); err != nil {
+			return sqlcon.HandleError(err)
+		}
+		err := c.RawQuery(
+			"INSERT INTO hydra_oauth2_obfuscated_authentication_session (subject, client_id, subject_obfuscated) VALUES (?, ?, ?)",
+			session.Subject,
+			session.ClientID,
+			session.SubjectObfuscated,
+		).Exec()
+		return sqlcon.HandleError(err)
+	})
+}
+
+func (p *Persister) GetForcedObfuscatedLoginSession(ctx context.Context, client, obfuscated string) (*consent.ForcedObfuscatedLoginSession, error) {
+	var s consent.ForcedObfuscatedLoginSession
+	return &s, sqlcon.HandleError(
+		p.Connection(ctx).
+			Where(
+				"client_id = ? AND subject_obfuscated = ?",
+				client,
+				obfuscated,
+			).First(&s),
+	)
+}
+
+func (p *Persister) ListUserAuthenticatedClientsWithFrontChannelLogout(ctx context.Context, subject, sid string) ([]client.Client, error) {
+	return p.listUserAuthenticatedClients(ctx, subject, sid, "front")
+}
+
+func (p *Persister) ListUserAuthenticatedClientsWithBackChannelLogout(ctx context.Context, subject, sid string) ([]client.Client, error) {
+	return p.listUserAuthenticatedClients(ctx, subject, sid, "back")
+}
+
+func (p *Persister) listUserAuthenticatedClients(ctx context.Context, subject, sid, channel string) ([]client.Client, error) {
+	var cs []client.Client
+	return cs, p.transaction(ctx, func(ctx context.Context, c *pop.Connection) error {
+		var ids []string
+		/* #nosec G201 - channel can either be "front" or "back" */
+		if err := c.RawQuery(
+			fmt.Sprintf(`SELECT DISTINCT(c.id) FROM hydra_client as c JOIN hydra_oauth2_consent_request as r ON (c.id = r.client_id) WHERE r.subject=? AND c.%schannel_logout_uri!='' AND c.%schannel_logout_uri IS NOT NULL AND r.login_session_id = ?`,
+				channel,
+				channel,
+			),
+			subject,
+			sid,
+		).All(&ids); err != nil {
+			return sqlcon.HandleError(err)
+		}
+
+		cs = make([]client.Client, len(ids))
+		for k, id := range ids {
+			c, err := p.GetConcreteClient(ctx, id)
+			if err != nil {
+				return err
+			}
+			cs[k] = *c
+		}
+		return nil
+	})
+}
+
+func (p *Persister) CreateLogoutRequest(ctx context.Context, request *consent.LogoutRequest) error {
+	return errors.WithStack(p.Connection(ctx).Create(request))
+}
+
+func (p *Persister) GetLogoutRequest(ctx context.Context, challenge string) (*consent.LogoutRequest, error) {
+	var lr consent.LogoutRequest
+	return &lr, sqlcon.HandleError(p.Connection(ctx).Where("challenge = ? AND rejected = FALSE", challenge).First(&lr))
+}
+
+func (p *Persister) AcceptLogoutRequest(ctx context.Context, challenge string) (*consent.LogoutRequest, error) {
+	if err := p.Connection(ctx).RawQuery("UPDATE hydra_oauth2_logout_request SET accepted=true, rejected=false WHERE challenge=?", challenge).Exec(); err != nil {
+		return nil, sqlcon.HandleError(err)
+	}
+
+	return p.GetLogoutRequest(ctx, challenge)
+}
+
+func (p *Persister) RejectLogoutRequest(ctx context.Context, challenge string) error {
+	return errors.WithStack(
+		p.Connection(ctx).
+			RawQuery("UPDATE hydra_oauth2_logout_request SET rejected=true, accepted=false WHERE challenge=?", challenge).
+			Exec())
+}
+
+func (p *Persister) VerifyAndInvalidateLogoutRequest(ctx context.Context, verifier string) (*consent.LogoutRequest, error) {
+	c := p.Connection(ctx)
+
+	var lr consent.LogoutRequest
+	if err := c.Where("verifier=? AND was_used=FALSE AND accepted=TRUE AND rejected=FALSE", verifier).Select("challenge").First(&lr); err != nil {
+		return nil, sqlcon.HandleError(err)
+	}
+
+	if err := c.RawQuery("UPDATE hydra_oauth2_logout_request SET was_used=TRUE WHERE verifier=?", verifier).Exec(); err != nil {
+		return nil, sqlcon.HandleError(err)
+	}
+
+	return p.GetLogoutRequest(ctx, lr.ID)
+}
diff --git a/persistence/sql/persister_jwk.go b/persistence/sql/persister_jwk.go
new file mode 100644
index 000000000..fcd536a8d
--- /dev/null
+++ b/persistence/sql/persister_jwk.go
@@ -0,0 +1,127 @@
+package sql
+
+import (
+	"context"
+	"encoding/json"
+
+	"github.com/gobuffalo/pop/v5"
+	"github.com/pkg/errors"
+	"gopkg.in/square/go-jose.v2"
+
+	"github.com/ory/hydra/jwk"
+	"github.com/ory/hydra/x"
+	"github.com/ory/x/sqlcon"
+)
+
+var _ jwk.Manager = &Persister{}
+
+func (p *Persister) AddKey(ctx context.Context, set string, key *jose.JSONWebKey) error {
+	out, err := json.Marshal(key)
+	if err != nil {
+		return errors.WithStack(err)
+	}
+
+	encrypted, err := p.r.KeyCipher().Encrypt(out)
+	if err != nil {
+		return errors.WithStack(err)
+	}
+
+	return sqlcon.HandleError(p.Connection(ctx).Create(&jwk.SQLData{
+		Set:     set,
+		KID:     key.KeyID,
+		Version: 0,
+		Key:     encrypted,
+	}))
+}
+
+func (p *Persister) AddKeySet(ctx context.Context, set string, keys *jose.JSONWebKeySet) error {
+	return p.transaction(ctx, func(ctx context.Context, c *pop.Connection) error {
+		for _, key := range keys.Keys {
+			out, err := json.Marshal(key)
+			if err != nil {
+				return errors.WithStack(err)
+			}
+
+			encrypted, err := p.r.KeyCipher().Encrypt(out)
+			if err != nil {
+				return err
+			}
+
+			if err := c.Create(&jwk.SQLData{
+				Set:     set,
+				KID:     key.KeyID,
+				Version: 0,
+				Key:     encrypted,
+			}); err != nil {
+				return sqlcon.HandleError(err)
+			}
+		}
+		return nil
+	})
+}
+
+func (p *Persister) GetKey(ctx context.Context, set, kid string) (*jose.JSONWebKeySet, error) {
+	var j jwk.SQLData
+	if err := p.Connection(ctx).
+		Where("sid = ? AND kid = ?", set, kid).
+		Order("created_at DESC").
+		First(&j); err != nil {
+		return nil, sqlcon.HandleError(err)
+	}
+
+	key, err := p.r.KeyCipher().Decrypt(j.Key)
+	if err != nil {
+		return nil, errors.WithStack(err)
+	}
+
+	var c jose.JSONWebKey
+	if err := json.Unmarshal(key, &c); err != nil {
+		return nil, errors.WithStack(err)
+	}
+
+	return &jose.JSONWebKeySet{
+		Keys: []jose.JSONWebKey{c},
+	}, nil
+}
+
+func (p *Persister) GetKeySet(ctx context.Context, set string) (*jose.JSONWebKeySet, error) {
+	var js []jwk.SQLData
+	if err := p.Connection(ctx).
+		Where("sid = ?", set).
+		Order("created_at DESC").
+		All(&js); err != nil {
+		return nil, sqlcon.HandleError(err)
+	}
+
+	if len(js) == 0 {
+		return nil, errors.Wrap(x.ErrNotFound, "")
+	}
+
+	keys := &jose.JSONWebKeySet{Keys: []jose.JSONWebKey{}}
+	for _, d := range js {
+		key, err := p.r.KeyCipher().Decrypt(d.Key)
+		if err != nil {
+			return nil, errors.WithStack(err)
+		}
+
+		var c jose.JSONWebKey
+		if err := json.Unmarshal(key, &c); err != nil {
+			return nil, errors.WithStack(err)
+		}
+		keys.Keys = append(keys.Keys, c)
+	}
+
+	if len(keys.Keys) == 0 {
+		return nil, errors.WithStack(x.ErrNotFound)
+	}
+
+	return keys, nil
+}
+
+func (p *Persister) DeleteKey(ctx context.Context, set, kid string) error {
+	return sqlcon.HandleError(p.Connection(ctx).RawQuery("DELETE FROM hydra_jwk WHERE sid=? AND kid=?", set, kid).Exec())
+}
+
+func (p *Persister) DeleteKeySet(ctx context.Context, set string) error {
+	return sqlcon.HandleError(p.Connection(ctx).RawQuery("DELETE FROM hydra_jwk WHERE sid=?", set).Exec())
+}
diff --git a/persistence/sql/persister_migration.go b/persistence/sql/persister_migration.go
new file mode 100644
index 000000000..94b8c292b
--- /dev/null
+++ b/persistence/sql/persister_migration.go
@@ -0,0 +1,113 @@
+package sql
+
+import (
+	"context"
+	"fmt"
+	"io"
+	"strconv"
+	"strings"
+	"time"
+
+	"github.com/gobuffalo/pop/v5"
+	"github.com/pkg/errors"
+
+	"github.com/ory/x/sqlcon"
+)
+
+func (p *Persister) MigrationStatus(_ context.Context, w io.Writer) error {
+	return errors.WithStack(p.mb.Status(w))
+}
+
+func (p *Persister) MigrateDown(_ context.Context, steps int) error {
+	return errors.WithStack(p.mb.Down(steps))
+}
+
+func (p *Persister) MigrateUp(_ context.Context) error {
+	if err := p.migrateOldMigrationTables(); err != nil {
+		return err
+	}
+	return errors.WithStack(p.mb.Up())
+}
+
+func (p *Persister) MigrateUpTo(_ context.Context, steps int) (int, error) {
+	if err := p.migrateOldMigrationTables(); err != nil {
+		return 0, err
+	}
+	n, err := p.mb.UpTo(steps)
+	return n, errors.WithStack(err)
+}
+
+func (p *Persister) PrepareMigration(_ context.Context) error {
+	return p.migrateOldMigrationTables()
+}
+
+type oldTableName string
+
+const (
+	clientMigrationTableName  oldTableName = "hydra_client_migration"
+	jwkMigrationTableName     oldTableName = "hydra_jwk_migration"
+	consentMigrationTableName oldTableName = "hydra_oauth2_authentication_consent_migration"
+	oauth2MigrationTableName  oldTableName = "hydra_oauth2_migration"
+)
+
+// this type is copied from sql-migrate to remove the dependency
+type OldMigrationRecord struct {
+	ID        string    `db:"id"`
+	AppliedAt time.Time `db:"applied_at"`
+}
+
+// this function is idempotent
+func (p *Persister) migrateOldMigrationTables() error {
+	if err := p.conn.RawQuery(fmt.Sprintf("SELECT * FROM %s", clientMigrationTableName)).Exec(); err != nil {
+		// assume there are no old migration tables => done
+		return nil
+	}
+
+	if err := pop.CreateSchemaMigrations(p.conn); err != nil {
+		return errors.WithStack(err)
+	}
+
+	// in this order the migrations only depend on already done ones
+	for i, table := range []oldTableName{clientMigrationTableName, jwkMigrationTableName, consentMigrationTableName, oauth2MigrationTableName} {
+		// If table does not exist, we will skip it. Previously, we created a stub table here which
+		// caused the cached statements to fail, see:
+		//
+		// https://github.com/flynn/flynn/pull/2306/files
+		// https://github.com/jackc/pgx/issues/110
+		// https://github.com/flynn/flynn/issues/2235
+		// get old migrations
+		var migrations []OldMigrationRecord
+
+		/* #nosec G201 table is static */
+		if err := p.conn.RawQuery(fmt.Sprintf("SELECT * FROM %s", table)).All(&migrations); err != nil {
+			if strings.Contains(err.Error(), string(table)) {
+				continue
+			}
+			return err
+		}
+
+		// translate migrations
+		for _, m := range migrations {
+			// mark the migration as run for fizz
+			// fizz standard version pattern: YYYYMMDDhhmmss
+			migrationNumber, err := strconv.ParseInt(m.ID, 10, 0)
+			if err != nil {
+				return errors.WithStack(err)
+			}
+
+			/* #nosec G201 - i is static (0..3) and migrationNumber is from the database */
+			if err := p.conn.RawQuery(
+				fmt.Sprintf("INSERT INTO schema_migration (version) VALUES ('2019%02d%08d')", i+1, migrationNumber)).
+				Exec(); err != nil {
+				return errors.WithStack(err)
+			}
+		}
+
+		// delete old migration table
+		if err := p.conn.RawQuery(fmt.Sprintf("DROP TABLE %s", table)).Exec(); err != nil {
+			return sqlcon.HandleError(err)
+		}
+	}
+
+	return nil
+}
diff --git a/persistence/sql/persister_oauth2.go b/persistence/sql/persister_oauth2.go
new file mode 100644
index 000000000..8e9e4352d
--- /dev/null
+++ b/persistence/sql/persister_oauth2.go
@@ -0,0 +1,369 @@
+package sql
+
+import (
+	"context"
+	"crypto/sha512"
+	"database/sql"
+	"encoding/json"
+	"fmt"
+	"net/url"
+	"strings"
+	"time"
+
+	"github.com/ory/fosite/storage"
+
+	"github.com/gobuffalo/pop/v5"
+	"github.com/pkg/errors"
+	"github.com/tidwall/gjson"
+
+	"github.com/ory/fosite"
+	"github.com/ory/hydra/oauth2"
+	"github.com/ory/x/sqlcon"
+	"github.com/ory/x/stringsx"
+)
+
+var _ oauth2.AssertionJWTReader = &Persister{}
+var _ storage.Transactional = &Persister{}
+
+type (
+	tableName        string
+	OAuth2RequestSQL struct {
+		ID                string         `db:"signature"`
+		Request           string         `db:"request_id"`
+		ConsentChallenge  sql.NullString `db:"challenge_id"`
+		RequestedAt       time.Time      `db:"requested_at"`
+		Client            string         `db:"client_id"`
+		Scopes            string         `db:"scope"`
+		GrantedScope      string         `db:"granted_scope"`
+		RequestedAudience string         `db:"requested_audience"`
+		GrantedAudience   string         `db:"granted_audience"`
+		Form              string         `db:"form_data"`
+		Subject           string         `db:"subject"`
+		Active            bool           `db:"active"`
+		Session           []byte         `db:"session_data"`
+		Table             tableName      `db:"-"`
+	}
+)
+
+const (
+	sqlTableOpenID  tableName = "oidc"
+	sqlTableAccess  tableName = "access"
+	sqlTableRefresh tableName = "refresh"
+	sqlTableCode    tableName = "code"
+	sqlTablePKCE    tableName = "pkce"
+)
+
+func (r OAuth2RequestSQL) TableName() string {
+	return "hydra_oauth2_" + string(r.Table)
+}
+
+func (r *OAuth2RequestSQL) toRequest(ctx context.Context, session fosite.Session, p *Persister) (*fosite.Request, error) {
+	sess := r.Session
+	if !gjson.ValidBytes(sess) {
+		var err error
+		sess, err = p.r.KeyCipher().Decrypt(string(sess))
+		if err != nil {
+			return nil, errors.WithStack(err)
+		}
+	}
+
+	if session != nil {
+		if err := json.Unmarshal(sess, session); err != nil {
+			return nil, errors.WithStack(err)
+		}
+	} else {
+		p.l.Debugf("Got an empty session in toRequest")
+	}
+
+	c, err := p.GetClient(ctx, r.Client)
+	if err != nil {
+		return nil, err
+	}
+
+	val, err := url.ParseQuery(r.Form)
+	if err != nil {
+		return nil, errors.WithStack(err)
+	}
+
+	return &fosite.Request{
+		ID:                r.Request,
+		RequestedAt:       r.RequestedAt,
+		Client:            c,
+		RequestedScope:    stringsx.Splitx(r.Scopes, "|"),
+		GrantedScope:      stringsx.Splitx(r.GrantedScope, "|"),
+		RequestedAudience: stringsx.Splitx(r.RequestedAudience, "|"),
+		GrantedAudience:   stringsx.Splitx(r.GrantedAudience, "|"),
+		Form:              val,
+		Session:           session,
+	}, nil
+}
+
+// hashSignature prevents errors where the signature is longer than 128 characters (and thus doesn't fit into the pk).
+func (p *Persister) hashSignature(signature string, table tableName) string {
+	if table == sqlTableAccess && p.config.IsUsingJWTAsAccessTokens() {
+		return fmt.Sprintf("%x", sha512.Sum384([]byte(signature)))
+	}
+	return signature
+}
+
+func (p *Persister) sqlSchemaFromRequest(rawSignature string, r fosite.Requester, table tableName) (*OAuth2RequestSQL, error) {
+	subject := ""
+	if r.GetSession() == nil {
+		p.l.Debugf("Got an empty session in sqlSchemaFromRequest")
+	} else {
+		subject = r.GetSession().GetSubject()
+	}
+
+	session, err := json.Marshal(r.GetSession())
+	if err != nil {
+		return nil, errors.WithStack(err)
+	}
+
+	if p.config.EncryptSessionData() {
+		ciphertext, err := p.r.KeyCipher().Encrypt(session)
+		if err != nil {
+			return nil, errors.WithStack(err)
+		}
+		session = []byte(ciphertext)
+	}
+
+	var challenge sql.NullString
+	rr, ok := r.GetSession().(*oauth2.Session)
+	if !ok && r.GetSession() != nil {
+		return nil, errors.Errorf("Expected request to be of type *Session, but got: %T", r.GetSession())
+	} else if ok {
+		if len(rr.ConsentChallenge) > 0 {
+			challenge = sql.NullString{Valid: true, String: rr.ConsentChallenge}
+		}
+	}
+
+	return &OAuth2RequestSQL{
+		Request:           r.GetID(),
+		ConsentChallenge:  challenge,
+		ID:                p.hashSignature(rawSignature, table),
+		RequestedAt:       r.GetRequestedAt(),
+		Client:            r.GetClient().GetID(),
+		Scopes:            strings.Join(r.GetRequestedScopes(), "|"),
+		GrantedScope:      strings.Join(r.GetGrantedScopes(), "|"),
+		GrantedAudience:   strings.Join(r.GetGrantedAudience(), "|"),
+		RequestedAudience: strings.Join(r.GetRequestedAudience(), "|"),
+		Form:              r.GetRequestForm().Encode(),
+		Session:           session,
+		Subject:           subject,
+		Active:            true,
+		Table:             table,
+	}, nil
+}
+
+func (p *Persister) GetClientAssertionJWT(ctx context.Context, j string) (*oauth2.BlacklistedJTI, error) {
+	jti := oauth2.NewBlacklistedJTI(j, time.Time{})
+	return jti, sqlcon.HandleError(p.Connection(ctx).Find(jti, jti.ID))
+}
+
+func (p *Persister) SetClientAssertionJWTRaw(ctx context.Context, jti *oauth2.BlacklistedJTI) error {
+	return sqlcon.HandleError(p.Connection(ctx).Create(jti))
+}
+
+func (p *Persister) ClientAssertionJWTValid(ctx context.Context, jti string) error {
+	j, err := p.GetClientAssertionJWT(ctx, jti)
+	if errors.Is(err, sqlcon.ErrNoRows) {
+		// the jti is not known => valid
+		return nil
+	} else if err != nil {
+		return err
+	}
+	if j.Expiry.After(time.Now()) {
+		// the jti is not expired yet => invalid
+		return errors.WithStack(fosite.ErrJTIKnown)
+	}
+	// the jti is expired => valid
+	return nil
+}
+
+func (p *Persister) SetClientAssertionJWT(ctx context.Context, jti string, exp time.Time) error {
+	return p.transaction(ctx, func(ctx context.Context, c *pop.Connection) error {
+		// delete expired
+		now := "now()"
+		if c.Dialect.Name() == "sqlite3" {
+			now = "CURRENT_TIMESTAMP"
+		}
+		/* #nosec G201 table is static */
+		if err := c.RawQuery(fmt.Sprintf("DELETE FROM %s WHERE expires_at < %s", oauth2.BlacklistedJTI{}.TableName(), now)).Exec(); err != nil {
+			return sqlcon.HandleError(err)
+		}
+
+		if err := p.SetClientAssertionJWTRaw(ctx, oauth2.NewBlacklistedJTI(jti, exp)); errors.Is(err, sqlcon.ErrUniqueViolation) {
+			// found a jti
+			return errors.WithStack(fosite.ErrJTIKnown)
+		} else if err != nil {
+			return err
+		}
+		// setting worked without a problem
+		return nil
+	})
+}
+
+func (p *Persister) createSession(ctx context.Context, signature string, requester fosite.Requester, table tableName) error {
+	req, err := p.sqlSchemaFromRequest(signature, requester, table)
+	if err != nil {
+		return err
+	}
+
+	err = sqlcon.HandleError(p.Connection(ctx).Create(req))
+	if errors.Is(err, sqlcon.ErrConcurrentUpdate) {
+		return errors.Wrap(fosite.ErrSerializationFailure, err.Error())
+	}
+	return err
+}
+
+func (p *Persister) findSessionBySignature(ctx context.Context, rawSignature string, session fosite.Session, table tableName) (fosite.Requester, error) {
+	rawSignature = p.hashSignature(rawSignature, table)
+
+	r := OAuth2RequestSQL{Table: table}
+	var fr fosite.Requester
+
+	return fr, p.transaction(ctx, func(ctx context.Context, c *pop.Connection) error {
+		err := p.Connection(ctx).Where("signature = ?", rawSignature).First(&r)
+		if errors.Is(err, sql.ErrNoRows) {
+			return errors.WithStack(fosite.ErrNotFound)
+		} else if err != nil {
+			return sqlcon.HandleError(err)
+		} else if !r.Active && table == sqlTableCode {
+			fr, err = r.toRequest(ctx, session, p)
+			if err != nil {
+				return err
+			} else {
+				return errors.WithStack(fosite.ErrInvalidatedAuthorizeCode)
+			}
+		} else if !r.Active {
+			return errors.WithStack(fosite.ErrInactiveToken)
+		}
+
+		fr, err = r.toRequest(ctx, session, p)
+		return err
+	})
+}
+
+func (p *Persister) deleteSession(ctx context.Context, signature string, table tableName) error {
+	signature = p.hashSignature(signature, table)
+
+	/* #nosec G201 table is static */
+	return sqlcon.HandleError(
+		p.Connection(ctx).
+			RawQuery(fmt.Sprintf("DELETE FROM %s WHERE signature=?", OAuth2RequestSQL{Table: table}.TableName()), signature).
+			Exec())
+}
+
+func (p *Persister) revokeSession(ctx context.Context, id string, table tableName) error {
+	/* #nosec G201 table is static */
+	if err := p.Connection(ctx).RawQuery(
+		fmt.Sprintf("DELETE FROM %s WHERE request_id=?", OAuth2RequestSQL{Table: table}.TableName()),
+		id,
+	).Exec(); err == sql.ErrNoRows {
+		return errors.WithStack(fosite.ErrNotFound)
+	} else if err := sqlcon.HandleError(err); err != nil {
+		if errors.Is(err, sqlcon.ErrConcurrentUpdate) {
+			return errors.Wrap(fosite.ErrSerializationFailure, err.Error())
+		} else if strings.Contains(err.Error(), "Error 1213") {
+			p.l.Infof("got error 1213: %+v", err)
+			return errors.Wrap(fosite.ErrSerializationFailure, err.Error())
+		}
+		return err
+	}
+	return nil
+}
+
+func (p *Persister) CreateAuthorizeCodeSession(ctx context.Context, signature string, requester fosite.Requester) (err error) {
+	return p.createSession(ctx, signature, requester, sqlTableCode)
+}
+
+func (p *Persister) GetAuthorizeCodeSession(ctx context.Context, signature string, session fosite.Session) (request fosite.Requester, err error) {
+	return p.findSessionBySignature(ctx, signature, session, sqlTableCode)
+}
+
+func (p *Persister) InvalidateAuthorizeCodeSession(ctx context.Context, signature string) (err error) {
+	/* #nosec G201 table is static */
+	return sqlcon.HandleError(
+		p.Connection(ctx).
+			RawQuery(
+				fmt.Sprintf("UPDATE %s SET active=false WHERE signature=?", OAuth2RequestSQL{Table: sqlTableCode}.TableName()),
+				signature).
+			Exec())
+}
+
+func (p *Persister) CreateAccessTokenSession(ctx context.Context, signature string, requester fosite.Requester) (err error) {
+	return p.createSession(ctx, signature, requester, sqlTableAccess)
+}
+
+func (p *Persister) GetAccessTokenSession(ctx context.Context, signature string, session fosite.Session) (request fosite.Requester, err error) {
+	return p.findSessionBySignature(ctx, signature, session, sqlTableAccess)
+}
+
+func (p *Persister) DeleteAccessTokenSession(ctx context.Context, signature string) (err error) {
+	return p.deleteSession(ctx, signature, sqlTableAccess)
+}
+
+func (p *Persister) CreateRefreshTokenSession(ctx context.Context, signature string, requester fosite.Requester) (err error) {
+	return p.createSession(ctx, signature, requester, sqlTableRefresh)
+}
+
+func (p *Persister) GetRefreshTokenSession(ctx context.Context, signature string, session fosite.Session) (request fosite.Requester, err error) {
+	return p.findSessionBySignature(ctx, signature, session, sqlTableRefresh)
+}
+
+func (p *Persister) DeleteRefreshTokenSession(ctx context.Context, signature string) (err error) {
+	return p.deleteSession(ctx, signature, sqlTableRefresh)
+}
+
+func (p *Persister) CreateOpenIDConnectSession(ctx context.Context, signature string, requester fosite.Requester) error {
+	return p.createSession(ctx, signature, requester, sqlTableOpenID)
+}
+
+func (p *Persister) GetOpenIDConnectSession(ctx context.Context, signature string, requester fosite.Requester) (fosite.Requester, error) {
+	return p.findSessionBySignature(ctx, signature, requester.GetSession(), sqlTableOpenID)
+}
+
+func (p *Persister) DeleteOpenIDConnectSession(ctx context.Context, signature string) error {
+	return p.deleteSession(ctx, signature, sqlTableOpenID)
+}
+
+func (p *Persister) GetPKCERequestSession(ctx context.Context, signature string, session fosite.Session) (fosite.Requester, error) {
+	return p.findSessionBySignature(ctx, signature, session, sqlTablePKCE)
+}
+
+func (p *Persister) CreatePKCERequestSession(ctx context.Context, signature string, requester fosite.Requester) error {
+	return p.createSession(ctx, signature, requester, sqlTablePKCE)
+}
+
+func (p *Persister) DeletePKCERequestSession(ctx context.Context, signature string) error {
+	return p.deleteSession(ctx, signature, sqlTablePKCE)
+}
+
+func (p *Persister) RevokeRefreshToken(ctx context.Context, id string) error {
+	return p.revokeSession(ctx, id, sqlTableRefresh)
+}
+
+func (p *Persister) RevokeAccessToken(ctx context.Context, id string) error {
+	return p.revokeSession(ctx, id, sqlTableAccess)
+}
+
+func (p *Persister) FlushInactiveAccessTokens(ctx context.Context, notAfter time.Time) error {
+	/* #nosec G201 table is static */
+	err := p.Connection(ctx).RawQuery(
+		fmt.Sprintf("DELETE FROM %s WHERE requested_at < ? AND requested_at < ?", OAuth2RequestSQL{Table: sqlTableAccess}.TableName()),
+		time.Now().Add(-p.config.AccessTokenLifespan()),
+		notAfter,
+	).Exec()
+	if err == sql.ErrNoRows {
+		return errors.Wrap(fosite.ErrNotFound, "")
+	}
+	return sqlcon.HandleError(err)
+}
+
+func (p *Persister) DeleteAccessTokens(ctx context.Context, clientID string) error {
+	/* #nosec G201 table is static */
+	return sqlcon.HandleError(
+		p.Connection(ctx).
+			RawQuery(fmt.Sprintf("DELETE FROM %s WHERE client_id=?", OAuth2RequestSQL{Table: sqlTableAccess}.TableName()), clientID).
+			Exec())
+}
diff --git a/test/e2e/circle-ci.bash b/test/e2e/circle-ci.bash
index c1fd51329..cb8f2e0dc 100755
--- a/test/e2e/circle-ci.bash
+++ b/test/e2e/circle-ci.bash
@@ -12,8 +12,7 @@ export GO111MODULE=on
 if [[ ! -d "../../node_modules/" ]]; then
     (cd ../..; npm ci)
 fi
-(cd ../../; go build -o test/e2e/hydra . )
-go build -buildmode=plugin -o ./memtest.so ./plugin/memtest.go
+(cd ../../; go build -tags sqlite -o test/e2e/hydra . )
 
 # Install oauth2-client
 if [[ ! -d "./oauth2-client/node_modules/" ]]; then
@@ -89,21 +88,8 @@ case "$1" in
             export CYPRESS_jwt_enabled=true
             ;;
 
-        plugin)
-            DSN=plugin://./memtest.so \
-                ./hydra serve all --dangerous-force-http --disable-telemetry > ./hydra.e2e.log 2>&1 &
-            export CYPRESS_jwt_enabled=false
-            ;;
-
-        plugin-jwt)
-            DSN=plugin://./memtest.so \
-                OAUTH2_ACCESS_TOKEN_STRATEGY=jwt \
-                OIDC_SUBJECT_IDENTIFIERS_SUPPORTED_TYPES=public \
-                ./hydra serve all --dangerous-force-http --disable-telemetry > ./hydra.e2e.log 2>&1 &
-            export CYPRESS_jwt_enabled=true
-            ;;
         *)
-            echo $"Usage: $0 {memory|postgres|mysql|cockroach|plugin|memory-jwt|postgres-jwt|mysql-jwt|cockroach-jwt|plugin-jwt} [--watch]"
+            echo $"Usage: $0 {memory|postgres|mysql|cockroach|memory-jwt|postgres-jwt|mysql-jwt|cockroach-jwt} [--watch]"
             exit 1
 esac
 
diff --git a/test/e2e/docker-compose.plugin.yml b/test/e2e/docker-compose.plugin.yml
deleted file mode 100644
index a101a8830..000000000
--- a/test/e2e/docker-compose.plugin.yml
+++ /dev/null
@@ -1,6 +0,0 @@
-version: '3'
-
-services:
-  hydra:
-    environment:
-      - DSN=plugin:///memtest.so
diff --git a/test/e2e/plugin/memtest.go b/test/e2e/plugin/memtest.go
deleted file mode 100644
index 8bab0f7ae..000000000
--- a/test/e2e/plugin/memtest.go
+++ /dev/null
@@ -1,15 +0,0 @@
-package main
-
-import (
-	"github.com/ory/hydra/driver"
-)
-
-type MemTestPlugin struct {
-	*driver.RegistryMemory
-}
-
-func NewRegistry() driver.Registry {
-	return &MemTestPlugin{RegistryMemory: driver.NewRegistryMemory()}
-}
-
-func main() {}
diff --git a/x/tls_termination_test.go b/x/tls_termination_test.go
index 4b0dcaaf6..0eb3aebea 100644
--- a/x/tls_termination_test.go
+++ b/x/tls_termination_test.go
@@ -25,7 +25,7 @@ func noopHandler(w http.ResponseWriter, r *http.Request) {
 
 func TestDoesRequestSatisfyTermination(t *testing.T) {
 	c := internal.NewConfigurationWithDefaultsAndHTTPS()
-	r := internal.NewRegistryMemory(c)
+	r := internal.NewRegistryMemory(t, c)
 
 	t.Run("case=tls-termination-disabled", func(t *testing.T) {
 		viper.Set(configuration.ViperKeyAllowTLSTerminationFrom, "")
