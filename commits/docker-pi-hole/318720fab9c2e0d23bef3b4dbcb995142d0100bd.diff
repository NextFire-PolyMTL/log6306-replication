commit 318720fab9c2e0d23bef3b4dbcb995142d0100bd (from 7e817b9360f449d5114cff2db10d146e6365e8a9)
Merge: 7e817b9 74dec72
Author: Adam Warner <me@adamwarner.co.uk>
Date:   Fri Jul 15 17:13:01 2022 +0100

    Merge pull request #1141 from pi-hole/massive-refactor
    
    Huge tidy up/prune/refactor of the code

diff --git a/Dockerfile b/Dockerfile
index 067f969..5a2b23d 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -4,12 +4,12 @@ FROM "${PIHOLE_BASE:-ghcr.io/pi-hole/docker-pi-hole-base:bullseye-slim}"
 ARG PIHOLE_DOCKER_TAG
 ENV PIHOLE_DOCKER_TAG "${PIHOLE_DOCKER_TAG}"
 
-ENV S6_OVERLAY_VERSION v2.1.0.2
+ENV S6_OVERLAY_VERSION v3.1.1.2
 
-COPY install.sh /usr/local/bin/install.sh
+COPY ./scripts/install.sh /usr/local/bin/install.sh
 ENV PIHOLE_INSTALL /etc/.pihole/automated\ install/basic-install.sh
 
-ENTRYPOINT [ "/s6-init" ]
+ENTRYPOINT [ "/init" ]
 
 COPY s6/debian-root /
 COPY s6/service /usr/local/bin/service
@@ -22,8 +22,9 @@ ARG PHP_ENV_CONFIG
 ENV PHP_ENV_CONFIG /etc/lighttpd/conf-enabled/15-fastcgi-php.conf
 ARG PHP_ERROR_LOG
 ENV PHP_ERROR_LOG /var/log/lighttpd/error-pihole.log
-COPY ./start.sh /
-COPY ./bash_functions.sh /
+COPY ./scripts/start.sh /
+COPY ./scripts/bash_functions.sh /
+COPY ./scripts/gravityonboot.sh /
 
 # IPv6 disable flag for networks/devices that do not support it
 ENV IPv6 True
@@ -36,7 +37,7 @@ ENV S6_LOGGING 0
 ENV S6_KEEP_ENV 1
 ENV S6_BEHAVIOUR_IF_STAGE2_FAILS 2
 
-ENV ServerIP 0.0.0.0
+ENV FTLCONF_REPLY_ADDR4 0.0.0.0
 ENV FTL_CMD no-daemon
 ENV DNSMASQ_USER pihole
 
diff --git a/README.md b/README.md
index 9051557..af0ea13 100644
--- a/README.md
+++ b/README.md
@@ -9,17 +9,17 @@
 
 - **Using Watchtower? See the [Note on Watchtower](#note-on-watchtower) at the bottom of this readme**
 
-- Due to [a known issue with Docker and libseccomp <2.5](https://github.com/moby/moby/issues/40734), you may run into issues running `2022.04` and later on host systems with an older version of `libseccomp2` ([Such as Debian/Raspbian buster or Ubuntu 20.04](https://pkgs.org/download/libseccomp2), and maybe [CentOS 7](https://pkgs.org/download/libseccomp)). 
+- Due to [a known issue with Docker and libseccomp <2.5](https://github.com/moby/moby/issues/40734), you may run into issues running `2022.04` and later on host systems with an older version of `libseccomp2` ([Such as Debian/Raspbian buster or Ubuntu 20.04](https://pkgs.org/download/libseccomp2), and maybe [CentOS 7](https://pkgs.org/download/libseccomp)).
+
+  The first recommendation is to upgrade your host OS, which will include a more up to date (and fixed) version of `libseccomp`.
 
-  The first recommendation is to upgrade your host OS, which will include a more up to date (and fixed) version of `libseccomp`. 
-  
   _If you absolutely cannot do this, some users [have reported](https://github.com/pi-hole/docker-pi-hole/issues/1042#issuecomment-1086728157) success in updating `libseccomp2` via backports on debian, or similar via updates on Ubuntu. You can try this workaround at your own risk_  (Note, you may also find that you need the latest `docker.io` (more details [here](https://blog.samcater.com/fix-workaround-rpi4-docker-libseccomp2-docker-20/))
 
 - Some users [have reported issues](https://github.com/pi-hole/docker-pi-hole/issues/963#issuecomment-1095602502) with using the `--privileged` flag on `2022.04` and above. TL;DR, don't use that that mode, and be [explicit with the permitted caps](https://github.com/pi-hole/docker-pi-hole#note-on-capabilities) (if needed) instead
 
 - As of `2022.04.01`, setting `CAP_NET_ADMIN` is only required if you are using Pi-hole as your DHCP server. The container will only try to set caps that are explicitly granted (or natively available)
 
-- In `2022.01` and later, the default `DNSMASQ_USER` has been changed to `pihole`, however this may cause issues on some systems such as Synology, see Issue [#963](https://github.com/pi-hole/docker-pi-hole/issues/963) for more information.  
+- In `2022.01` and later, the default `DNSMASQ_USER` has been changed to `pihole`, however this may cause issues on some systems such as Synology, see Issue [#963](https://github.com/pi-hole/docker-pi-hole/issues/963) for more information.
  If the container won't start due to issues setting capabilities, set `DNSMASQ_USER` to `root` in your environment.
 
 ## Quick Start
@@ -122,7 +122,7 @@ There are other environment variables if you want to customize various things in
 | `PIHOLE_DOMAIN` | `lan` | `<domain>` | Domain name sent by the DHCP server.
 | `DHCP_IPv6` | `false` | `<"true"\|"false">` | Enable DHCP server IPv6 support (SLAAC + RA).
 | `DHCP_rapid_commit` | `false` | `<"true"\|"false">` | Enable DHCPv4 rapid commit (fast address assignment).
-| `VIRTUAL_HOST` | `$ServerIP` | `<Custom Hostname>` | What your web server 'virtual host' is, accessing admin through this Hostname/IP allows you to make changes to the whitelist / blacklists in addition to the default 'http://pi.hole/admin/' address
+| `VIRTUAL_HOST` | `$FTLCONF_REPLY_ADDR4` | `<Custom Hostname>` | What your web server 'virtual host' is, accessing admin through this Hostname/IP allows you to make changes to the whitelist / blacklists in addition to the default 'http://pi.hole/admin/' address
 | `IPv6` | `true` | `<"true"\|"false">` | For unraid compatibility, strips out all the IPv6 configuration from DNS/Web services when false.
 | `TEMPERATUREUNIT` | `c` | `<c\|k\|f>` | Set preferred temperature unit to `c`: Celsius, `k`: Kelvin, or `f` Fahrenheit units.
 | `WEBUIBOXEDLAYOUT` | `boxed` | `<boxed\|traditional>` | Use boxed layout (helpful when working on large screens)
@@ -224,7 +224,7 @@ Users of older Ubuntu releases (circa 17.04) will need to disable dnsmasq.
 
 The primary docker tags are explained in the following table.  [Click here to see the full list of tags](https://store.docker.com/community/images/pihole/pihole/tags). See [GitHub Release notes](https://github.com/pi-hole/docker-pi-hole/releases) to see the specific version of Pi-hole Core, Web, and FTL included in the release.
 
-| tag                 | description                                                                                                                                
+| tag                 | description
 |---------------------|--------------------------------------------------------------------------------------------------------------------------------------------|
 | `latest`            | Always latest release                                                                                                                      |
 | `2022.04`           | Date-based release that can receive bugfix updates                                                                                         |
diff --git a/bash_functions.sh b/bash_functions.sh
deleted file mode 100644
index 96131f5..0000000
--- a/bash_functions.sh
+++ /dev/null
@@ -1,415 +0,0 @@
-#!/bin/bash
-# Some of the bash_functions use variables these core pi-hole/web scripts
-. /opt/pihole/webpage.sh
-
-fix_capabilities() {
-    # Testing on Docker 20.10.14 with no caps set shows the following caps available to the container:
-    # Current: cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap=ep
-    # FTL can also use CAP_NET_ADMIN and CAP_SYS_NICE. If we try to set them when they haven't been explicitly enabled, FTL will not start. Test for them first:
-
-    /sbin/capsh --has-p=cap_chown 2>/dev/null && CAP_STR+=',CAP_CHOWN'
-    /sbin/capsh --has-p=cap_net_bind_service 2>/dev/null && CAP_STR+=',CAP_NET_BIND_SERVICE'
-    /sbin/capsh --has-p=cap_net_raw 2>/dev/null && CAP_STR+=',CAP_NET_RAW'
-    /sbin/capsh --has-p=cap_net_admin 2>/dev/null && CAP_STR+=',CAP_NET_ADMIN' || DHCP_READY='false'
-    /sbin/capsh --has-p=cap_sys_nice 2>/dev/null && CAP_STR+=',CAP_SYS_NICE'
-
-    if [[ ${CAP_STR} ]]; then
-        # We have the (some of) the above caps available to us - apply them to pihole-FTL
-        setcap ${CAP_STR:1}+ep $(which pihole-FTL) || ret=$?
-
-        if [[ $DHCP_READY == false ]] && [[ $DHCP_ACTIVE == true ]]; then
-            # DHCP is requested but NET_ADMIN is not available.
-            echo "ERROR: DHCP requested but NET_ADMIN is not available. DHCP will not be started."
-            echo "      Please add cap_net_admin to the container's capabilities or disable DHCP."
-            DHCP_ACTIVE='false'
-            change_setting "DHCP_ACTIVE" "false"
-        fi
-
-        if [[ $ret -ne 0 && "${DNSMASQ_USER:-pihole}" != "root" ]]; then
-            echo "ERROR: Unable to set capabilities for pihole-FTL. Cannot run as non-root."
-            echo "       If you are seeing this error, please set the environment variable 'DNSMASQ_USER' to the value 'root'"
-            exit 1
-        fi
-    else
-        echo "WARNING: Unable to set capabilities for pihole-FTL."
-        echo "         Please ensure that the container has the required capabilities."
-        exit 1
-    fi
-}
-
-prepare_configs() {
-    # Done in /start.sh, don't do twice
-    SKIP_INSTALL=true . "${PIHOLE_INSTALL}"
-    # Set Debian webserver variables for installConfigs
-    LIGHTTPD_USER="www-data"
-    LIGHTTPD_GROUP="www-data"
-    LIGHTTPD_CFG="lighttpd.conf.debian"
-    installConfigs
-    installLogrotate || true #installLogRotate can return 2 or 3, but we are still OK to continue in that case
-
-    if [ ! -f "${setupVars}" ]; then
-        install -m 644 /dev/null "${setupVars}"
-        echo "Creating empty ${setupVars} file."
-    fi
-
-    set +e
-    mkdir -p /var/run/pihole /var/log/pihole
-
-    chown pihole:root /etc/lighttpd
-
-    # In case of `pihole` UID being changed, re-chown the pihole scripts and pihole command
-    chown -R pihole:root "${PI_HOLE_INSTALL_DIR}"
-    chown pihole:root "${PI_HOLE_BIN_DIR}/pihole"
-
-    set -e
-    # Update version numbers
-    pihole updatechecker
-    # Re-write all of the setupVars to ensure required ones are present (like QUERY_LOGGING)
-
-    # If the setup variable file exists,
-    if [[ -e "${setupVars}" ]]; then
-        cp -f "${setupVars}" "${setupVars}.update.bak"
-    fi
-
-    # Remove any existing macvendor.db and replace it with a symblink to the one moved to the root directory (see install.sh)
-    if [[ -f "/etc/pihole/macvendor.db" ]]; then
-        rm /etc/pihole/macvendor.db
-    fi
-    ln -s /macvendor.db /etc/pihole/macvendor.db
-}
-
-validate_env() {
-    # Optional ServerIP is a valid IP
-    # nc won't throw any text based errors when it times out connecting to a valid IP, otherwise it complains about the DNS name being garbage
-    # if nc doesn't behave as we expect on a valid IP the routing table should be able to look it up and return a 0 retcode
-    if [[ "$(nc -4 -w1 -z "$ServerIP" 53 2>&1)" != "" ]] && ! ip route get "$ServerIP" > /dev/null ; then
-        echo "ERROR: ServerIP Environment variable ($ServerIP) doesn't appear to be a valid IPv4 address"
-        exit 1
-    fi
-
-    # Optional IPv6 is a valid address
-    if [[ -n "$ServerIPv6" ]] ; then
-        if [[ "$ServerIPv6" == 'kernel' ]] ; then
-            echo "ERROR: You passed in IPv6 with a value of 'kernel', this maybe because you do not have IPv6 enabled on your network"
-            unset ServerIPv6
-            exit 1
-        fi
-        if [[ "$(nc -6 -w1 -z "$ServerIPv6" 53 2>&1)" != "" ]] && ! ip route get "$ServerIPv6" > /dev/null ; then
-            echo "ERROR: ServerIPv6 Environment variable ($ServerIPv6) doesn't appear to be a valid IPv6 address"
-            echo "  TIP: If your server is not IPv6 enabled just remove '-e ServerIPv6' from your docker container"
-            exit 1
-        fi
-    fi;
-}
-
-setup_dnsmasq_interface() {
-    local interface="${1:-eth0}"
-    local interfaceType='default'
-    if [ "$interface" != 'eth0' ] ; then
-      interfaceType='custom'
-    fi;
-    echo "DNSMasq binding to $interfaceType interface: $interface"
-    [ -n "$interface" ] && change_setting "PIHOLE_INTERFACE" "${interface}"
-}
-
-setup_dnsmasq_listening_behaviour() {
-    local dnsmasq_listening_behaviour="${1}"
-
-    if [ -n "$dnsmasq_listening_behaviour" ]; then
-      change_setting "DNSMASQ_LISTENING" "${dnsmasq_listening_behaviour}"
-    fi;
-}
-
-setup_dnsmasq_config_if_missing() {
-    # When fresh empty directory volumes are used we miss this file
-    if [ ! -f /etc/dnsmasq.d/01-pihole.conf ] ; then
-        cp /etc/.pihole/advanced/01-pihole.conf /etc/dnsmasq.d/
-    fi;
-}
-
-setup_dnsmasq() {
-    local interface="$1"
-    local dnsmasq_listening_behaviour="$2"
-    # Coordinates
-    setup_dnsmasq_config_if_missing
-    setup_dnsmasq_interface "$interface"
-    setup_dnsmasq_listening_behaviour "$dnsmasq_listening_behaviour"
-    setup_dnsmasq_user "${DNSMASQ_USER}"
-    setup_cache_size "${CUSTOM_CACHE_SIZE}"
-    ProcessDNSSettings
-}
-
-setup_dnsmasq_user() {
-    local DNSMASQ_USER="${1}"
-
-    # Run DNSMASQ as root user to avoid SHM permission issues
-    if grep -r -q '^\s*user=' /etc/dnsmasq.* ; then
-        # Change user that had been set previously to root
-        for f in $(grep -r -l '^\s*user=' /etc/dnsmasq.*); do
-            sed -i "/^\s*user=/ c\user=${DNSMASQ_USER}" "${f}"
-        done
-    else
-      echo -e "\nuser=${DNSMASQ_USER}" >> /etc/dnsmasq.conf
-    fi
-}
-
-setup_dnsmasq_hostnames() {
-    # largely borrowed from automated install/basic-install.sh
-    local IPV4_ADDRESS="${1}"
-    local IPV6_ADDRESS="${2}"
-    local hostname="${3}"
-    local dnsmasq_pihole_01_location="/etc/dnsmasq.d/01-pihole.conf"
-
-    if [ -z "$hostname" ]; then
-        if [[ -f /etc/hostname ]]; then
-            hostname=$(</etc/hostname)
-        elif [ -x "$(command -v hostname)" ]; then
-            hostname=$(hostname -f)
-        fi
-    fi;
-
-    if [[ "${IPV4_ADDRESS}" != "" ]]; then
-        tmp=${IPV4_ADDRESS%/*}
-        sed -i "s/@IPV4@/$tmp/" ${dnsmasq_pihole_01_location}
-    else
-        sed -i '/^address=\/pi.hole\/@IPV4@/d' ${dnsmasq_pihole_01_location}
-        sed -i '/^address=\/@HOSTNAME@\/@IPV4@/d' ${dnsmasq_pihole_01_location}
-    fi
-
-    if [[ "${IPV6_ADDRESS}" != "" ]]; then
-        sed -i "s/@IPv6@/$IPV6_ADDRESS/" ${dnsmasq_pihole_01_location}
-    else
-        sed -i '/^address=\/pi.hole\/@IPv6@/d' ${dnsmasq_pihole_01_location}
-        sed -i '/^address=\/@HOSTNAME@\/@IPv6@/d' ${dnsmasq_pihole_01_location}
-    fi
-
-    if [[ "${hostname}" != "" ]]; then
-        sed -i "s/@HOSTNAME@/$hostname/" ${dnsmasq_pihole_01_location}
-    else
-        sed -i '/^address=\/@HOSTNAME@*/d' ${dnsmasq_pihole_01_location}
-    fi
-}
-
-setup_cache_size() {
-    local warning="WARNING: CUSTOM_CACHE_SIZE not used"
-    local dnsmasq_pihole_01_location="/etc/dnsmasq.d/01-pihole.conf"
-    # Quietly exit early for empty or default
-    if [[ -z "${1}" || "${1}" == '10000' ]] ; then return ; fi
-
-    if [[ "${DNSSEC}" == "true" ]] ; then
-        echo "$warning - Cannot change cache size if DNSSEC is enabled"
-        return
-    fi
-
-    if ! echo $1 | grep -q '^[0-9]*$' ; then
-        echo "$warning - $1 is not an integer"
-        return
-    fi
-
-    local -i custom_cache_size="$1"
-    if (( $custom_cache_size < 0 )); then
-        echo "$warning - $custom_cache_size is not a positive integer or zero"
-        return
-    fi
-    echo "Custom CUSTOM_CACHE_SIZE set to $custom_cache_size"
-
-    sed -i "s/^cache-size=\s*[0-9]*/cache-size=$custom_cache_size/" ${dnsmasq_pihole_01_location}
-}
-
-setup_lighttpd_bind() {
-    local serverip="$1"
-    # if using '--net=host' only bind lighttpd on $ServerIP and localhost
-    if grep -q "docker" /proc/net/dev && [[ $serverip != 0.0.0.0 ]]; then #docker (docker0 by default) should only be present on the host system
-        if ! grep -q "server.bind" /etc/lighttpd/lighttpd.conf ; then # if the declaration is already there, don't add it again
-            sed -i -E "s/server\.port\s+\=\s+([0-9]+)/server.bind\t\t = \"${serverip}\"\nserver.port\t\t = \1\n"\$SERVER"\[\"socket\"\] == \"127\.0\.0\.1:\1\" \{\}/" /etc/lighttpd/lighttpd.conf
-        fi
-    fi
-}
-
-setup_php_env() {
-    if [ -z "$VIRTUAL_HOST" ] ; then
-      VIRTUAL_HOST="$ServerIP"
-    fi;
-
-    for config_var in "VIRTUAL_HOST" "CORS_HOSTS" "ServerIP" "PHP_ERROR_LOG" "PIHOLE_DOCKER_TAG" "TZ"; do
-      local beginning_of_line="\t\t\t\"${config_var}\" => "
-      if grep -qP "$beginning_of_line" "$PHP_ENV_CONFIG" ; then
-        # replace line if already present
-        sed -i "/${beginning_of_line}/c\\${beginning_of_line}\"${!config_var}\"," "$PHP_ENV_CONFIG"
-      else
-        # add line otherwise
-        sed -i "/bin-environment/ a\\${beginning_of_line}\"${!config_var}\"," "$PHP_ENV_CONFIG"
-      fi
-    done
-
-    echo "Added ENV to php:"
-    grep -E '(VIRTUAL_HOST|CORS_HOSTS|ServerIP|PHP_ERROR_LOG|PIHOLE_DOCKER_TAG|TZ)' "$PHP_ENV_CONFIG"
-}
-
-setup_web_port() {
-    local warning="WARNING: Custom WEB_PORT not used"
-    # Quietly exit early for empty or default
-    if [[ -z "${1}" || "${1}" == '80' ]] ; then return ; fi
-
-    if ! echo $1 | grep -q '^[0-9][0-9]*$' ; then
-        echo "$warning - $1 is not an integer"
-        return
-    fi
-
-    local -i web_port="$1"
-    if (( $web_port < 1 || $web_port > 65535 )); then
-        echo "$warning - $web_port is not within valid port range of 1-65535"
-        return
-    fi
-    echo "Custom WEB_PORT set to $web_port"
-    echo "INFO: Without proper router DNAT forwarding to $ServerIP:$web_port, you may not get any blocked websites on ads"
-
-    # Update lighttpd's port
-    sed -i '/server.port\s*=\s*80\s*$/ s/80/'$WEB_PORT'/g' /etc/lighttpd/lighttpd.conf
-
-}
-
-load_web_password_secret() {
-   # If WEBPASSWORD is not set at all, attempt to read password from WEBPASSWORD_FILE,
-   # allowing secrets to be passed via docker secrets
-   if [ -z "${WEBPASSWORD+x}" ] && [ -n "${WEBPASSWORD_FILE}" ] && [ -r "${WEBPASSWORD_FILE}" ]; then
-     WEBPASSWORD=$(<"${WEBPASSWORD_FILE}")
-   fi;
-}
-
-
-
-setup_web_password() {
-    if [ -z "${WEBPASSWORD+x}" ] ; then
-        # ENV WEBPASSWORD is not set
-
-        # Exit if setupvars already has a password
-        setup_var_exists "WEBPASSWORD" && return
-
-        # Generate new random password
-        WEBPASSWORD=$(tr -dc _A-Z-a-z-0-9 < /dev/urandom | head -c 8)
-        echo "Assigning random password: $WEBPASSWORD"
-    else
-        # ENV WEBPASSWORD is set an will be used
-        echo "::: Assigning password defined by Environment Variable"
-    fi
-
-    PASS="$WEBPASSWORD"
-
-    # Explicitly turn off bash printing when working with secrets
-    { set +x; } 2>/dev/null
-
-    if [[ "$PASS" == "" ]] ; then
-        echo "" | pihole -a -p
-    else
-        pihole -a -p "$PASS" "$PASS"
-    fi
-
-    # To avoid printing this if conditional in bash debug, turn off  debug above..
-    # then re-enable debug if necessary (more code but cleaner printed output)
-    if [ "${PH_VERBOSE:-0}" -gt 0 ] ; then
-        set -x
-    fi
-}
-
-setup_ipv4_ipv6() {
-    local ip_versions="IPv4 and IPv6"
-    if [ "${IPv6,,}" != "true" ] ; then
-        ip_versions="IPv4"
-        sed -i '/use-ipv6.pl/ d' /etc/lighttpd/lighttpd.conf
-    fi;
-    echo "Using $ip_versions"
-}
-
-test_configs() {
-    set -e
-    echo -n '::: Testing lighttpd config: '
-    lighttpd -t -f /etc/lighttpd/lighttpd.conf || exit 1
-    set +e
-    echo "::: All config checks passed, cleared for startup ..."
-}
-
-setup_blocklists() {
-    local blocklists="$1"
-    # Exit/return early without setting up adlists with defaults for any of the following conditions:
-    # 1. skip_setup_blocklists env is set
-    exit_string="(exiting ${FUNCNAME[0]} early)"
-
-    if [ -n "${skip_setup_blocklists}" ]; then
-        echo "::: skip_setup_blocklists requested ($exit_string)"
-        return
-    fi
-
-    # 2. The adlist file exists already (restarted container or volume mounted list)
-    if [ -f "${adlistFile}" ]; then
-        echo "::: Preexisting ad list ${adlistFile} detected ($exit_string)"
-        cat "${adlistFile}"
-        return
-    fi
-
-    echo "::: ${FUNCNAME[0]} now setting default blocklists up: "
-    echo "::: TIP: Use a docker volume for ${adlistFile} if you want to customize for first boot"
-    installDefaultBlocklists
-
-    echo "::: Blocklists (${adlistFile}) now set to:"
-    cat "${adlistFile}"
-}
-
-setup_var_exists() {
-    local KEY="$1"
-    if [ -n "$2" ]; then
-        local REQUIRED_VALUE="[^\n]+"
-    fi
-    if grep -Pq "^${KEY}=${REQUIRED_VALUE}" "$setupVars"; then
-        echo "::: Pre existing ${KEY} found"
-        true
-    else
-        false
-    fi
-}
-
-setup_temp_unit() {
-  local UNIT="$1"
-  # check if var is empty
-  if [[ "$UNIT" != "" ]] ; then
-      # check if we have valid units
-      if [[ "$UNIT" == "c" || "$UNIT" == "k" || $UNIT == "f" ]] ; then
-          pihole -a -${UNIT}
-      fi
-  fi
-}
-
-setup_ui_layout() {
-  local LO=$1
-  # check if var is empty
-  if [[ "$LO" != "" ]] ; then
-      # check if we have valid types boxed | traditional
-      if [[ "$LO" == "traditional" || "$LO" == "boxed" ]] ; then
-          change_setting "WEBUIBOXEDLAYOUT" "$WEBUIBOXEDLAYOUT"
-      fi
-  fi
-}
-
-setup_admin_email() {
-  local EMAIL=$1
-  # check if var is empty
-  if [[ "$EMAIL" != "" ]] ; then
-      pihole -a -e "$EMAIL"
-  fi
-}
-
-setup_dhcp() {
-  if [ -z "${DHCP_START}" ] || [ -z "${DHCP_END}" ] || [ -z "${DHCP_ROUTER}" ]; then
-    echo "ERROR: Won't enable DHCP server because mandatory Environment variables are missing: DHCP_START, DHCP_END and/or DHCP_ROUTER"
-    change_setting "DHCP_ACTIVE" "false"
-  else
-    change_setting "DHCP_ACTIVE" "${DHCP_ACTIVE}"
-    change_setting "DHCP_START" "${DHCP_START}"
-    change_setting "DHCP_END" "${DHCP_END}"
-    change_setting "DHCP_ROUTER" "${DHCP_ROUTER}"
-    change_setting "DHCP_LEASETIME" "${DHCP_LEASETIME}"
-    change_setting "PIHOLE_DOMAIN" "${PIHOLE_DOMAIN}"
-    change_setting "DHCP_IPv6" "${DHCP_IPv6}"
-    change_setting "DHCP_rapid_commit" "${DHCP_rapid_commit}"
-  fi
-}
diff --git a/docker_run.sh b/docker_run.sh
index 045cec8..687691d 100755
--- a/docker_run.sh
+++ b/docker_run.sh
@@ -5,7 +5,7 @@
 PIHOLE_BASE="${PIHOLE_BASE:-$(pwd)}"
 [[ -d "$PIHOLE_BASE" ]] || mkdir -p "$PIHOLE_BASE" || { echo "Couldn't create storage directory: $PIHOLE_BASE"; exit 1; }
 
-# Note: ServerIP should be replaced with your external ip.
+# Note: FTLCONF_REPLY_ADDR4 should be replaced with your external ip.
 docker run -d \
     --name pihole \
     -p 53:53/tcp -p 53:53/udp \
@@ -18,7 +18,7 @@ docker run -d \
     --hostname pi.hole \
     -e VIRTUAL_HOST="pi.hole" \
     -e PROXY_LOCATION="pi.hole" \
-    -e ServerIP="127.0.0.1" \
+    -e FTLCONF_REPLY_ADDR4="127.0.0.1" \
     pihole/pihole:latest
 
 printf 'Starting up pihole container '
diff --git a/s6/debian-root/etc/cont-init.d/05-changer-uid-gid.sh b/s6/debian-root/etc/cont-init.d/05-changer-uid-gid.sh
old mode 100644
new mode 100755
index 1bc2106..84ad3d8
--- a/s6/debian-root/etc/cont-init.d/05-changer-uid-gid.sh
+++ b/s6/debian-root/etc/cont-init.d/05-changer-uid-gid.sh
@@ -1,4 +1,4 @@
-#!/usr/bin/with-contenv bash
+#!/command/with-contenv bash
 set -e
 
 if [ "${PH_VERBOSE:-0}" -gt 0 ] ; then
@@ -14,7 +14,7 @@ modifyUser()
   [[ ${currentId} -eq ${newId} ]] && return
 
   echo "Changing ID for user: ${username} (${currentId} => ${newId})"
-  usermod -o -u ${newId} ${username}  
+  usermod -o -u ${newId} ${username}
 }
 
 modifyGroup()
diff --git a/s6/debian-root/etc/fix-attrs.d/01-resolver-resolv b/s6/debian-root/etc/fix-attrs.d/01-resolver-resolv
old mode 100644
new mode 100755
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/1-gravityonboot/dependencies b/s6/debian-root/etc/s6-overlay/s6-rc.d/1-gravityonboot/dependencies
new file mode 100755
index 0000000..c282670
--- /dev/null
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/1-gravityonboot/dependencies
@@ -0,0 +1 @@
+pihole-FTL
\ No newline at end of file
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/1-gravityonboot/type b/s6/debian-root/etc/s6-overlay/s6-rc.d/1-gravityonboot/type
new file mode 100755
index 0000000..3d92b15
--- /dev/null
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/1-gravityonboot/type
@@ -0,0 +1 @@
+oneshot
\ No newline at end of file
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/1-gravityonboot/up b/s6/debian-root/etc/s6-overlay/s6-rc.d/1-gravityonboot/up
new file mode 100755
index 0000000..1a88195
--- /dev/null
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/1-gravityonboot/up
@@ -0,0 +1 @@
+bash /gravityonboot.sh
\ No newline at end of file
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/1-startup/type b/s6/debian-root/etc/s6-overlay/s6-rc.d/1-startup/type
new file mode 100755
index 0000000..3d92b15
--- /dev/null
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/1-startup/type
@@ -0,0 +1 @@
+oneshot
\ No newline at end of file
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/1-startup/up b/s6/debian-root/etc/s6-overlay/s6-rc.d/1-startup/up
new file mode 100755
index 0000000..e5d3fb1
--- /dev/null
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/1-startup/up
@@ -0,0 +1,2 @@
+#!/command/execlineb
+foreground { bash -e /start.sh }
\ No newline at end of file
diff --git a/s6/debian-root/etc/services.d/cron/finish b/s6/debian-root/etc/s6-overlay/s6-rc.d/cron/finish
old mode 100644
new mode 100755
similarity index 58%
rename from s6/debian-root/etc/services.d/cron/finish
rename to s6/debian-root/etc/s6-overlay/s6-rc.d/cron/finish
index 7d31867..14c0c72
--- a/s6/debian-root/etc/services.d/cron/finish
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/cron/finish
@@ -1,4 +1,4 @@
-#!/usr/bin/with-contenv bash
+#!/command/with-contenv bash
 
 s6-echo "Stopping cron"
 killall -9 cron
diff --git a/s6/debian-root/etc/services.d/cron/run b/s6/debian-root/etc/s6-overlay/s6-rc.d/cron/run
old mode 100644
new mode 100755
similarity index 69%
rename from s6/debian-root/etc/services.d/cron/run
rename to s6/debian-root/etc/s6-overlay/s6-rc.d/cron/run
index df902ed..e9f582c
--- a/s6/debian-root/etc/services.d/cron/run
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/cron/run
@@ -1,4 +1,4 @@
-#!/usr/bin/with-contenv bash
+#!/command/with-contenv bash
 s6-echo "Starting crond"
 
 exec -c
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/cron/type b/s6/debian-root/etc/s6-overlay/s6-rc.d/cron/type
new file mode 100755
index 0000000..1780f9f
--- /dev/null
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/cron/type
@@ -0,0 +1 @@
+longrun
\ No newline at end of file
diff --git a/s6/debian-root/etc/services.d/lighttpd-access-log/down b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-access-log/down
old mode 100644
new mode 100755
similarity index 100%
rename from s6/debian-root/etc/services.d/lighttpd-access-log/down
rename to s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-access-log/down
diff --git a/s6/debian-root/etc/services.d/lighttpd-access-log/finish b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-access-log/finish
old mode 100644
new mode 100755
similarity index 87%
rename from s6/debian-root/etc/services.d/lighttpd-access-log/finish
rename to s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-access-log/finish
index 5802d5b..d3da477
--- a/s6/debian-root/etc/services.d/lighttpd-access-log/finish
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-access-log/finish
@@ -1,4 +1,4 @@
-#!/usr/bin/with-contenv bash
+#!/command/with-contenv bash
 
 s6-echo "Stopping lighttpd-access-log"
 pid=$(ps -C cat -o pid=,args= |grep -oP "([0-9]+).+access\.log" |cut -f1 -d" ")
diff --git a/s6/debian-root/etc/services.d/lighttpd-access-log/run b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-access-log/run
old mode 100644
new mode 100755
similarity index 78%
rename from s6/debian-root/etc/services.d/lighttpd-access-log/run
rename to s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-access-log/run
index 61d7cbb..c1d379e
--- a/s6/debian-root/etc/services.d/lighttpd-access-log/run
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-access-log/run
@@ -1,4 +1,4 @@
-#!/usr/bin/with-contenv bash
+#!/command/with-contenv bash
 
 s6-echo "Starting lighttpd-access-log"
 
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-access-log/type b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-access-log/type
new file mode 100755
index 0000000..1780f9f
--- /dev/null
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-access-log/type
@@ -0,0 +1 @@
+longrun
\ No newline at end of file
diff --git a/s6/debian-root/etc/services.d/lighttpd-error-log/down b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-error-log/down
old mode 100644
new mode 100755
similarity index 100%
rename from s6/debian-root/etc/services.d/lighttpd-error-log/down
rename to s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-error-log/down
diff --git a/s6/debian-root/etc/services.d/lighttpd-error-log/finish b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-error-log/finish
old mode 100644
new mode 100755
similarity index 87%
rename from s6/debian-root/etc/services.d/lighttpd-error-log/finish
rename to s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-error-log/finish
index 8fbad41..fe649a2
--- a/s6/debian-root/etc/services.d/lighttpd-error-log/finish
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-error-log/finish
@@ -1,4 +1,4 @@
-#!/usr/bin/with-contenv bash
+#!/command/with-contenv bash
 
 s6-echo "Stopping lighttpd-error-log"
 pid=$(ps -C cat -o pid=,args= |grep -oP "([0-9]+).+error\.log" |cut -f1 -d" ")
diff --git a/s6/debian-root/etc/services.d/lighttpd-error-log/run b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-error-log/run
old mode 100644
new mode 100755
similarity index 78%
rename from s6/debian-root/etc/services.d/lighttpd-error-log/run
rename to s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-error-log/run
index 45e666a..59fe79b
--- a/s6/debian-root/etc/services.d/lighttpd-error-log/run
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-error-log/run
@@ -1,4 +1,4 @@
-#!/usr/bin/with-contenv bash
+#!/command/with-contenv bash
 
 s6-echo "Starting lighttpd-error-log"
 
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-error-log/type b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-error-log/type
new file mode 100755
index 0000000..1780f9f
--- /dev/null
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd-error-log/type
@@ -0,0 +1 @@
+longrun
\ No newline at end of file
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd/dependencies b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd/dependencies
new file mode 100644
index 0000000..c282670
--- /dev/null
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd/dependencies
@@ -0,0 +1 @@
+pihole-FTL
\ No newline at end of file
diff --git a/s6/debian-root/etc/services.d/lighttpd/finish b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd/finish
old mode 100644
new mode 100755
similarity index 79%
rename from s6/debian-root/etc/services.d/lighttpd/finish
rename to s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd/finish
index b4dbfa4..0f6e5e3
--- a/s6/debian-root/etc/services.d/lighttpd/finish
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd/finish
@@ -1,4 +1,4 @@
-#!/usr/bin/with-contenv bash
+#!/command/with-contenv bash
 
 s6-echo "Stopping lighttpd"
 service lighttpd-access-log stop
diff --git a/s6/debian-root/etc/services.d/lighttpd/run b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd/run
old mode 100644
new mode 100755
similarity index 97%
rename from s6/debian-root/etc/services.d/lighttpd/run
rename to s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd/run
index 8a314fb..a0deb15
--- a/s6/debian-root/etc/services.d/lighttpd/run
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd/run
@@ -1,4 +1,4 @@
-#!/usr/bin/with-contenv bash
+#!/command/with-contenv bash
 
 s6-echo "Starting lighttpd"
 
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd/type b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd/type
new file mode 100755
index 0000000..1780f9f
--- /dev/null
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/lighttpd/type
@@ -0,0 +1 @@
+longrun
\ No newline at end of file
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/pihole-FTL/dependencies b/s6/debian-root/etc/s6-overlay/s6-rc.d/pihole-FTL/dependencies
new file mode 100644
index 0000000..c81115b
--- /dev/null
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/pihole-FTL/dependencies
@@ -0,0 +1 @@
+1-startup
\ No newline at end of file
diff --git a/s6/debian-root/etc/services.d/pihole-FTL/finish b/s6/debian-root/etc/s6-overlay/s6-rc.d/pihole-FTL/finish
old mode 100644
new mode 100755
similarity index 65%
rename from s6/debian-root/etc/services.d/pihole-FTL/finish
rename to s6/debian-root/etc/s6-overlay/s6-rc.d/pihole-FTL/finish
index 4ed219a..57265c1
--- a/s6/debian-root/etc/services.d/pihole-FTL/finish
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/pihole-FTL/finish
@@ -1,4 +1,4 @@
-#!/usr/bin/with-contenv bash
+#!/command/with-contenv bash
 
 s6-echo "Stopping pihole-FTL"
 killall -15 pihole-FTL
diff --git a/s6/debian-root/etc/services.d/pihole-FTL/run b/s6/debian-root/etc/s6-overlay/s6-rc.d/pihole-FTL/run
old mode 100644
new mode 100755
similarity index 56%
rename from s6/debian-root/etc/services.d/pihole-FTL/run
rename to s6/debian-root/etc/s6-overlay/s6-rc.d/pihole-FTL/run
index ababe8d..aac13d3
--- a/s6/debian-root/etc/services.d/pihole-FTL/run
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/pihole-FTL/run
@@ -1,4 +1,37 @@
-#!/usr/bin/with-contenv bash
+#!/command/with-contenv bash
+
+# Testing on Docker 20.10.14 with no caps set shows the following caps available to the container:
+# Current: cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap=ep
+# FTL can also use CAP_NET_ADMIN and CAP_SYS_NICE. If we try to set them when they haven't been explicitly enabled, FTL will not start. Test for them first:
+
+/sbin/capsh --has-p=cap_chown 2>/dev/null && CAP_STR+=',CAP_CHOWN'
+/sbin/capsh --has-p=cap_net_bind_service 2>/dev/null && CAP_STR+=',CAP_NET_BIND_SERVICE'
+/sbin/capsh --has-p=cap_net_raw 2>/dev/null && CAP_STR+=',CAP_NET_RAW'
+/sbin/capsh --has-p=cap_net_admin 2>/dev/null && CAP_STR+=',CAP_NET_ADMIN' || DHCP_READY='false'
+/sbin/capsh --has-p=cap_sys_nice 2>/dev/null && CAP_STR+=',CAP_SYS_NICE'
+
+if [[ ${CAP_STR} ]]; then
+    # We have the (some of) the above caps available to us - apply them to pihole-FTL
+    setcap ${CAP_STR:1}+ep "$(which pihole-FTL)" || ret=$?
+
+    if [[ $DHCP_READY == false ]] && [[ $DHCP_ACTIVE == true ]]; then
+        # DHCP is requested but NET_ADMIN is not available.
+        echo "ERROR: DHCP requested but NET_ADMIN is not available. DHCP will not be started."
+        echo "      Please add cap_net_admin to the container's capabilities or disable DHCP."
+        DHCP_ACTIVE='false'
+        change_setting "DHCP_ACTIVE" "false"
+    fi
+
+    if [[ $ret -ne 0 && "${DNSMASQ_USER:-pihole}" != "root" ]]; then
+        echo "ERROR: Unable to set capabilities for pihole-FTL. Cannot run as non-root."
+        echo "       If you are seeing this error, please set the environment variable 'DNSMASQ_USER' to the value 'root'"
+        exit 1
+    fi
+else
+    echo "WARNING: Unable to set capabilities for pihole-FTL."
+    echo "         Please ensure that the container has the required capabilities."
+    exit 1
+fi
 
 s6-echo "Starting pihole-FTL ($FTL_CMD) as ${DNSMASQ_USER}"
 # Remove possible leftovers from previous pihole-FTL processes
@@ -37,7 +70,7 @@ if [ ! -f /var/log/pihole-FTL.log ]; then
 fi
 
 # Call capsh with the detected capabilities
-capsh --inh=${CAP_STR:1} --addamb=${CAP_STR:1} --user=$DNSMASQ_USER --keep=1 -- -c "/usr/bin/pihole-FTL $FTL_CMD >/dev/null 2>&1" 
+capsh --inh=${CAP_STR:1} --addamb=${CAP_STR:1} --user=$DNSMASQ_USER --keep=1 -- -c "/usr/bin/pihole-FTL $FTL_CMD >/dev/null 2>&1"
 
 # Notes on above:
 # - DNSMASQ_USER default of pihole is in Dockerfile & can be overwritten by runtime container env
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/pihole-FTL/type b/s6/debian-root/etc/s6-overlay/s6-rc.d/pihole-FTL/type
new file mode 100755
index 0000000..1780f9f
--- /dev/null
+++ b/s6/debian-root/etc/s6-overlay/s6-rc.d/pihole-FTL/type
@@ -0,0 +1 @@
+longrun
\ No newline at end of file
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/user/contents.d/1-gravityonboot b/s6/debian-root/etc/s6-overlay/s6-rc.d/user/contents.d/1-gravityonboot
new file mode 100644
index 0000000..e69de29
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/user/contents.d/1-startup b/s6/debian-root/etc/s6-overlay/s6-rc.d/user/contents.d/1-startup
new file mode 100644
index 0000000..e69de29
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/user/contents.d/cron b/s6/debian-root/etc/s6-overlay/s6-rc.d/user/contents.d/cron
new file mode 100644
index 0000000..e69de29
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/user/contents.d/lighttpd b/s6/debian-root/etc/s6-overlay/s6-rc.d/user/contents.d/lighttpd
new file mode 100644
index 0000000..e69de29
diff --git a/s6/debian-root/etc/s6-overlay/s6-rc.d/user/contents.d/pihole-FTL b/s6/debian-root/etc/s6-overlay/s6-rc.d/user/contents.d/pihole-FTL
new file mode 100644
index 0000000..e69de29
diff --git a/s6/service b/s6/service
index 730c405..47b2d4a 100755
--- a/s6/service
+++ b/s6/service
@@ -7,14 +7,14 @@ start() {
 }
 
 stop() {
-  s6-svc -wD -d -T2500 /var/run/s6/services/$service
+  /command/s6-svc -wD -d -T2500 /run/service/"$service"
 }
 
 restart() {
   local pid
 
   # Get the PID(s) of the service we are asking to restart
-  mapfile -t pids < <(pgrep $service)  
+  mapfile -t pids < <(pgrep "$service")
 
   # Only attempt to stop the service if it is already running
   if [ "${#pids[@]}" -gt 0 ]; then
@@ -22,30 +22,30 @@ restart() {
 
     for pid in "${pids[@]}"; do
       # Loop until we are certain that the process has been stopped
-      while test -d /proc/$pid; do
+      while test -d /proc/"$pid"; do
         sleep 0.2
       done
     done
   fi
 
   # Check it hasn't been started by something else in the meantime
-  pid=$(pgrep $service)
-  
+  pid=$(pgrep "$service")
+
   # Only attempt to start the service if it is not already running
   if [ -z "$pid" ]; then
-    s6-svc -wu -u -T2500 /var/run/s6/services/$service
+    /command/s6-svc -wu -u -T2500 /run/service/"$service"
   fi
-  
+
 }
 
 status() {
-  s6-svstat /var/run/s6/services/$service
+  /command/s6-svstat /run/service/"$service"
 }
 
 service="$1"
 command="$2"
 
-if [[ ! -d "/var/run/s6/services/$service" ]] ; then
+if [[ ! -d "/run/service/$service" ]] ; then
   echo "s6 service not found for $service, exiting..."
   exit
 fi;
diff --git a/scripts/bash_functions.sh b/scripts/bash_functions.sh
new file mode 100644
index 0000000..657c473
--- /dev/null
+++ b/scripts/bash_functions.sh
@@ -0,0 +1,473 @@
+#!/bin/bash
+# Some of the bash_functions use utilities from Pi-hole's utils.sh
+# shellcheck disable=SC2154
+# shellcheck source=/dev/null
+. /opt/pihole/utils.sh
+
+export setupVars="/etc/pihole/setupVars.conf"
+export FTLconf="/etc/pihole/pihole-FTL.conf"
+export dnsmasqconfig="/etc/dnsmasq.d/01-pihole.conf"
+export adlistFile="/etc/pihole/adlists.list"
+
+change_setting() {
+    addOrEditKeyValPair "${setupVars}" "${1}" "${2}"
+}
+
+changeFTLsetting() {
+    addOrEditKeyValPair "${FTLconf}" "${1}" "${2}"
+}
+
+# shellcheck disable=SC2034
+ensure_basic_configuration() {
+
+    # Set Debian webserver variables for installConfigs
+    LIGHTTPD_USER="www-data"
+    LIGHTTPD_GROUP="www-data"
+    LIGHTTPD_CFG="lighttpd.conf.debian"
+    installConfigs
+    installLogrotate || true #installLogRotate can return 2 or 3, but we are still OK to continue in that case
+
+    if [ ! -f "${setupVars}" ]; then
+        install -m 644 /dev/null "${setupVars}"
+        echo "Creating empty ${setupVars} file."
+        # The following setting needs to exist else the web interface version won't show in pihole -v
+        change_setting "INSTALL_WEB_INTERFACE" "true"
+    fi
+
+    set +e
+    mkdir -p /var/run/pihole /var/log/pihole
+    touch /var/log/pihole/FTL.log /var/log/pihole/pihole.log
+
+    chown pihole:root /etc/lighttpd
+
+    # In case of `pihole` UID being changed, re-chown the pihole scripts and pihole command
+    chown -R pihole:root "${PI_HOLE_INSTALL_DIR}"
+    chown pihole:root "${PI_HOLE_BIN_DIR}/pihole"
+
+    set -e
+    # Update version numbers
+    pihole updatechecker
+    # Re-write all of the setupVars to ensure required ones are present (like QUERY_LOGGING)
+
+    # If the setup variable file exists,
+    if [[ -e "${setupVars}" ]]; then
+        cp -f "${setupVars}" "${setupVars}.update.bak"
+    fi
+
+    # Remove any existing macvendor.db and replace it with a symblink to the one moved to the root directory (see install.sh)
+    if [[ -f "/etc/pihole/macvendor.db" ]]; then
+        rm /etc/pihole/macvendor.db
+    fi
+    ln -s /macvendor.db /etc/pihole/macvendor.db
+
+    # When fresh empty directory volumes are used then we need to create this file
+    if [ ! -f /etc/dnsmasq.d/01-pihole.conf ] ; then
+        cp /etc/.pihole/advanced/01-pihole.conf /etc/dnsmasq.d/
+    fi;
+
+    # setup_or_skip_gravity
+}
+
+validate_env() {
+    # Optional FTLCONF_REPLY_ADDR4 is a valid IP
+    # nc won't throw any text based errors when it times out connecting to a valid IP, otherwise it complains about the DNS name being garbage
+    # if nc doesn't behave as we expect on a valid IP the routing table should be able to look it up and return a 0 retcode
+    if [[ "$(nc -4 -w1 -z "$FTLCONF_REPLY_ADDR4" 53 2>&1)" != "" ]] && ! ip route get "$FTLCONF_REPLY_ADDR4" > /dev/null ; then
+        echo "ERROR: FTLCONF_REPLY_ADDR4 Environment variable ($FTLCONF_REPLY_ADDR4) doesn't appear to be a valid IPv4 address"
+        exit 1
+    fi
+
+    # Optional IPv6 is a valid address
+    if [[ -n "$FTLCONF_REPLY_ADDR6" ]] ; then
+        if [[ "$FTLCONF_REPLY_ADDR6" == 'kernel' ]] ; then
+            echo "ERROR: You passed in IPv6 with a value of 'kernel', this maybe because you do not have IPv6 enabled on your network"
+            unset FTLCONF_REPLY_ADDR6
+            exit 1
+        fi
+        if [[ "$(nc -6 -w1 -z "$FTLCONF_REPLY_ADDR6" 53 2>&1)" != "" ]] && ! ip route get "$FTLCONF_REPLY_ADDR6" > /dev/null ; then
+            echo "ERROR: FTLCONF_REPLY_ADDR6 Environment variable ($FTLCONF_REPLY_ADDR6) doesn't appear to be a valid IPv6 address"
+            echo "  TIP: If your server is not IPv6 enabled just remove '-e FTLCONF_REPLY_ADDR6' from your docker container"
+            exit 1
+        fi
+    fi;
+}
+
+setup_FTL_User(){
+    # Run DNSMASQ as root user to avoid SHM permission issues
+    if grep -r -q '^\s*user=' /etc/dnsmasq.* ; then
+        # Change user that had been set previously to root
+        for f in $(grep -r -l '^\s*user=' /etc/dnsmasq.*); do
+            sed -i "/^\s*user=/ c\user=${DNSMASQ_USER}" "${f}"
+        done
+    else
+      echo -e "\nuser=${DNSMASQ_USER}" >> /etc/dnsmasq.conf
+    fi
+}
+
+setup_FTL_Interface(){
+    local interface="${INTERFACE:-eth0}"
+
+    # Set the interface for FTL to listen on
+    local interfaceType='default'
+    if [ "$interface" != 'eth0' ] ; then
+      interfaceType='custom'
+    fi;
+    echo "FTL binding to $interfaceType interface: $interface"
+    change_setting "PIHOLE_INTERFACE" "${interface}"
+}
+
+setup_FTL_CacheSize() {
+    local warning="WARNING: CUSTOM_CACHE_SIZE not used"
+    local dnsmasq_pihole_01_location="/etc/dnsmasq.d/01-pihole.conf"
+    # Quietly exit early for empty or default
+    if [[ -z "${CUSTOM_CACHE_SIZE}" || "${CUSTOM_CACHE_SIZE}" == '10000' ]] ; then return ; fi
+
+    if [[ "${DNSSEC}" == "true" ]] ; then
+        echo "$warning - Cannot change cache size if DNSSEC is enabled"
+        return
+    fi
+
+    if ! echo "$CUSTOM_CACHE_SIZE" | grep -q '^[0-9]*$' ; then
+        echo "$warning - $CUSTOM_CACHE_SIZE is not an integer"
+        return
+    fi
+
+    local -i custom_cache_size="$CUSTOM_CACHE_SIZE"
+    if (( custom_cache_size < 0 )); then
+        echo "$warning - $custom_cache_size is not a positive integer or zero"
+        return
+    fi
+    echo "Custom CUSTOM_CACHE_SIZE set to $custom_cache_size"
+
+    change_setting "CACHE_SIZE" "$custom_cache_size"
+    sed -i "s/^cache-size=\s*[0-9]*/cache-size=$custom_cache_size/" ${dnsmasq_pihole_01_location}
+}
+
+apply_FTL_Configs_From_Env(){
+    # Get all exported environment variables starting with FTLCONF_ as a prefix and call the changeFTLsetting
+    # function with the environment variable's suffix as the key. This allows applying any pihole-FTL.conf
+    # setting defined here: https://docs.pi-hole.net/ftldns/configfile/
+    declare -px | grep FTLCONF_ | sed -E 's/declare -x FTLCONF_([^=]+)=\"(.+)\"/\1 \2/' | while read -r name value
+    do
+        echo "Applying pihole-FTL.conf setting $name=$value"
+        changeFTLsetting "$name" "$value"
+    done
+}
+
+setup_FTL_dhcp() {
+  if [ -z "${DHCP_START}" ] || [ -z "${DHCP_END}" ] || [ -z "${DHCP_ROUTER}" ]; then
+    echo "ERROR: Won't enable DHCP server because mandatory Environment variables are missing: DHCP_START, DHCP_END and/or DHCP_ROUTER"
+    change_setting "DHCP_ACTIVE" "false"
+  else
+    change_setting "DHCP_ACTIVE" "${DHCP_ACTIVE}"
+    change_setting "DHCP_START" "${DHCP_START}"
+    change_setting "DHCP_END" "${DHCP_END}"
+    change_setting "DHCP_ROUTER" "${DHCP_ROUTER}"
+    change_setting "DHCP_LEASETIME" "${DHCP_LEASETIME}"
+    change_setting "PIHOLE_DOMAIN" "${PIHOLE_DOMAIN}"
+    change_setting "DHCP_IPv6" "${DHCP_IPv6}"
+    change_setting "DHCP_rapid_commit" "${DHCP_rapid_commit}"
+  fi
+}
+
+setup_FTL_query_logging(){
+    if [ "${QUERY_LOGGING_OVERRIDE}" == "false" ]; then
+        echo "::: Disabling Query Logging"
+        change_setting "QUERY_LOGGING" "$QUERY_LOGGING_OVERRIDE"
+        removeKey "${dnsmasqconfig}" log-queries
+    else
+        # If it is anything other than false, set it to true
+        change_setting "QUERY_LOGGING" "true"
+        # Set pihole logging on for good measure
+        echo "::: Enabling Query Logging"
+        addKey "${dnsmasqconfig}" log-queries
+    fi
+
+}
+
+setup_FTL_server(){
+    [ -n "${REV_SERVER}" ] && change_setting "REV_SERVER" "$REV_SERVER"
+    [ -n "${REV_SERVER_DOMAIN}" ] && change_setting "REV_SERVER_DOMAIN" "$REV_SERVER_DOMAIN"
+    [ -n "${REV_SERVER_TARGET}" ] && change_setting "REV_SERVER_TARGET" "$REV_SERVER_TARGET"
+    [ -n "${REV_SERVER_CIDR}" ] && change_setting "REV_SERVER_CIDR" "$REV_SERVER_CIDR"
+
+    if [ -z "$REV_SERVER" ];then
+        # If the REV_SERVER* variables are set, then there is no need to add these.
+        # If it is not set, then adding these variables is fine, and they will be converted by the Pi-hole install script
+        [ -n "${CONDITIONAL_FORWARDING}" ] && change_setting "CONDITIONAL_FORWARDING" "$CONDITIONAL_FORWARDING"
+        [ -n "${CONDITIONAL_FORWARDING_IP}" ] && change_setting "CONDITIONAL_FORWARDING_IP" "$CONDITIONAL_FORWARDING_IP"
+        [ -n "${CONDITIONAL_FORWARDING_DOMAIN}" ] && change_setting "CONDITIONAL_FORWARDING_DOMAIN" "$CONDITIONAL_FORWARDING_DOMAIN"
+        [ -n "${CONDITIONAL_FORWARDING_REVERSE}" ] && change_setting "CONDITIONAL_FORWARDING_REVERSE" "$CONDITIONAL_FORWARDING_REVERSE"
+    fi
+}
+
+setup_FTL_upstream_DNS(){
+    if [ -z "${PIHOLE_DNS_}" ]; then
+        # For backward compatibility, if DNS1 and/or DNS2 are set, but PIHOLE_DNS_ is not, convert them to
+        # a semi-colon delimited string and store in PIHOLE_DNS_
+        # They are not used anywhere if PIHOLE_DNS_ is set already
+        [ -n "${DNS1}" ] && echo "Converting DNS1 to PIHOLE_DNS_" && PIHOLE_DNS_="$DNS1"
+        [[ -n "${DNS2}" && "${DNS2}" != "no" ]] && echo "Converting DNS2 to PIHOLE_DNS_" && PIHOLE_DNS_="$PIHOLE_DNS_;$DNS2"
+    fi
+
+    # Parse the PIHOLE_DNS variable, if it exists, and apply upstream servers to Pi-hole config
+    if [ -n "${PIHOLE_DNS_}" ]; then
+        echo "Setting DNS servers based on PIHOLE_DNS_ variable"
+        # Remove any PIHOLE_DNS_ entries from setupVars.conf, if they exist
+        sed -i '/PIHOLE_DNS_/d' /etc/pihole/setupVars.conf
+        # Split into an array (delimited by ;)
+        # Loop through and add them one by one to setupVars.conf
+        IFS=";" read -r -a PIHOLE_DNS_ARR <<< "${PIHOLE_DNS_}"
+        # PIHOLE_DNS_ARR=(${PIHOLE_DNS_//;/ })
+        count=1
+        valid_entries=0
+        for i in "${PIHOLE_DNS_ARR[@]}"; do
+            if valid_ip "$i" || valid_ip6 "$i" ; then
+            change_setting "PIHOLE_DNS_$count" "$i"
+            ((count=count+1))
+            ((valid_entries=valid_entries+1))
+            continue
+            fi
+            # shellcheck disable=SC2086
+            if [ -n "$(dig +short ${i//#*/})" ]; then
+            # If the "address" is a domain (for example a docker link) then try to resolve it and add
+            # the result as a DNS server in setupVars.conf.
+            resolved_ip="$(dig +short ${i//#*/} | head -n 1)"
+            if [ -n "${i//*#/}" ] && [ "${i//*#/}" != "${i//#*/}" ]; then
+                resolved_ip="${resolved_ip}#${i//*#/}"
+            fi
+            echo "Resolved ${i} from PIHOLE_DNS_ as: ${resolved_ip}"
+            if valid_ip "$resolved_ip" || valid_ip6 "$resolved_ip" ; then
+                change_setting "PIHOLE_DNS_$count" "$resolved_ip"
+                ((count=count+1))
+                ((valid_entries=valid_entries+1))
+                continue
+            fi
+            fi
+            # If the above tests fail then this is an invalid DNS server
+            echo "Invalid entry detected in PIHOLE_DNS_: ${i}"
+        done
+
+        if [ $valid_entries -eq 0 ]; then
+        echo "No Valid entries detected in PIHOLE_DNS_. Aborting"
+        exit 1
+        fi
+    else
+        # Environment variable has not been set, but there may be existing values in an existing setupVars.conf
+        # if this is the case, we do not want to overwrite these with the defaults of 8.8.8.8 and 8.8.4.4
+        # Pi-hole can run with only one upstream configured, so we will just check for one.
+        setupVarsDNS="$(grep 'PIHOLE_DNS_' /etc/pihole/setupVars.conf || true)"
+
+        if [ -z "${setupVarsDNS}" ]; then
+            echo "Configuring default DNS servers: 8.8.8.8, 8.8.4.4"
+            change_setting "PIHOLE_DNS_1" "8.8.8.8"
+            change_setting "PIHOLE_DNS_2" "8.8.4.4"
+        else
+            echo "Existing DNS servers detected in setupVars.conf. Leaving them alone"
+        fi
+    fi
+}
+
+setup_FTL_ProcessDNSSettings(){
+    # Commit settings to 01-pihole.conf
+
+    # shellcheck source=/dev/null
+    . /opt/pihole/webpage.sh
+    ProcessDNSSettings
+}
+
+setup_lighttpd_bind() {
+    local serverip="${FTLCONF_REPLY_ADDR4}"
+    # if using '--net=host' only bind lighttpd on $FTLCONF_REPLY_ADDR6 and localhost
+    if grep -q "docker" /proc/net/dev && [[ $serverip != 0.0.0.0 ]]; then #docker (docker0 by default) should only be present on the host system
+        if ! grep -q "server.bind" /etc/lighttpd/lighttpd.conf ; then # if the declaration is already there, don't add it again
+            sed -i -E "s/server\.port\s+\=\s+([0-9]+)/server.bind\t\t = \"${serverip}\"\nserver.port\t\t = \1\n"\$SERVER"\[\"socket\"\] == \"127\.0\.0\.1:\1\" \{\}/" /etc/lighttpd/lighttpd.conf
+        fi
+    fi
+}
+
+setup_web_php_env() {
+    if [ -z "$VIRTUAL_HOST" ] ; then
+      VIRTUAL_HOST="$FTLCONF_REPLY_ADDR4"
+    fi;
+
+    for config_var in "VIRTUAL_HOST" "CORS_HOSTS" "PHP_ERROR_LOG" "PIHOLE_DOCKER_TAG" "TZ"; do
+      local beginning_of_line="\t\t\t\"${config_var}\" => "
+      if grep -qP "$beginning_of_line" "$PHP_ENV_CONFIG" ; then
+        # replace line if already present
+        sed -i "/${beginning_of_line}/c\\${beginning_of_line}\"${!config_var}\"," "$PHP_ENV_CONFIG"
+      else
+        # add line otherwise
+        sed -i "/bin-environment/ a\\${beginning_of_line}\"${!config_var}\"," "$PHP_ENV_CONFIG"
+      fi
+    done
+
+    echo "Added ENV to php:"
+    grep -E '(VIRTUAL_HOST|CORS_HOSTS|PHP_ERROR_LOG|PIHOLE_DOCKER_TAG|TZ)' "$PHP_ENV_CONFIG"
+}
+
+setup_web_port() {
+    local warning="WARNING: Custom WEB_PORT not used"
+    # Quietly exit early for empty or default
+    if [[ -z "${WEB_PORT}" || "${WEB_PORT}" == '80' ]] ; then return ; fi
+
+    if ! echo "$WEB_PORT" | grep -q '^[0-9][0-9]*$' ; then
+        echo "$warning - $WEB_PORT is not an integer"
+        return
+    fi
+
+    local -i web_port="$WEB_PORT"
+    if (( web_port < 1 || web_port > 65535 )); then
+        echo "$warning - $web_port is not within valid port range of 1-65535"
+        return
+    fi
+    echo "Custom WEB_PORT set to $web_port"
+    echo "INFO: Without proper router DNAT forwarding to $FTLCONF_REPLY_ADDR4:$web_port, you may not get any blocked websites on ads"
+
+    # Update lighttpd's port
+    sed -i '/server.port\s*=\s*80\s*$/ s/80/'"${WEB_PORT}"'/g' /etc/lighttpd/lighttpd.conf
+
+}
+
+setup_web_theme(){
+    # Parse the WEBTHEME variable, if it exists, and set the selected theme if it is one of the supported values.
+    # If an invalid theme name was supplied, setup WEBTHEME to use the default-light theme.
+    if [ -n "${WEBTHEME}" ]; then
+        case "${WEBTHEME}" in
+        "default-dark" | "default-darker" | "default-light" | "default-auto" | "lcars")
+            echo "Setting Web Theme based on WEBTHEME variable, using value ${WEBTHEME}"
+            change_setting "WEBTHEME" "${WEBTHEME}"
+            ;;
+        *)
+            echo "Invalid theme name supplied: ${WEBTHEME}, falling back to default-light."
+            change_setting "WEBTHEME" "default-light"
+            ;;
+        esac
+    fi
+}
+
+load_web_password_secret() {
+   # If WEBPASSWORD is not set at all, attempt to read password from WEBPASSWORD_FILE,
+   # allowing secrets to be passed via docker secrets
+   if [ -z "${WEBPASSWORD+x}" ] && [ -n "${WEBPASSWORD_FILE}" ] && [ -r "${WEBPASSWORD_FILE}" ]; then
+     WEBPASSWORD=$(<"${WEBPASSWORD_FILE}")
+   fi;
+}
+
+setup_web_password() {
+    if [ -z "${WEBPASSWORD+x}" ] ; then
+        # ENV WEBPASSWORD is not set
+
+        # Exit if setupvars already has a password
+        setup_var_exists "WEBPASSWORD" && return
+
+        # Generate new random password
+        WEBPASSWORD=$(tr -dc _A-Z-a-z-0-9 < /dev/urandom | head -c 8)
+        echo "Assigning random password: $WEBPASSWORD"
+    else
+        # ENV WEBPASSWORD is set an will be used
+        echo "::: Assigning password defined by Environment Variable"
+    fi
+
+    PASS="$WEBPASSWORD"
+
+    # Explicitly turn off bash printing when working with secrets
+    { set +x; } 2>/dev/null
+
+    if [[ "$PASS" == "" ]] ; then
+        echo "" | pihole -a -p
+    else
+        pihole -a -p "$PASS" "$PASS"
+    fi
+
+    # To avoid printing this if conditional in bash debug, turn off  debug above..
+    # then re-enable debug if necessary (more code but cleaner printed output)
+    if [ "${PH_VERBOSE:-0}" -gt 0 ] ; then
+        set -x
+    fi
+}
+
+setup_ipv4_ipv6() {
+    local ip_versions="IPv4 and IPv6"
+    if [ "${IPv6,,}" != "true" ] ; then
+        ip_versions="IPv4"
+        sed -i '/use-ipv6.pl/ d' /etc/lighttpd/lighttpd.conf
+    fi;
+    echo "Using $ip_versions"
+}
+
+test_configs() {
+    set -e
+    echo -n '::: Testing lighttpd config: '
+    lighttpd -t -f /etc/lighttpd/lighttpd.conf || exit 1
+    set +e
+    echo "::: All config checks passed, cleared for startup ..."
+}
+
+setup_blocklists() {
+    # Exit/return early without setting up adlists with defaults for any of the following conditions:
+    # 1. skip_setup_blocklists env is set
+    exit_string="(exiting ${FUNCNAME[0]} early)"
+
+    if [ -n "${skip_setup_blocklists}" ]; then
+        echo "::: skip_setup_blocklists requested ($exit_string)"
+        return
+    fi
+
+    # 2. The adlist file exists already (restarted container or volume mounted list)
+    if [ -f "${adlistFile}" ]; then
+        echo "::: Preexisting ad list ${adlistFile} detected ($exit_string)"
+        cat "${adlistFile}"
+        return
+    fi
+
+    echo "::: ${FUNCNAME[0]} now setting default blocklists up: "
+    echo "::: TIP: Use a docker volume for ${adlistFile} if you want to customize for first boot"
+    installDefaultBlocklists
+
+    echo "::: Blocklists (${adlistFile}) now set to:"
+    cat "${adlistFile}"
+}
+
+setup_var_exists() {
+    local KEY="$1"
+    if [ -n "$2" ]; then
+        local REQUIRED_VALUE="[^\n]+"
+    fi
+    if grep -Pq "^${KEY}=${REQUIRED_VALUE}" "$setupVars"; then
+        echo "::: Pre existing ${KEY} found"
+        true
+    else
+        false
+    fi
+}
+
+setup_web_temp_unit() {
+  local UNIT="${TEMPERATUREUNIT}"
+  # check if var is empty
+  if [[ "$UNIT" != "" ]] ; then
+      # check if we have valid units
+      if [[ "$UNIT" == "c" || "$UNIT" == "k" || $UNIT == "f" ]] ; then
+          pihole -a -"${UNIT}"
+      fi
+  fi
+}
+
+setup_web_layout() {
+  local LO="${WEBUIBOXEDLAYOUT}"
+  # check if var is empty
+  if [[ "$LO" != "" ]] ; then
+      # check if we have valid types boxed | traditional
+      if [[ "$LO" == "traditional" || "$LO" == "boxed" ]] ; then
+          change_setting "WEBUIBOXEDLAYOUT" "$WEBUIBOXEDLAYOUT"
+      fi
+  fi
+}
+
+setup_admin_email() {
+  local EMAIL="${ADMIN_EMAIL}"
+  # check if var is empty
+  if [[ "$EMAIL" != "" ]] ; then
+      pihole -a -e "$EMAIL"
+  fi
+}
diff --git a/s6/debian-root/etc/cont-init.d/20-start.sh b/scripts/gravityonboot.sh
old mode 100644
new mode 100755
similarity index 51%
rename from s6/debian-root/etc/cont-init.d/20-start.sh
rename to scripts/gravityonboot.sh
index 78efae6..d664a99
--- a/s6/debian-root/etc/cont-init.d/20-start.sh
+++ b/scripts/gravityonboot.sh
@@ -1,18 +1,4 @@
-#!/usr/bin/with-contenv bash
-set -e
-
-bashCmd='bash -e'
-if [ "${PH_VERBOSE:-0}" -gt 0 ] ; then
-    set -x ;
-    bashCmd='bash -e -x'
-fi
-
-$bashCmd /start.sh
-# Gotta go fast, no time for gravity
-if [ -n "$PYTEST" ]; then
-    sed -i 's/^gravity_spinup$/#gravity_spinup # DISABLED FOR PYTEST/g' "$(which gravity.sh)"
-fi
-
+#!/bin/bash
 gravityDBfile="/etc/pihole/gravity.db"
 config_file="/etc/pihole/pihole-FTL.conf"
 # make a point to mention which config file we're checking, as breadcrumb to revisit if/when pihole-FTL.conf is succeeded by TOML
@@ -21,19 +7,12 @@ if [[ -f "${config_file}" ]]; then
     gravityDBfile="$(grep --color=never -Po "^GRAVITYDB=\K.*" "${config_file}" 2> /dev/null || echo "/etc/pihole/gravity.db")"
 fi
 
-
-if [ -z "$SKIPGRAVITYONBOOT" ] || [ ! -e "${gravityDBfile}" ]; then
+if [ -z "$SKIPGRAVITYONBOOT" ] || [ ! -f "${gravityDBfile}" ]; then
     if [ -n "$SKIPGRAVITYONBOOT" ];then
         echo "  SKIPGRAVITYONBOOT is set, however ${gravityDBfile} does not exist (Likely due to a fresh volume). This is a required file for Pi-hole to operate."
         echo "  Ignoring SKIPGRAVITYONBOOT on this occaision."
     fi
-
-    echo '@reboot root PATH="$PATH:/usr/sbin:/usr/local/bin/" pihole updateGravity >/var/log/pihole/pihole_updateGravity.log || cat /var/log/pihole/pihole_updateGravity.log' > /etc/cron.d/gravity-on-boot
+    pihole -g
 else
     echo "  Skipping Gravity Database Update."
-    [ ! -e /etc/cron.d/gravity-on-boot ] || rm /etc/cron.d/gravity-on-boot &>/dev/null
-fi
-
-pihole -v
-
-echo "  Container tag is: ${PIHOLE_DOCKER_TAG}"
\ No newline at end of file
+fi
\ No newline at end of file
diff --git a/install.sh b/scripts/install.sh
similarity index 85%
rename from install.sh
rename to scripts/install.sh
index 6e2ee05..51b581c 100644
--- a/install.sh
+++ b/scripts/install.sh
@@ -1,4 +1,5 @@
 #!/bin/bash -ex
+# shellcheck disable=SC2034
 
 mkdir -p /etc/pihole/
 mkdir -p /var/run/pihole
@@ -8,24 +9,24 @@ WEB_LOCAL_REPO=/var/www/html/admin
 
 setupVars=/etc/pihole/setupVars.conf
 
-s6_download_url() {
+detect_arch() {
   DETECTED_ARCH=$(dpkg --print-architecture)
   S6_ARCH=$DETECTED_ARCH
   case $DETECTED_ARCH in
+  amd64)
+    S6_ARCH="x86_64";;
   armel)
     S6_ARCH="arm";;
   armhf)
-    S6_ARCH="arm";;
+    S6_ARCH="armhf";;
   arm64)
     S6_ARCH="aarch64";;
   i386)
-    S6_ARCH="x86";;
-  ppc64el)
-    S6_ARCH="ppc64le";;
+    S6_ARCH="i686";;
 esac
-  echo "https://github.com/just-containers/s6-overlay/releases/download/${S6_OVERLAY_VERSION}/s6-overlay-${S6_ARCH}.tar.gz"
 }
 
+
 # Helps to have some additional tools in the dev image when debugging
 if [[ "${PIHOLE_DOCKER_TAG}" = 'nightly' ||  "${PIHOLE_DOCKER_TAG}" = 'dev' ]]; then
   apt-get update
@@ -33,9 +34,10 @@ if [[ "${PIHOLE_DOCKER_TAG}" = 'nightly' ||  "${PIHOLE_DOCKER_TAG}" = 'dev' ]];
   rm -rf /var/lib/apt/lists/*
 fi
 
-ln -s `which echo` /usr/local/bin/whiptail
-curl -L -s "$(s6_download_url)" | tar xvzf - -C /
-mv /init /s6-init
+detect_arch
+
+curl -L -s "https://github.com/just-containers/s6-overlay/releases/download/${S6_OVERLAY_VERSION}/s6-overlay-noarch.tar.xz" | tar Jxpf - -C /
+curl -L -s "https://github.com/just-containers/s6-overlay/releases/download/${S6_OVERLAY_VERSION}/s6-overlay-${S6_ARCH}.tar.xz" | tar Jxpf - -C /
 
 # Preseed variables to assist with using --unattended install
 {
@@ -62,7 +64,6 @@ if [[ "${PIHOLE_DOCKER_TAG}" = 'nightly'  ]]; then
   yes | pihole checkout dev
 fi
 
-sed -i 's/readonly //g' /opt/pihole/webpage.sh
 sed -i '/^WEBPASSWORD/d' /etc/pihole/setupVars.conf
 
 # sed a new function into the `pihole` script just above the `helpFunc()` function for later use.
diff --git a/scripts/start.sh b/scripts/start.sh
new file mode 100755
index 0000000..ccc2659
--- /dev/null
+++ b/scripts/start.sh
@@ -0,0 +1,76 @@
+#!/bin/bash -e
+
+# If user has set QUERY_LOGGING Env Var, copy it out to _OVERRIDE,
+# else it will get overridden when we source bash_functions.sh
+# (which then sources basic-install.sh)
+[ -n "${QUERY_LOGGING}" ] && export QUERY_LOGGING_OVERRIDE="${QUERY_LOGGING}"
+
+# Legacy Env Vars preserved for backwards compatibility - convert them to FTLCONF_ equivalents
+[ -n "${ServerIP}" ] && echo "ServerIP is deprecated. Converting to FTLCONF_REPLY_ADDR4" && export "FTLCONF_REPLY_ADDR4"="$ServerIP"
+[ -n "${ServerIPv6}" ] && echo "ServerIPv6 is deprecated. Converting to FTLCONF_REPLY_ADDR6" && export "FTLCONF_REPLY_ADDR6"="$ServerIPv6"
+
+# The below functions are all contained in bash_functions.sh
+# shellcheck source=/dev/null
+. /bash_functions.sh
+
+# shellcheck source=/dev/null
+SKIP_INSTALL=true . "${PIHOLE_INSTALL}"
+
+echo " ::: Starting docker specific checks & setup for docker pihole/pihole"
+
+# TODO:
+#if [ ! -f /.piholeFirstBoot ] ; then
+#    echo " ::: Not first container startup so not running docker's setup, re-create container to run setup again"
+#else
+#    regular_setup_functions
+#fi
+
+# Initial checks
+# ===========================
+validate_env || exit 1
+ensure_basic_configuration
+
+# FTL setup
+# ===========================
+setup_FTL_upstream_DNS
+[[ -n "${DHCP_ACTIVE}" && ${DHCP_ACTIVE} == "true" ]] && echo "Setting DHCP server" && setup_FTL_dhcp
+apply_FTL_Configs_From_Env
+setup_FTL_User
+setup_FTL_Interface
+setup_FTL_CacheSize
+setup_FTL_query_logging
+setup_FTL_server || true
+[ -n "${DNS_FQDN_REQUIRED}" ] && change_setting "DNS_FQDN_REQUIRED" "$DNS_FQDN_REQUIRED"
+[ -n "${DNSSEC}" ] && change_setting "DNSSEC" "$DNSSEC"
+[ -n "${DNS_BOGUS_PRIV}" ] && change_setting "DNS_BOGUS_PRIV" "$DNS_BOGUS_PRIV"
+setup_FTL_ProcessDNSSettings
+
+# Web interface setup
+# ===========================
+setup_web_port
+load_web_password_secret
+setup_web_password
+setup_web_theme
+setup_web_temp_unit
+setup_web_layout
+setup_web_php_env
+
+# lighttpd setup
+# ===========================
+setup_ipv4_ipv6
+setup_lighttpd_bind
+
+# Misc Setup
+# ===========================
+setup_admin_email
+setup_blocklists
+
+test_configs
+
+[ -f /.piholeFirstBoot ] && rm /.piholeFirstBoot
+
+echo "::: Docker start setup complete"
+
+pihole -v
+
+echo "  Container tag is: ${PIHOLE_DOCKER_TAG}"
diff --git a/start.sh b/start.sh
deleted file mode 100755
index c5ae36d..0000000
--- a/start.sh
+++ /dev/null
@@ -1,219 +0,0 @@
-#!/bin/bash -e
-# Dockerfile variables
-export TAG
-export ServerIP
-export ServerIPv6
-export PYTEST
-export PHP_ENV_CONFIG
-export PHP_ERROR_LOG
-export HOSTNAME
-export WEBLOGDIR
-export DNS1
-export DNS2
-export DNSSEC
-export DNS_BOGUS_PRIV
-export DNS_FQDN_REQUIRED
-export INTERFACE
-export DNSMASQ_LISTENING_BEHAVIOUR="$DNSMASQ_LISTENING"
-export IPv6
-export WEB_PORT
-export REV_SERVER
-export REV_SERVER_DOMAIN
-export REV_SERVER_TARGET
-export REV_SERVER_CIDR
-export CONDITIONAL_FORWARDING
-export CONDITIONAL_FORWARDING_IP
-export CONDITIONAL_FORWARDING_DOMAIN
-export CONDITIONAL_FORWARDING_REVERSE
-export TEMPERATUREUNIT
-export ADMIN_EMAIL
-export WEBUIBOXEDLAYOUT
-export QUERY_LOGGING
-export PIHOLE_DNS_
-export DHCP_ACTIVE
-export DHCP_START
-export DHCP_END
-export DHCP_ROUTER
-export DHCP_LEASETIME
-export PIHOLE_DOMAIN
-export DHCP_IPv6
-export DHCP_rapid_commit
-export WEBTHEME
-export WEBPASSWORD
-export CUSTOM_CACHE_SIZE
-
-export adlistFile='/etc/pihole/adlists.list'
-
-# If user has set QUERY_LOGGING Env Var, copy it out to _OVERRIDE, else it will get reset when we source the next two files
-# Come back to it at the end of the file
-[ -n "${QUERY_LOGGING}" ] && QUERY_LOGGING_OVERRIDE="${QUERY_LOGGING}"
-
-# The below functions are all contained in bash_functions.sh
-. /bash_functions.sh
-
-# Ensure we have all functions available to update our configurations
-. /opt/pihole/webpage.sh
-
-# SKIP_INSTALL prevents the install from actually running
-SKIP_INSTALL=true . "${PIHOLE_INSTALL}"
-
-echo " ::: Starting docker specific checks & setup for docker pihole/pihole"
-
-# TODO:
-#if [ ! -f /.piholeFirstBoot ] ; then
-#    echo " ::: Not first container startup so not running docker's setup, re-create container to run setup again"
-#else
-#    regular_setup_functions
-#fi
-
-fix_capabilities
-load_web_password_secret
-validate_env || exit 1
-prepare_configs
-
-[ -n "${PIHOLE_INTERFACE}" ] && change_setting "PIHOLE_INTERFACE" "$PIHOLE_INTERFACE"
-[ -n "${IPV4_ADDRESS}" ] && change_setting "IPV4_ADDRESS" "$IPV4_ADDRESS"
-[ -n "${INSTALL_WEB_SERVER}" ] && change_setting "INSTALL_WEB_SERVER" "$INSTALL_WEB_SERVER"
-[ -n "${INSTALL_WEB_INTERFACE}" ] && change_setting "INSTALL_WEB_INTERFACE" "$INSTALL_WEB_INTERFACE"
-[ -n "${LIGHTTPD_ENABLED}" ] && change_setting "LIGHTTPD_ENABLED" "$LIGHTTPD_ENABLED"
-[ -n "${DNS_BOGUS_PRIV}" ] && change_setting "DNS_BOGUS_PRIV" "$DNS_BOGUS_PRIV"
-[ -n "${ServerIP}" ] && changeFTLsetting "REPLY_ADDR4" "$ServerIP"
-[ -n "${ServerIPv6}" ] && changeFTLsetting "REPLY_ADDR6" "$ServerIPv6"
-[ -n "${DNS_FQDN_REQUIRED}" ] && change_setting "DNS_FQDN_REQUIRED" "$DNS_FQDN_REQUIRED"
-[ -n "${DNSSEC}" ] && change_setting "DNSSEC" "$DNSSEC"
-[ -n "${REV_SERVER}" ] && change_setting "REV_SERVER" "$REV_SERVER"
-[ -n "${REV_SERVER_DOMAIN}" ] && change_setting "REV_SERVER_DOMAIN" "$REV_SERVER_DOMAIN"
-[ -n "${REV_SERVER_TARGET}" ] && change_setting "REV_SERVER_TARGET" "$REV_SERVER_TARGET"
-[ -n "${REV_SERVER_CIDR}" ] && change_setting "REV_SERVER_CIDR" "$REV_SERVER_CIDR"
-
-# Get all exported environment variables starting with FTLCONF_ as a prefix and call the changeFTLsetting
-# function with the environment variable's suffix as the key. This allows applying any pihole-FTL.conf
-# setting defined here: https://docs.pi-hole.net/ftldns/configfile/
-declare -px | grep FTLCONF_ | sed -E 's/declare -x FTLCONF_([^=]+)=\"(.+)\"/\1 \2/' | while read -r name value
-  do
-    echo "Applying pihole-FTL.conf setting $name=$value"
-    changeFTLsetting "$name" "$value"
-  done
-
-if [ -z "$REV_SERVER" ];then
-    # If the REV_SERVER* variables are set, then there is no need to add these.
-    # If it is not set, then adding these variables is fine, and they will be converted by the Pi-hole install script
-    [ -n "${CONDITIONAL_FORWARDING}" ] && change_setting "CONDITIONAL_FORWARDING" "$CONDITIONAL_FORWARDING"
-    [ -n "${CONDITIONAL_FORWARDING_IP}" ] && change_setting "CONDITIONAL_FORWARDING_IP" "$CONDITIONAL_FORWARDING_IP"
-    [ -n "${CONDITIONAL_FORWARDING_DOMAIN}" ] && change_setting "CONDITIONAL_FORWARDING_DOMAIN" "$CONDITIONAL_FORWARDING_DOMAIN"
-    [ -n "${CONDITIONAL_FORWARDING_REVERSE}" ] && change_setting "CONDITIONAL_FORWARDING_REVERSE" "$CONDITIONAL_FORWARDING_REVERSE"
-fi
-
-if [ -z "${PIHOLE_DNS_}" ]; then
-    # For backward compatibility, if DNS1 and/or DNS2 are set, but PIHOLE_DNS_ is not, convert them to
-    # a semi-colon delimited string and store in PIHOLE_DNS_
-    # They are not used anywhere if PIHOLE_DNS_ is set already
-    [ -n "${DNS1}" ] && echo "Converting DNS1 to PIHOLE_DNS_" && PIHOLE_DNS_="$DNS1"
-    [[ -n "${DNS2}" && "${DNS2}" != "no" ]] && echo "Converting DNS2 to PIHOLE_DNS_" && PIHOLE_DNS_="$PIHOLE_DNS_;$DNS2"
-fi
-
-# Parse the PIHOLE_DNS variable, if it exists, and apply upstream servers to Pi-hole config
-if [ -n "${PIHOLE_DNS_}" ]; then
-    echo "Setting DNS servers based on PIHOLE_DNS_ variable"
-    # Remove any PIHOLE_DNS_ entries from setupVars.conf, if they exist
-    sed -i '/PIHOLE_DNS_/d' /etc/pihole/setupVars.conf
-    # Split into an array (delimited by ;)
-    # Loop through and add them one by one to setupVars.conf
-    PIHOLE_DNS_ARR=(${PIHOLE_DNS_//;/ })
-    count=1
-    valid_entries=0
-    for i in "${PIHOLE_DNS_ARR[@]}"; do
-        if valid_ip "$i" || valid_ip6 "$i" ; then
-          change_setting "PIHOLE_DNS_$count" "$i"
-          ((count=count+1))
-          ((valid_entries=valid_entries+1))
-          continue
-        fi
-        if [ -n "$(dig +short ${i//#*/})" ]; then
-          # If the "address" is a domain (for example a docker link) then try to resolve it and add 
-          # the result as a DNS server in setupVars.conf.
-          resolved_ip="$(dig +short ${i//#*/} | head -n 1)"
-          if [ -n "${i//*#/}" ] && [ "${i//*#/}" != "${i//#*/}" ]; then
-            resolved_ip="${resolved_ip}#${i//*#/}"
-          fi
-          echo "Resolved ${i} from PIHOLE_DNS_ as: ${resolved_ip}"
-          if valid_ip "$resolved_ip" || valid_ip6 "$resolved_ip" ; then
-            change_setting "PIHOLE_DNS_$count" "$resolved_ip"
-            ((count=count+1))
-            ((valid_entries=valid_entries+1))
-            continue
-          fi
-        fi
-        # If the above tests fail then this is an invalid DNS server
-        echo "Invalid entry detected in PIHOLE_DNS_: ${i}"
-    done
-
-    if [ $valid_entries -eq 0 ]; then
-      echo "No Valid entries detected in PIHOLE_DNS_. Aborting"
-      exit 1
-    fi
-else
-    # Environment variable has not been set, but there may be existing values in an existing setupVars.conf
-    # if this is the case, we do not want to overwrite these with the defaults of 8.8.8.8 and 8.8.4.4
-    # Pi-hole can run with only one upstream configured, so we will just check for one.
-    setupVarsDNS="$(grep 'PIHOLE_DNS_' /etc/pihole/setupVars.conf || true)"
-
-    if [ -z "${setupVarsDNS}" ]; then
-      echo "Configuring default DNS servers: 8.8.8.8, 8.8.4.4"
-      change_setting "PIHOLE_DNS_1" "8.8.8.8"
-      change_setting "PIHOLE_DNS_2" "8.8.4.4"
-    else
-      echo "Existing DNS servers detected in setupVars.conf. Leaving them alone"
-    fi
-fi
-
-# Parse the WEBTHEME variable, if it exists, and set the selected theme if it is one of the supported values.
-# If an invalid theme name was supplied, setup WEBTHEME to use the default-light theme.
-if [ -n "${WEBTHEME}" ]; then
-    case "${WEBTHEME}" in
-      "default-dark" | "default-darker" | "default-light" | "default-auto" | "lcars")
-        echo "Setting Web Theme based on WEBTHEME variable, using value ${WEBTHEME}"
-        change_setting "WEBTHEME" "${WEBTHEME}"
-        ;;
-      *)
-        echo "Invalid theme name supplied: ${WEBTHEME}, falling back to default-light."
-        change_setting "WEBTHEME" "default-light"
-        ;;
-    esac
-fi
-
-[[ -n "${DHCP_ACTIVE}" && ${DHCP_ACTIVE} == "true" ]] && echo "Setting DHCP server" && setup_dhcp
-
-setup_web_port "$WEB_PORT"
-setup_web_password
-setup_temp_unit "$TEMPERATUREUNIT"
-setup_ui_layout "$WEBUIBOXEDLAYOUT"
-setup_admin_email "$ADMIN_EMAIL"
-setup_dnsmasq "$INTERFACE" "$DNSMASQ_LISTENING_BEHAVIOUR"
-setup_php_env
-setup_dnsmasq_hostnames "$ServerIP" "$ServerIPv6" "$HOSTNAME"
-setup_ipv4_ipv6
-setup_lighttpd_bind "$ServerIP"
-setup_blocklists
-test_configs
-
-[ -f /.piholeFirstBoot ] && rm /.piholeFirstBoot
-
-# Set QUERY_LOGGING value in setupVars to be that which the user has passed in as an ENV var (if they have)
-[ -n "${QUERY_LOGGING_OVERRIDE}" ] && change_setting "QUERY_LOGGING" "$QUERY_LOGGING_OVERRIDE"
-
-# Source setupVars.conf to get the true value of QUERY_LOGGING
-. ${setupVars}
-
-if [ ${QUERY_LOGGING} == "false" ]; then
-  echo "::: Disabling Query Logging"
-  pihole logging off
-else
-  # If it is anything other than false, set it to true
-  change_setting "QUERY_LOGGING" "true"
-  # Set pihole logging on for good measure
-  echo "::: Enabling Query Logging"
-  pihole logging on
-fi
-
-echo " ::: Docker start setup complete"
diff --git a/test/conftest.py b/test/conftest.py
index 0c190f8..5e92ee6 100644
--- a/test/conftest.py
+++ b/test/conftest.py
@@ -34,7 +34,7 @@ def args_volumes():
 
 @pytest.fixture()
 def args_env():
-    return '-e ServerIP="127.0.0.1"'
+    return '-e FTLCONF_REPLY_ADDR4="127.0.0.1"'
 
 @pytest.fixture()
 def args(args_volumes, args_env):
@@ -138,7 +138,7 @@ def persist_args_volumes():
 
 @pytest.fixture(scope='module')
 def persist_args_env():
-    return '-e ServerIP="127.0.0.1"'
+    return '-e FTLCONF_REPLY_ADDR4="127.0.0.1"'
 
 @pytest.fixture(scope='module')
 def persist_args(persist_args_volumes, persist_args_env):
diff --git a/test/test_bash_functions.py b/test/test_bash_functions.py
index ebdfce1..3d53621 100644
--- a/test/test_bash_functions.py
+++ b/test/test_bash_functions.py
@@ -5,8 +5,9 @@ import re
 
 SETUPVARS_LOC='/etc/pihole/setupVars.conf'
 DNSMASQ_CONFIG_LOC = '/etc/dnsmasq.d/01-pihole.conf'
-EVAL_SETUP_DNSMASQ='. /bash_functions.sh ; eval `grep "^setup_dnsmasq " /start.sh`'
-EVAL_SETUP_WEB_PASSWORD='. /bash_functions.sh ; eval `grep setup_web_password /start.sh`'
+EVAL_SETUP_FTL_CACHESIZE='. ./bash_functions.sh ; eval `grep setup_FTL_CacheSize /start.sh`'
+EVAL_SETUP_FTL_INTERFACE='. ./bash_functions.sh ; eval `grep setup_FTL_Interface /start.sh`'
+EVAL_SETUP_WEB_PASSWORD='. ./bash_functions.sh ; eval `grep setup_web_password /start.sh`'
 
 def _cat(file):
     return 'cat {}'.format(file)
@@ -63,7 +64,7 @@ def test_overrides_default_custom_cache_size(docker, slow, test_args, cache_size
     ''' Changes the cache_size setting to increase or decrease the cache size for dnsmasq'''
     CONFIG_LINE = r'cache-size\s*=\s*{}'.format(cache_size)
 
-    function = docker.run('echo ${CUSTOM_CACHE_SIZE};. ./bash_functions.sh; echo ${CUSTOM_CACHE_SIZE}; eval `grep setup_dnsmasq /start.sh`')
+    function = docker.run('echo ${CUSTOM_CACHE_SIZE};. ./bash_functions.sh; echo ${CUSTOM_CACHE_SIZE}; eval `grep setup_FTL_CacheSize /start.sh`')
     assert "Custom CUSTOM_CACHE_SIZE set to {}".format(cache_size) in function.stdout
     slow(lambda: re.search(CONFIG_LINE, docker.run(_cat(DNSMASQ_CONFIG_LOC)).stdout) != None)
 
@@ -75,7 +76,7 @@ def test_overrides_default_custom_cache_size(docker, slow, test_args, cache_size
 def test_bad_input_to_custom_cache_size(docker, slow, test_args):
     CONFIG_LINE = r'cache-size\s*=\s*10000'
 
-    docker.run('. ./bash_functions.sh; eval `grep setup_dnsmasq /start.sh`')
+    docker.run(EVAL_SETUP_FTL_CACHESIZE)
     slow(lambda: re.search(CONFIG_LINE, docker.run(_cat(DNSMASQ_CONFIG_LOC)).stdout) != None)
 
 @pytest.mark.parametrize('test_args', [
@@ -84,84 +85,23 @@ def test_bad_input_to_custom_cache_size(docker, slow, test_args):
 def test_dnssec_enabled_with_custom_cache_size(docker, slow, test_args):
     CONFIG_LINE = r'cache-size\s*=\s*10000'
 
-    docker.run('. ./bash_functions.sh; eval `grep setup_dnsmasq /start.sh`')
+    docker.run(EVAL_SETUP_FTL_CACHESIZE)
     slow(lambda: re.search(CONFIG_LINE, docker.run(_cat(DNSMASQ_CONFIG_LOC)).stdout) != None)
 
 
-# DNS Environment Variable behavior in combinations of modified pihole LTE settings
-@pytest.mark.skip('broke, needs investigation in v5.0 beta')
-@pytest.mark.parametrize('args_env, expected_stdout, dns1, dns2', [
-    ('',                                     'default DNS', '8.8.8.8', '8.8.4.4' ),
-    ('-e DNS1="1.2.3.4"',                   'custom DNS',  '1.2.3.4', '8.8.4.4' ),
-    ('-e DNS2="1.2.3.4"',                   'custom DNS',  '8.8.8.8', '1.2.3.4' ),
-    ('-e DNS1="1.2.3.4" -e DNS2="2.2.3.4"', 'custom DNS',  '1.2.3.4', '2.2.3.4' ),
-    ('-e DNS1="1.2.3.4" -e DNS2="no"',      'custom DNS',  '1.2.3.4', None ),
-    ('-e DNS2="no"',                        'custom DNS',  '8.8.8.8', None ),
-])
-def test_override_default_servers_with_dns_envvars(docker, slow, args_env, expected_stdout, dns1, dns2):
-    ''' on first boot when DNS vars are NOT set explain default google DNS settings are used
-                   or when DNS vars are set override the pihole DNS settings '''
-    assert docker.run('test -f /.piholeFirstBoot').rc == 0
-    function = docker.run(EVAL_SETUP_DNSMASQ)
-    assert expected_stdout in function.stdout
-    expected_servers = 'server={}\n'.format(dns1) if dns2 == None else 'server={}\nserver={}\n'.format(dns1, dns2)
-    slow(lambda: expected_servers == docker.run('grep "^server=[^/]" /etc/dnsmasq.d/01-pihole.conf').stdout)
-
-
-#@pytest.mark.skipif(os.environ.get('CI') == 'true',
-#                    reason="Can't get setupVar setup to work on travis")
-@pytest.mark.skip('broke, needs investigation in v5.0 beta')
-@pytest.mark.parametrize('args_env, dns1, dns2, expected_stdout', [
-
-    ('', '9.9.9.1', '9.9.9.2',
-     'Existing DNS servers used'),
-    ('-e DNS1="1.2.3.4"', '9.9.9.1', '9.9.9.2',
-     'Docker DNS variables not used\nExisting DNS servers used (9.9.9.1 & 9.9.9.2)'),
-    ('-e DNS2="1.2.3.4"', '8.8.8.8', None,
-     'Docker DNS variables not used\nExisting DNS servers used (8.8.8.8 & unset)'),
-    ('-e DNS1="1.2.3.4" -e DNS2="2.2.3.4"', '1.2.3.4', '2.2.3.4',
-     'Docker DNS variables not used\nExisting DNS servers used (1.2.3.4 & 2.2.3.4'),
-])
-def test_dns_envs_are_secondary_to_setupvars(docker, slow, args_env, expected_stdout, dns1, dns2):
-    ''' on second boot when DNS vars are set just use pihole DNS settings
-                    or when DNS vars and FORCE_DNS var are set override the pihole DNS settings '''
-    # Given we are not booting for the first time
-    assert docker.run('rm /.piholeFirstBoot').rc == 0
-
-    # and a user already has custom pihole dns variables in setup vars    
-    docker.run('sed -i "/^PIHOLE_DNS/ d" {}'.format(SETUPVARS_LOC))
-    docker.run('echo "PIHOLE_DNS_1={}" | tee -a {}'.format(dns1, SETUPVARS_LOC))
-    if dns2:
-        docker.run('echo "PIHOLE_DNS_2={}" | tee -a {}'.format(dns2, SETUPVARS_LOC))
-    docker.run('sync {}'.format(SETUPVARS_LOC))
-    slow(lambda: 'PIHOLE_DNS' in docker.run(_cat(SETUPVARS_LOC)).stdout)
-
-    # When we run setup dnsmasq during startup of the container
-    function = docker.run(EVAL_SETUP_DNSMASQ)
-    assert expected_stdout in function.stdout
-
-    # Then the servers are still what the user had customized if forced dnsmasq is not set
-    expected_servers = ['server={}'.format(dns1)]
-    if dns2:
-        expected_servers.append('server={}'.format(dns2))
-    slow(lambda: docker.run('grep "^server=[^/]" /etc/dnsmasq.d/01-pihole.conf').stdout.strip().split('\n') == \
-         expected_servers)
-
-
-@pytest.mark.parametrize('args_env, expected_stdout, expected_config_line', [    
+@pytest.mark.parametrize('args_env, expected_stdout, expected_config_line', [
     ('', 'binding to default interface: eth0', 'PIHOLE_INTERFACE=eth0'),
     ('-e INTERFACE="br0"', 'binding to custom interface: br0', 'PIHOLE_INTERFACE=br0'),
 ])
 def test_dns_interface_override_defaults(docker, slow, args_env, expected_stdout, expected_config_line):
     ''' When INTERFACE environment var is passed in, overwrite dnsmasq interface '''
-    function = docker.run(EVAL_SETUP_DNSMASQ)
+    function = docker.run(EVAL_SETUP_FTL_INTERFACE)
     assert expected_stdout in function.stdout
     slow(lambda: expected_config_line + '\n' == docker.run('grep "^PIHOLE_INTERFACE" {}'.format(SETUPVARS_LOC)).stdout)
 
 
 expected_debian_lines = [
     '"VIRTUAL_HOST" => "127.0.0.1"',
-    '"ServerIP" => "127.0.0.1"',
     '"PHP_ERROR_LOG" => "/var/log/lighttpd/error-pihole.log"'
 ]
 
@@ -191,8 +131,8 @@ def test_webpassword_random_generation(docker):
 
 @pytest.mark.parametrize('entrypoint,cmd', [('--entrypoint=tail','-f /dev/null')])
 @pytest.mark.parametrize('args_env,secure,setupvars_hash', [
-    ('-e ServerIP=1.2.3.4 -e WEBPASSWORD=login', True, 'WEBPASSWORD=6060d59351e8c2f48140f01b2c3f3b61652f396c53a5300ae239ebfbe7d5ff08'),
-    ('-e ServerIP=1.2.3.4 -e WEBPASSWORD=""', False, ''),
+    ('-e WEBPASSWORD=login', True, 'WEBPASSWORD=6060d59351e8c2f48140f01b2c3f3b61652f396c53a5300ae239ebfbe7d5ff08'),
+    ('-e WEBPASSWORD=""', False, ''),
 ])
 def test_webpassword_env_assigns_password_to_file_or_removes_if_empty(docker, args_env, secure, setupvars_hash):
     ''' When a user sets webPassword env the admin password gets set or removed if empty '''
@@ -209,10 +149,10 @@ def test_webpassword_env_assigns_password_to_file_or_removes_if_empty(docker, ar
 @pytest.mark.parametrize('entrypoint,cmd', [('--entrypoint=tail','-f /dev/null')])
 @pytest.mark.parametrize('test_args', ['-e WEBPASSWORD=login', '-e WEBPASSWORD=""'])
 def test_env_always_updates_password(docker, args_env, test_args):
-    '''When a user sets the WEBPASSWORD environment variable, ensure it always sets the password'''    
+    '''When a user sets the WEBPASSWORD environment variable, ensure it always sets the password'''
     function = docker.run(EVAL_SETUP_WEB_PASSWORD)
 
-    assert '::: Assigning password defined by Environment Variable' in function.stdout    
+    assert '::: Assigning password defined by Environment Variable' in function.stdout
 
 
 @pytest.mark.parametrize('entrypoint,cmd', [('--entrypoint=tail','-f /dev/null')])
diff --git a/test/test_start.py b/test/test_start.py
index 2f5c7a4..2439362 100644
--- a/test/test_start.py
+++ b/test/test_start.py
@@ -5,29 +5,21 @@ import time
 ''' Note, testinfra builtins don't seem fully compatible with
         docker containers (esp. musl based OSs) stripped down nature '''
 
-# If the test runs /start.sh, do not let s6 run it too!  Kill entrypoint to avoid race condition/duplicated execution
-@pytest.mark.parametrize('persist_entrypoint,persist_cmd,persist_args_env', [('--entrypoint=tail','-f /dev/null','')])
-def test_serverip_missing_is_not_required_anymore(running_pihole):
-    ''' When args to docker are empty start.sh exits saying ServerIP is required '''
-    start = docker.run('/start.sh')
-    error_msg = "ERROR: To function correctly you must pass an environment variables of 'ServerIP' into the docker container"
-    assert start.rc == 1
-    assert error_msg in start.stdout
 
 # If the test runs /start.sh, do not let s6 run it too!  Kill entrypoint to avoid race condition/duplicated execution
 @pytest.mark.parametrize('entrypoint,cmd', [('--entrypoint=tail','-f /dev/null')])
-@pytest.mark.parametrize('args,error_msg,expect_rc', [ 
-    ('-e ServerIP="1.2.3.z"', "ServerIP Environment variable (1.2.3.z) doesn't appear to be a valid IPv4 address",1), 
-    ('-e ServerIP="1.2.3.4" -e ServerIPv6="1234:1234:1234:ZZZZ"', "Environment variable (1234:1234:1234:ZZZZ) doesn't appear to be a valid IPv6 address",1),
-    ('-e ServerIP="1.2.3.4" -e ServerIPv6="kernel"', "ERROR: You passed in IPv6 with a value of 'kernel'",1),
+@pytest.mark.parametrize('args,error_msg,expect_rc', [
+    ('-e FTLCONF_REPLY_ADDR4="1.2.3.z"', "FTLCONF_REPLY_ADDR4 Environment variable (1.2.3.z) doesn't appear to be a valid IPv4 address",1),
+    ('-e FTLCONF_REPLY_ADDR4="1.2.3.4" -e FTLCONF_REPLY_ADDR6="1234:1234:1234:ZZZZ"', "Environment variable (1234:1234:1234:ZZZZ) doesn't appear to be a valid IPv6 address",1),
+    ('-e FTLCONF_REPLY_ADDR4="1.2.3.4" -e FTLCONF_REPLY_ADDR6="kernel"', "ERROR: You passed in IPv6 with a value of 'kernel'",1),
 ])
-def test_serverip_invalid_ips_triggers_exit_error(docker, error_msg, expect_rc):
-    ''' When args to docker are empty start.sh exits saying ServerIP is required '''
+def test_ftlconf_reply_addr_invalid_ips_triggers_exit_error(docker, error_msg, expect_rc):
     start = docker.run('/start.sh')
     assert start.rc == expect_rc
     assert 'ERROR' in start.stdout
     assert error_msg in start.stdout
 
+
 @pytest.mark.parametrize('hostname,expected_ip', [
     ('pi.hole',                        '127.0.0.1'),
     ('google-public-dns-a.google.com', '8.8.8.8'),
@@ -62,7 +54,7 @@ def test_admin_requests_load_as_expected(running_pihole, version, addr, url):
     validate_curl(http_rc, expected_http_code, page_contents)
     assert http_rc.rc == 0
     assert int(http_rc.stdout) == expected_http_code
-    for html_text in ['dns_queries_today', 'Content-Security-Policy', 
+    for html_text in ['dns_queries_today', 'Content-Security-Policy',
                       'scripts/pi-hole/js/footer.js']:
         # version removed, not showing up in footer of test env (fix me)
         assert html_text in page_contents
